*Generated by [Prodex](https://github.com/emxhive/prodex#readme)*
> Note for LLMs: `Lx-Ly` ranges refer to lines in this Prodex trace file, not the original source files. Index metadata is provided via the HTML comment markers in this section.

# Index
<!-- PRODEX_INDEX_RANGE: L8-L13 -->
<!-- PRODEX_FILE_COUNT: 6 -->
<!-- PRODEX_INDEX_LIST_START -->
- [src/react/adapters/reactflow/adapter.ts](#1)  L17-L521
- [src/react/adapters/reactflow/index.tsx](#2)  L522-L591
- [src/react/adapters/reactflow/toolbar.tsx](#3)  L592-L1050
- [src/react/adapters/reactflow/toolbar/icons.tsx](#4)  L1051-L1114
- [src/react/adapters/reactflow/toolbar/merge.ts](#5)  L1115-L1188
- [src/react/adapters/reactflow/toolbar/types.ts](#6)  L1189-L1276
<!-- PRODEX_INDEX_LIST_END -->

---
---
#### 1


` File: src/react/adapters/reactflow/adapter.ts`  [↑ Back to top](#index)

```ts
// src/react/adapters/reactflow/adapter.ts
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import type {
    Node,
    Edge,
    OnConnect,
    OnEdgesChange,
    OnNodesChange,
    Viewport as RFViewport,
    IsValidConnection,
    Connection,
    OnConnectStart,
    OnConnectEnd,
} from "reactflow";
import { applyNodeChanges, applyEdgeChanges } from "reactflow";
import type { CanvasAPI } from "../../canvas/api";
import type { CanvasState } from "../../../schema/canvas-types";
import type { EdgeKind } from "../../../schema/graph";
import { CommentThread } from "../../canvas/comments";

/* ───────────────────────────── Types & options ───────────────────────────── */

export type AdapterOptions = {
    // validation & policy
    beforeConnect?: (arg: {
        from: string;
        to: string;
        kind: EdgeKind;
        api: CanvasAPI;
    }) => { ok: boolean; reason?: string };
    afterConnect?: (arg: {
        from: string;
        to: string;
        kind: EdgeKind;
        created: boolean;
        api: CanvasAPI;
    }) => void;

    // behavior
    allowEdgeDelete?: boolean; // reserved
    enableShortcuts?: boolean; // reserved

    // snapping & perf
    snapToGrid?: boolean | { x: number; y: number };
    throttleMs?: number; // default 80ms

    // mapping/decoration
    nodeDecorators?: (nodeId: string) => Partial<Node>;
    edgeDecorators?: (edgeId: string) => Partial<Edge>;
};

type RFModel = { nodes: Node[]; edges: Edge[] };

/* ───────────────────────────── Utilities ───────────────────────────── */

function rafThrottle<T extends (...args: any[]) => void>(fn: T, minMs = 80): T {
    let frame = 0;
    let last = 0;
    let queuedArgs: any[] | null = null;

    const run = (now: number) => {
        frame = 0;
        last = now;
        const args = queuedArgs!;
        queuedArgs = null;
        fn(...(args as Parameters<T>));
    };

    return ((...args: any[]) => {
        queuedArgs = args;
        const now = performance.now();
        if (!frame) {
            if (now - last >= minMs) {
                run(now);
            } else {
                frame = requestAnimationFrame(run);
            }
        }
    }) as T;
}

const isCommentId = (id: string) => id.startsWith("c::");

function sameIdSet(a: string[], b: string[]): boolean {
    if (a.length !== b.length) return false;
    const s = new Set(a);
    for (const id of b) if (!s.has(id)) return false;
    return true;
}

/* ───────────────────────────── Mapping helpers ───────────────────────────── */

function commentPosition(
    th: CommentThread,
    state: CanvasState,
): { x: number; y: number } {
    const a = th.anchor;
    if (a.type === "free") return { x: a.position.x, y: a.position.y };
    if (a.type === "node") {
        const base = state.positions[a.nodeId] ?? { x: 0, y: 0 };
        const dx = a.offset?.dx ?? 32;
        const dy = a.offset?.dy ?? -16;
        return { x: base.x + dx, y: base.y + dy };
    }
    // edge-anchored: simple fallback (edge geometry not available here)
    return { x: 0, y: 0 };
}

function commentNodes(state: CanvasState, api: CanvasAPI): Node[] {
    return api.comments.list().map((th) => ({
        id: `c::${th.id}`,
        type: "comment",
        position: commentPosition(th, state),
        draggable: true,
        selectable: true,
        data: { thread: th },
    }));
}

function toRF(
    state: CanvasState,
    api: CanvasAPI,
    opts?: Pick<AdapterOptions, "nodeDecorators" | "edgeDecorators">,
): RFModel {
    const nodes: Node[] = state.graph.nodes.map((n) => {
        const base: Node = {
            id: n.id,
            type: n.kind,
            data: { node: n },
            position: state.positions[n.id] ?? { x: 0, y: 0 },
            selected: state.selection.has(n.id),
        };
        return opts?.nodeDecorators
            ? { ...base, ...(opts.nodeDecorators(n.id) ?? {}) }
            : base;
    });

    const edges: Edge[] = state.graph.edges.map((e) => {
        const id = `${e.kind}:${e.from}->${e.to}`;
        const base: Edge = {
            id,
            source: e.from,
            target: e.to,
            type: e.kind,
            data: { edge: e },
            // @ts-ignore
            selectable: true,
        };
        return opts?.edgeDecorators
            ? { ...base, ...(opts.edgeDecorators(id) ?? {}) }
            : base;
    });

    nodes.push(...commentNodes(state, api));
    return { nodes, edges };
}

// Parse "kind:from->to"
const parseEdgeId = (
    id: string,
): { kind: EdgeKind; from: string; to: string } | null => {
    const [k, rest] = id.split(":");
    if (!k || !rest) return null;
    const [from, to] = rest.split("->");
    if (!from || !to) return null;
    return { kind: k as EdgeKind, from, to };
};

/* ───────────────────────────── Hook ───────────────────────────── */

export function useReactFlowAdapter(
    api: CanvasAPI,
    options: AdapterOptions = {},
) {
    // derive, don’t mutate incoming options
    const throttleMs = options.throttleMs ?? 80;
    const snapToGridOpt = options.snapToGrid;
    const nodeDecorators = options.nodeDecorators;
    const edgeDecorators = options.edgeDecorators;

    // Stable refs for validation callbacks
    const beforeConnectRef = useRef(options.beforeConnect);
    const afterConnectRef = useRef(options.afterConnect);
    useEffect(() => {
        beforeConnectRef.current = options.beforeConnect;
    }, [options.beforeConnect]);
    useEffect(() => {
        afterConnectRef.current = options.afterConnect;
    }, [options.afterConnect]);

    const [rf, setRF] = useState<RFModel>(() =>
        toRF(api.snapshot(), api, { nodeDecorators, edgeDecorators }),
    );

    const relRef = useRef<EdgeKind>(api.getEdgeRel());
    const dragStartRef = useRef<{ from?: string } | null>(null);
    const lastViewportRef = useRef<RFViewport | null>(null);

    // snap grid tuple
    const snapVector = useMemo<[number, number] | undefined>(() => {
        if (!snapToGridOpt) return undefined;
        if (snapToGridOpt === true) return [8, 8];
        return [snapToGridOpt.x || 8, snapToGridOpt.y || 8];
    }, [snapToGridOpt]);

    // Subscribe to API *structural* changes only.
    // Avoid re-mapping during drag/viewport churn (positions live update locally).
    useEffect(() => {
        const toModel = () =>
            setRF(
                toRF(api.snapshot(), api, { nodeDecorators, edgeDecorators }),
            );

        const offGraph = api.on("graph:update", toModel);
        const offC1 = api.on("comment:thread:create", toModel);
        const offC2 = api.on("comment:thread:update", toModel);
        const offC3 = api.on("comment:thread:delete", toModel);
        const offC4 = api.on("comment:move", toModel);
        const offC5 = api.on("comment:resolve", toModel);

        return () => {
            offGraph();
            offC1();
            offC2();
            offC3();
            offC4();
            offC5();
        };
    }, [api, nodeDecorators, edgeDecorators]);

    /* ── handlers ── */

    const applySnap = useCallback(
        (p: { x: number; y: number }) => {
            if (!snapVector) return p;
            const [gx, gy] = snapVector;
            return {
                x: Math.round(p.x / gx) * gx,
                y: Math.round(p.y / gy) * gy,
            };
        },
        [snapVector],
    );

    const setPositionsThrottled = useMemo(
        () =>
            rafThrottle(
                (pos: Record<string, { x: number; y: number }>) =>
                    api.setPositions(pos),
                throttleMs,
            ),
        [api, throttleMs],
    );

    const setViewportThrottled = useMemo(
        () =>
            rafThrottle(
                (v: RFViewport) =>
                    api.setViewport({ x: v.x, y: v.y, zoom: v.zoom }),
                throttleMs,
            ),
        [api, throttleMs],
    );

    const onNodesChange: OnNodesChange = useCallback(
        async (changes) => {
            // 1) Update RF locally for buttery dragging
            setRF((prev) => ({
                nodes: applyNodeChanges(changes, prev.nodes),
                edges: prev.edges,
            }));

            // 2) Collect batched position + selection updates for API
            const posUpdates: Record<string, { x: number; y: number }> = {};
            let selectionDirty = false;
            const keep = new Set<string>(
                Array.isArray(api.getSelection())
                    ? (api.getSelection() as string[])
                    : Array.from(api.getSelection() as unknown as Set<string>),
            );

            for (const c of changes) {
                if (c.type === "position" && c.position) {
                    // Comment dragging → move comment anchor in API
                    if (isCommentId(c.id)) {
                        const threadId = c.id.slice(3);
                        const th = api.comments.get(threadId);
                        if (!th) continue;
                        const a = th.anchor;
                        if (a.type === "free") {
                            await api.comments.move(threadId, {
                                type: "free",
                                position: c.position,
                            });
                        } else if (a.type === "node") {
                            const nodePos = api.snapshot().positions[
                                a.nodeId
                            ] ?? { x: 0, y: 0 };
                            await api.comments.move(threadId, {
                                type: "node",
                                nodeId: a.nodeId,
                                offset: {
                                    dx: c.position.x - nodePos.x,
                                    dy: c.position.y - nodePos.y,
                                },
                            });
                        }
                        continue;
                    }
                    posUpdates[c.id] = applySnap(c.position);
                } else if (c.type === "select") {
                    if (!isCommentId(c.id)) {
                        selectionDirty = true;
                        if (c.selected) keep.add(c.id);
                        else keep.delete(c.id);
                    } else {
                        api.selectComments(
                            c.selected ? c.id.slice(3) : undefined,
                        );
                    }
                }
            }

            if (Object.keys(posUpdates).length)
                setPositionsThrottled(posUpdates);

            if (selectionDirty) {
                const next = Array.from(keep);
                const currRaw = api.getSelection();
                const curr = Array.isArray(currRaw)
                    ? (currRaw as string[])
                    : Array.from(currRaw as Set<string>);
                if (!sameIdSet(next, curr)) {
                    api.select(keep);
                }
            }
        },
        [api, applySnap, setPositionsThrottled],
    );

    const onEdgesChange: OnEdgesChange = useCallback(
        (changes) => {
            // 1) Update RF locally
            setRF((prev) => ({
                nodes: prev.nodes,
                edges: applyEdgeChanges(changes, prev.edges),
            }));

            // 2) Highlight + deletions to API
            const selectedEdgeIds: string[] = [];
            const deletions: Array<{
                kind: EdgeKind;
                from: string;
                to: string;
            }> = [];

            for (const c of changes) {
                if (c.type === "select") {
                    if (c.selected) selectedEdgeIds.push(c.id);
                } else if (c.type === "remove") {
                    const parsed = parseEdgeId(c.id);
                    if (parsed) deletions.push(parsed);
                }
            }

            if (selectedEdgeIds.length) {
                const endpointIds = new Set<string>();
                for (const id of selectedEdgeIds) {
                    const p = parseEdgeId(id);
                    if (!p) continue;
                    endpointIds.add(p.from);
                    endpointIds.add(p.to);
                }
                api.setHighlighted(endpointIds);
            } else {
                api.setHighlighted([]);
            }

            for (const d of deletions) {
                api.emit("wire:delete" as any, d);
            }
        },
        [api],
    );

    const currentRel = useCallback(() => {
        const k = api.getEdgeRel();
        relRef.current = k;
        return k;
    }, [api]);

    const isValidConnection: IsValidConnection = useCallback(
        (conn: Connection | Edge) => {
            const kind = currentRel();
            const from = conn.source ?? "";
            const to = conn.target ?? "";
            if (!from || !to) return false;
            if (from === to) return false;
            if (isCommentId(from) || isCommentId(to)) return false;

            const check = beforeConnectRef.current;
            if (check) {
                try {
                    return !!check({ from, to, kind, api }).ok;
                } catch {
                    return false;
                }
            }
            return true;
        },
        [api, currentRel],
    );

    const onConnectStart: OnConnectStart = useCallback(
        (_, { nodeId }) => {
            if (!nodeId) return;
            dragStartRef.current = { from: nodeId };
            const kind = currentRel();
            api.startWire(nodeId, kind);
        },
        [api, currentRel],
    );

    const onConnectEnd: OnConnectEnd = useCallback(() => {
        dragStartRef.current = null;
        api.cancelWire();
    }, [api]);

    const onConnect: OnConnect = useCallback(
        (params) => {
            const from = params.source!;
            const to = params.target!;
            const kind = currentRel();

            const check = beforeConnectRef.current;
            if (check) {
                const res = check({ from, to, kind, api });
                if (!res.ok) {
                    api.cancelWire();
                    return;
                }
            }

            api.startWire(from, kind);
            api.commitWire(to);
            afterConnectRef.current?.({ from, to, kind, created: true, api });
            dragStartRef.current = null;
        },
        [api, currentRel],
    );

    const onMoveEnd = useCallback(
        (_evt: any, viewport: RFViewport) => {
            const prev = lastViewportRef.current;
            const changed =
                !prev ||
                Math.abs(prev.x - viewport.x) > 0.5 ||
                Math.abs(prev.y - viewport.y) > 0.5 ||
                Math.abs(prev.zoom - viewport.zoom) > 1e-4;

            if (changed) {
                lastViewportRef.current = viewport;
                setViewportThrottled(viewport);
            }
        },
        [setViewportThrottled],
    );

    const onSelectionChange = useCallback(
        ({ nodes }: { nodes: Node[]; edges: Edge[] }) => {
            console.log("onSelectionChange", nodes);
            const next = nodes.map((n) => n.id);
            const currRaw = api.getSelection();
            const curr = Array.isArray(currRaw)
                ? (currRaw as string[])
                : Array.from(currRaw as Set<string>);
            if (sameIdSet(next, curr)) return;
            api.select(next);
        },
        [api],
    );

    return {
        nodes: rf.nodes,
        edges: rf.edges,
        onNodesChange,
        onEdgesChange,
        onConnect,
        onConnectStart,
        onConnectEnd,
        onMoveEnd,
        onSelectionChange,
        isValidConnection,
        snapVector,
    };
}
```

---
#### 2


` File: src/react/adapters/reactflow/index.tsx`  [↑ Back to top](#index)

```tsx
// src/react/adapters/reactflow/index.tsx
import React from "react";
import { Canvas } from "@/components/canvas";
import { useCanvasAPI } from "@/context/context";
import type { AdapterOptions } from "./adapter";
import type { ToolsConfig, LabelPlacement } from "./toolbar/types";

export type FlowCanvasProps = {
    tools?: ToolsConfig;
    /** 'dev' enables richer UX; 'prod' can hide some helpers */
    mode?: "dev" | "prod";
    /** Show/position the toolbar (inside the ReactFlow surface) */
    showToolbar?: boolean;
    toolbarPositionClassName?: string; // e.g. "left-2 top-2"

    /** How labels render on buttons: tooltip | inline | below | none */
    labelPlacement?: LabelPlacement;

    /** Pass custom renderer for individual tool buttons */
    renderTool?: React.ComponentProps<typeof Canvas>["renderTool"];

    /** Initial layer toggles */
    initialShowGrid?: boolean;
    initialShowMiniMap?: boolean;

    /** Adapter options (snapping etc.) */
    options?: AdapterOptions;
};

const FlowCanvas: React.FC<FlowCanvasProps> = ({
    tools,
    showToolbar = true,
    toolbarPositionClassName,
    labelPlacement = "tooltip",
    renderTool,
    initialShowGrid = true,
    initialShowMiniMap = false,
    options,
}) => {
    const api = useCanvasAPI();

    return (
        <Canvas
            api={api}
            tools={tools}
            showToolbar={showToolbar}
            toolbarPositionClassName={toolbarPositionClassName}
            labelPlacement={labelPlacement}
            renderTool={renderTool}
            initialShowGrid={initialShowGrid}
            initialShowMiniMap={initialShowMiniMap}
            options={options}
        />
    );
};

export default FlowCanvas;

// Optional convenience re-exports
export { Canvas };
export type { ToolsConfig, LabelPlacement, AdapterOptions };
```

---
#### 3


` File: src/react/adapters/reactflow/toolbar.tsx`  [↑ Back to top](#index)

```tsx
import React, { useMemo, useState, useCallback } from "react";
import { useReactFlow } from "reactflow";
import type { CanvasAPI } from "../../canvas/api";
import { resolveTools } from "./toolbar/merge";
import type {
    ResolvedTools,
    ToolContext,
    ToolsConfig,
    LabelPlacement,
    ToolDescriptor,
} from "./toolbar/types";
import { Icons } from "./toolbar/icons";

export type ToolbarProps = {
    api: CanvasAPI;
    mode?: "dev" | "prod";
    showGrid: boolean;
    setShowGrid: (v: boolean) => void;
    showMiniMap: boolean;
    setShowMiniMap: (v: boolean) => void;

    tools?: ToolsConfig;
    /** Default: 'tooltip' (hidden label, shown as native tooltip) */
    labelPlacement?: LabelPlacement;
    /** Optional custom button renderer */
    renderButton?: (t: ToolRender, key: string) => React.ReactNode;
};

export type ToolRender = {
    id: string;
    label?: string;
    icon?: React.ReactNode;
    active: boolean;
    disabled: boolean;
    disabledReason?: string;
    onClick: () => void;
    group?: string;
    hasMenu?: boolean;
    open?: boolean;
    onToggleMenu?: () => void;
    children?: ToolRender[];
};

export function Toolbar({
    api,
    mode = "dev",
    showGrid,
    setShowGrid,
    showMiniMap,
    setShowMiniMap,
    tools,
    labelPlacement = "tooltip",
    renderButton,
}: ToolbarProps) {
    const rf = useReactFlow();
    const [openMenuId, setOpenMenuId] = useState<string | null>(null);

    const selectionCount = api.getSelection().length;
    const relation = api.getEdgeRel();
    const canUndo = true;
    const canRedo = true;

    const ctx: ToolContext = useMemo(
        () => ({
            api,
            env: { mode },
            state: {
                relation,
                selectionCount,
                canUndo,
                canRedo,
                showGrid,
                showMiniMap,
            },
            flow: {
                zoomIn: () => rf.zoomIn?.(),
                zoomOut: () => rf.zoomOut?.(),
                fitView: () => rf.fitView?.(),
            },
            setRelation: (rel) => api.setEdgeRel(rel),
            toggleGrid: () => setShowGrid(!showGrid),
            toggleMiniMap: () => setShowMiniMap(!showMiniMap),
        }),
        [
            api,
            mode,
            relation,
            selectionCount,
            showGrid,
            showMiniMap,
            rf,
            setShowGrid,
            setShowMiniMap,
        ],
    );

    const descriptors: ResolvedTools = useMemo(
        () => resolveTools({ base: defaultTools(), ...(tools ?? {}) }),
        [tools],
    );

    const buildRenderable = useCallback(
        (defs: ToolDescriptor[]): ToolRender[] => {
            return defs
                .filter((t) => (t.when ? !!t.when(ctx) : true))
                .map((t) => {
                    const en = t.enabled ? t.enabled(ctx) : true;
                    const enabledOk =
                        typeof en === "boolean" ? en : en.ok !== false;
                    const reason =
                        typeof en === "boolean" ? undefined : en.reason;
                    const active = t.active ? !!t.active(ctx) : false;

                    let iconNode: React.ReactNode | undefined;
                    if (typeof t.icon === "function")
                        iconNode = t.icon(active, !enabledOk);
                    else if (typeof t.icon === "string")
                        iconNode = mapIcon(t.icon, active);

                    const onClick = async () => {
                        if (!enabledOk || !t.action) return;
                        try {
                            t.onBefore?.(ctx);
                            await t.action(ctx);
                            t.onAfter?.(ctx);
                        } catch (err) {
                            t.onError?.(ctx, err);
                            api.emit("error", {
                                message:
                                    (err as any)?.message ??
                                    "Tool action failed",
                                meta: { tool: t.id },
                            });
                        }
                    };

                    const hasMenu = !!(t.children && t.children.length);
                    const children = hasMenu
                        ? buildRenderable(t.children!)
                        : undefined;

                    return {
                        id: t.id,
                        label: t.label,
                        icon: iconNode,
                        active,
                        disabled: !enabledOk,
                        disabledReason: reason,
                        onClick,
                        group: t.group,
                        hasMenu,
                        open: hasMenu && openMenuId === t.id,
                        onToggleMenu: hasMenu
                            ? () =>
                                  setOpenMenuId(
                                      openMenuId === t.id ? null : t.id,
                                  )
                            : undefined,
                        children,
                    } as ToolRender;
                });
        },
        [ctx, api, openMenuId],
    );

    const items: ToolRender[] = buildRenderable(descriptors);
    const groups = groupBy(items, (i) => i.group ?? "view");

    return (
        <div className="dsb-toolbar pointer-events-none absolute left-2 top-2 z-10 grid gap-2">
            {Object.entries(groups).map(([g, arr]) => (
                <div
                    key={g}
                    className="dsb-toolbar__group pointer-events-auto flex gap-1 rounded-lg border border-border bg-card/90 p-1 shadow-sm"
                >
                    {arr.map((btn) =>
                        renderButton ? (
                            renderButton(btn, btn.id)
                        ) : (
                            <DefaultTool
                                key={btn.id}
                                {...btn}
                                labelPlacement={labelPlacement}
                            />
                        ),
                    )}
                </div>
            ))}
        </div>
    );
}

/* ------------------- Built-in tools (with Tailwind icons) ------------------- */

function defaultTools(): ToolDescriptor[] {
    return [
        {
            id: "mode:bind",
            kind: "mode",
            group: "relation",
            order: 10,
            label: "Bind",
            icon: (active) => Icons.bind(active),
            active: (ctx) => ctx.state.relation === "bind",
            action: (ctx) => ctx.setRelation("bind"),
        },
        {
            id: "mode:include",
            kind: "mode",
            group: "relation",
            order: 20,
            label: "Include",
            icon: (active) => Icons.include(active),
            active: (ctx) => ctx.state.relation === "include",
            action: (ctx) => ctx.setRelation("include"),
        },
        {
            id: "mode:exclude",
            kind: "mode",
            group: "relation",
            order: 30,
            label: "Exclude",
            icon: (active) => Icons.exclude(active),
            active: (ctx) => ctx.state.relation === "exclude",
            action: (ctx) => ctx.setRelation("exclude"),
        },

        {
            id: "view:grid",
            kind: "toggle",
            group: "view",
            order: 10,
            label: "Grid",
            icon: (a) => Icons.grid(a),
            active: (ctx) => ctx.state.showGrid,
            action: (ctx) => ctx.toggleGrid(),
        },
        {
            id: "view:minimap",
            kind: "toggle",
            group: "view",
            order: 20,
            label: "Minimap",
            icon: (a) => Icons.minimap(a),
            active: (ctx) => ctx.state.showMiniMap,
            action: (ctx) => ctx.toggleMiniMap(),
        },

        // Example dropdown (menu) with viewport controls
        {
            id: "zoom:menu",
            kind: "menu",
            group: "viewport",
            order: 5,
            label: "Viewport",
            icon: () => Icons.fit(),
            children: [
                {
                    id: "zoom:in",
                    kind: "command",
                    label: "Zoom In",
                    icon: () => Icons.zoomIn(),
                    action: (ctx) => ctx.flow.zoomIn(),
                },
                {
                    id: "zoom:out",
                    kind: "command",
                    label: "Zoom Out",
                    icon: () => Icons.zoomOut(),
                    action: (ctx) => ctx.flow.zoomOut(),
                },
                {
                    id: "zoom:fit",
                    kind: "command",
                    label: "Fit",
                    icon: () => Icons.fit(),
                    action: (ctx) => ctx.flow.fitView(),
                },
            ],
        },
    ];
}

/* ------------------- Renderers ------------------- */

function DefaultTool({
    id,
    label,
    icon,
    active,
    disabled,
    disabledReason,
    onClick,
    hasMenu,
    open,
    onToggleMenu,
    children,
    group,
    labelPlacement,
}: ToolRender & { labelPlacement: LabelPlacement }) {
    const baseBtn =
        "dsb-tool inline-flex items-center justify-center rounded-md border border-border bg-card px-2 py-1 text-xs text-muted-foreground hover:bg-accent hover:text-accent-foreground aria-pressed:bg-accent aria-pressed:text-accent-foreground " +
        (active ? "ring-1 ring-ring bg-accent text-accent-foreground" : "") +
        (disabled ? " opacity-50 cursor-not-allowed" : "");

    const title =
        labelPlacement === "tooltip"
            ? disabled
                ? (disabledReason ?? label)
                : label
            : undefined;

    const content = (
        <>
            {icon ?? null}
            {labelPlacement === "inline" && label && (
                <span className="ml-1">{label}</span>
            )}
            {labelPlacement === "below" && label && (
                <span className="mt-0.5 block text-[10px] leading-3 text-muted-foreground">
                    {label}
                </span>
            )}
            {hasMenu && <span className="ml-1">{Icons.chevronDown()}</span>}
        </>
    );

    if (!hasMenu) {
        return (
            <button
                type="button"
                title={title}
                aria-pressed={active}
                disabled={disabled}
                onClick={onClick}
                className={
                    baseBtn +
                    " h-8 w-8 " +
                    (labelPlacement === "below" ? "flex-col" : "")
                }
            >
                {content}
            </button>
        );
    }

    // Menu root
    return (
        <div className="relative">
            <button
                type="button"
                title={title}
                aria-expanded={open ? "true" : "false"}
                disabled={disabled}
                onClick={onToggleMenu}
                className={
                    baseBtn +
                    " h-8 w-8 " +
                    (labelPlacement === "below" ? "flex-col" : "")
                }
            >
                {content}
            </button>

            {open && (
                <div
                    className="absolute left-0 z-20 mt-1 min-w-[10rem] overflow-hidden rounded-md border border-border bg-popover shadow-lg"
                    role="menu"
                >
                    <ul className="divide-y divide-border">
                        {children?.map((ch) => (
                            <li key={ch.id} className="p-0">
                                <button
                                    type="button"
                                    role="menuitem"
                                    title={
                                        labelPlacement === "tooltip"
                                            ? ch.disabled
                                                ? (ch.disabledReason ??
                                                  ch.label)
                                                : ch.label
                                            : undefined
                                    }
                                    disabled={ch.disabled}
                                    onClick={ch.onClick}
                                    className={
                                        "flex w-full items-center gap-2 px-3 py-2 text-sm hover:bg-accent hover:text-accent-foreground " +
                                        (ch.disabled
                                            ? "opacity-50 cursor-not-allowed"
                                            : "")
                                    }
                                >
                                    {ch.icon ?? null}
                                    {labelText(ch.label, "inline")}
                                </button>
                            </li>
                        ))}
                    </ul>
                </div>
            )}
        </div>
    );
}

function labelText(label?: string, placement: LabelPlacement = "tooltip") {
    if (!label || placement === "none" || placement === "tooltip") return null;
    if (placement === "inline") return <span>{label}</span>;
    if (placement === "below")
        return (
            <span className="block text-[10px] leading-3 text-muted-foreground">
                {label}
            </span>
        );
    return null;
}

function mapIcon(token: string, active: boolean): React.ReactNode {
    switch (token) {
        case "bind":
            return Icons.bind(active);
        case "include":
            return Icons.include(active);
        case "exclude":
            return Icons.exclude(active);
        case "zoom-in":
            return Icons.zoomIn();
        case "zoom-out":
            return Icons.zoomOut();
        case "fit":
            return Icons.fit();
        case "grid":
            return Icons.grid(active);
        case "minimap":
            return Icons.minimap(active);
        default:
            return (
                <span className="text-xs text-muted-foreground">{token}</span>
            );
    }
}

function groupBy<T>(arr: T[], key: (t: T) => string): Record<string, T[]> {
    const out: Record<string, T[]> = {};
    for (const x of arr) {
        const k = key(x);
        if (!out[k]) out[k] = [];
        out[k].push(x);
    }
    return out;
}
```

---
#### 4


` File: src/react/adapters/reactflow/toolbar/icons.tsx`  [↑ Back to top](#index)

```tsx
import React from 'react';

export const Icons = {
    bind: (active = false) => (
        <svg className={`h-4 w-4 ${active ? 'text-primary' : 'text-muted-foreground'}`} viewBox="0 0 20 20" fill="none">
            <path d="M6 8a4 4 0 014-4h2a4 4 0 110 8H9" stroke="currentColor" strokeWidth="2"/>
            <path d="M14 12a4 4 0 01-4 4H8a4 4 0 110-8h3" stroke="currentColor" strokeWidth="2"/>
        </svg>
    ),
    include: (active = false) => (
        <svg className={`h-4 w-4 ${active ? 'text-primary' : 'text-muted-foreground'}`} viewBox="0 0 20 20" fill="none">
            <path d="M8 10h8M8 14h8M8 6h8M4 6h.01M4 10h.01M4 14h.01" stroke="currentColor" strokeWidth="2"/>
        </svg>
    ),
    exclude: (active = false) => (
        <svg className={`h-4 w-4 ${active ? 'text-primary' : 'text-muted-foreground'}`} viewBox="0 0 20 20" fill="none">
            <path d="M5 5l10 10M15 5L5 15" stroke="currentColor" strokeWidth="2"/>
        </svg>
    ),
    zoomIn: () => (
        <svg className="h-4 w-4 text-muted-foreground" viewBox="0 0 20 20" fill="none">
            <path d="M9 9V5m0 4H5m4 0h4m-4 0v4" stroke="currentColor" strokeWidth="2"/>
            <circle cx="9" cy="9" r="6" stroke="currentColor" strokeWidth="2"/>
            <path d="M13.5 13.5L18 18" stroke="currentColor" strokeWidth="2"/>
        </svg>
    ),
    zoomOut: () => (
        <svg className="h-4 w-4 text-muted-foreground" viewBox="0 0 20 20" fill="none">
            <path d="M5 9h8" stroke="currentColor" strokeWidth="2"/>
            <circle cx="9" cy="9" r="6" stroke="currentColor" strokeWidth="2"/>
            <path d="M13.5 13.5L18 18" stroke="currentColor" strokeWidth="2"/>
        </svg>
    ),
    fit: () => (
        <svg className="h-4 w-4 text-muted-foreground" viewBox="0 0 20 20" fill="none">
            <path d="M3 7V3h4M17 7V3h-4M3 13v4h4M17 13v4h-4" stroke="currentColor" strokeWidth="2"/>
        </svg>
    ),
    grid: (active = false) => (
        <svg className={`h-4 w-4 ${active ? 'text-primary' : 'text-muted-foreground'}`} viewBox="0 0 20 20" fill="none">
            <path d="M3 7h14M3 13h14M7 3v14M13 3v14" stroke="currentColor" strokeWidth="2"/>
        </svg>
    ),
    minimap: (active = false) => (
        <svg className={`h-4 w-4 ${active ? 'text-primary' : 'text-muted-foreground'}`} viewBox="0 0 20 20" fill="none">
            <rect x="3" y="4" width="14" height="12" rx="2" stroke="currentColor" strokeWidth="2"/>
            <rect x="6" y="7" width="6" height="6" rx="1" fill="currentColor"/>
        </svg>
    ),
    chevronDown: () => (
        <svg className="h-3 w-3 text-muted-foreground" viewBox="0 0 20 20" fill="none">
            <path d="M6 8l4 4 4-4" stroke="currentColor" strokeWidth="2"/>
        </svg>
    ),
};
```

---
#### 5


` File: src/react/adapters/reactflow/toolbar/merge.ts`  [↑ Back to top](#index)

```ts
import type {ResolvedTools, ToolDescriptor, ToolsConfig} from './types';

export function resolveTools(config: ToolsConfig): ResolvedTools {
    const base = dedupeById(config.base ?? []);
    const extended = dedupeById(config.extend ?? []);
    const hidden = new Set(config.hidden ?? []);

    const byId = new Map<string, ToolDescriptor>();
    for (const t of base) byId.set(t.id, t);
    for (const t of extended) byId.set(t.id, t);

    let arr = Array.from(byId.values()).filter(t => !hidden.has(t.id));
    arr = sortWithAnchors(arr);
    arr.sort((a, b) => {
        const ga = a.group ?? 'view';
        const gb = b.group ?? 'view';
        if (ga !== gb) return ga < gb ? -1 : 1;
        const oa = a.order ?? 0;
        const ob = b.order ?? 0;
        return oa - ob;
    });

    return arr;
}

function dedupeById(list: ToolDescriptor[]): ToolDescriptor[] {
    const seen = new Set<string>();
    const out: ToolDescriptor[] = [];
    for (const t of list) {
        if (seen.has(t.id)) continue;
        seen.add(t.id);
        out.push(t);
    }
    return out;
}

function sortWithAnchors(list: ToolDescriptor[]): ToolDescriptor[] {
    const byId = new Map(list.map(t => [t.id, t]));
    const out: ToolDescriptor[] = [];
    const placed = new Set<string>();

    const place = (t: ToolDescriptor) => {
        if (placed.has(t.id)) return;
        if (t.insertBefore && byId.has(t.insertBefore)) {
            const anchor = byId.get(t.insertBefore)!;
            place(anchor);
            const idx = out.findIndex(x => x.id === anchor.id);
            out.splice(idx, 0, t);
            placed.add(t.id);
            return;
        }
        if (t.insertAfter && byId.has(t.insertAfter)) {
            place(byId.get(t.insertAfter)!);
            const idx = out.findIndex(x => x.id === t.insertAfter);
            out.splice(idx + 1, 0, t);
            placed.add(t.id);
            return;
        }
        out.push(t);
        placed.add(t.id);
    };

    for (const t of list) place(t);
    return out;
}
```

---
#### 6


` File: src/react/adapters/reactflow/toolbar/types.ts`  [↑ Back to top](#index)

```ts
import type {CanvasAPI} from "../../../canvas/api";
import type React from "react";

export type ToolKind = 'command' | 'toggle' | 'mode' | 'menu';

export type ToolGroup =
    | 'relation'
    | 'viewport'
    | 'view'
    | 'edit'
    | (string & {});

export type EnabledState = boolean | { ok: boolean; reason?: string };

export type ToolbarIcon =
    | string
    | ((active: boolean, disabled: boolean) => React.ReactNode);

export type LabelPlacement = 'tooltip' | 'inline' | 'below' | 'none';

export type ToolDescriptor = {
    id: string;
    kind: ToolKind;
    label?: string;
    group?: ToolGroup;
    order?: number;
    icon?: ToolbarIcon;
    hotkey?: string;

    /** Optional dropdown children (rendered as a menu). */
    children?: ToolDescriptor[];

    // Visibility and state
    when?: (ctx: ToolContext) => boolean;
    enabled?: (ctx: ToolContext) => EnabledState;
    active?: (ctx: ToolContext) => boolean;

    // Mutations
    action?: (ctx: ToolContext) => void | Promise<void>;
    onBefore?: (ctx: ToolContext) => void;
    onAfter?: (ctx: ToolContext) => void;
    onError?: (ctx: ToolContext, err: unknown) => void;

    // Placement helpers
    insertBefore?: string;
    insertAfter?: string;
};

export type ToolContext = {
    api: CanvasAPI;
    env: { mode: 'dev' | 'prod' };
    state: {
        relation: ReturnType<CanvasAPI['getEdgeRel']>;
        selectionCount: number;
        canUndo: boolean;
        canRedo: boolean;
        showGrid: boolean;
        showMiniMap: boolean;
    };
    flow: {
        zoomIn: () => void;
        zoomOut: () => void;
        fitView: () => void;
    };
    setRelation: (rel: ReturnType<CanvasAPI['getEdgeRel']>) => void;
    toggleGrid: () => void;
    toggleMiniMap: () => void;
};

export type ToolsConfig = {
    base?: ToolDescriptor[];
    extend?: ToolDescriptor[];
    hidden?: string[];
};

export type ResolvedTools = ToolDescriptor[];
```


---
*Generated with [Prodex](https://github.com/emxhive/prodex) — Codebase decoded.*
<!-- PRODEx v1.4.11 | 2026-01-20T14:32:20.260Z -->