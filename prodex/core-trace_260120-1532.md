*Generated by [Prodex](https://github.com/emxhive/prodex#readme)*
> Note for LLMs: `Lx-Ly` ranges refer to lines in this Prodex trace file, not the original source files. Index metadata is provided via the HTML comment markers in this section.

# Index
<!-- PRODEX_INDEX_RANGE: L8-L24 -->
<!-- PRODEX_FILE_COUNT: 17 -->
<!-- PRODEX_INDEX_LIST_START -->
- [src/core/__tests__/builder.test.ts](#1)  L28-L272
- [src/core/__tests__/fallback.spec.ts](#2)  L273-L492
- [src/core/__tests__/normalise.constraints.test.ts](#3)  L493-L563
- [src/core/__tests__/normalise.test.ts](#4)  L564-L755
- [src/core/__tests__/policy.test.ts](#5)  L756-L826
- [src/core/__tests__/utility-validation.spec.ts](#6)  L827-L1040
- [src/core/__tests__/validate.policies.test.ts](#7)  L1041-L1162
- [src/core/__tests__/validate.rate-coherence.spec.ts](#8)  L1163-L1439
- [src/core/__tests__/validate.test.ts](#9)  L1440-L1903
- [src/core/__tests__/validation.rate-coherence2.spec.ts](#10)  L1904-L2175
- [src/core/builder.ts](#11)  L2176-L2672
- [src/core/fallback.ts](#12)  L2673-L3039
- [src/core/index.ts](#13)  L3040-L3053
- [src/core/normalise.ts](#14)  L3054-L3493
- [src/core/policy.ts](#15)  L3494-L3677
- [src/core/rate-coherence.ts](#16)  L3678-L3996
- [src/core/validate.ts](#17)  L3997-L4858
<!-- PRODEX_INDEX_LIST_END -->

---
---
#### 1


` File: src/core/__tests__/builder.test.ts`  [↑ Back to top](#index)

```ts
import {describe, it, expect} from 'vitest';
import {createBuilder} from '../builder';
import type {ServiceProps} from '../../schema';
import type {DgpServiceMap} from '../../schema/provider';

describe('Builder', () => {
    it('load() normalises payload and builds indices', () => {
        const b = createBuilder();
        // No root provided → normalise() should inject it
        const props: ServiceProps = {filters: [], fields: []};
        b.load(props);

        const got = b.getProps();
        expect(Array.isArray(got.filters)).toBe(true);
        expect(got.filters[0]?.id).toBe('root');
    });

    it('tree() yields tag/field nodes and edges (child/bind/include/exclude)', () => {
        const b = createBuilder();
        b.load({
            filters: [
                {id: 'root', label: 'Root'},
                {id: 'A', label: 'A', bind_id: 'root', includes: ['fX'], excludes: ['fY']},
            ],
            fields: [
                {id: 'f1', label: 'F1', type: 'text', bind_id: 'A'},
                {id: 'fX', label: 'FX', type: 'text'},
                {id: 'fY', label: 'FY', type: 'text'},
            ],
        });

        const g = b.tree();
        // nodes include tags + fields
        const nodeIds = new Set(g.nodes.map(n => n.id));
        expect(nodeIds.has('root')).toBe(true);
        expect(nodeIds.has('A')).toBe(true);
        expect(nodeIds.has('f1')).toBe(true);
        expect(nodeIds.has('fX')).toBe(true);

        // edges include child (root->A), bind (A->f1), include/exclude from A
        const sig = g.edges.map(e => `${e.kind}:${e.from}->${e.to}`);
        expect(sig).toContain('child:root->A');
        expect(sig).toContain('bind:A->f1');
        expect(sig).toContain('include:A->fX');
        expect(sig).toContain('exclude:A->fY');
    });

    it('visibleFields(tagId) respects bind/include − exclude (static)', () => {
        const b = createBuilder();
        b.load({
            filters: [
                {id: 'root', label: 'Root'},
                {id: 'G', label: 'Group', bind_id: 'root', includes: ['fInc'], excludes: ['fExc']},
            ],
            fields: [
                {id: 'fBound', label: 'Bound', type: 'text', bind_id: 'G'},
                {id: 'fInc', label: 'Inc', type: 'text'},
                {id: 'fExc', label: 'Exc', type: 'text', bind_id: 'G'},
                {id: 'fOther', label: 'Other', type: 'text'},
            ],
        });

        const vis = b.visibleFields('G');
        expect(vis).toContain('fBound');
        expect(vis).toContain('fInc');       // included
        expect(vis).not.toContain('fExc');   // excluded
        expect(vis).not.toContain('fOther'); // neither bound nor included
    });

    it('visibleFields(tagId, selectedOptionKeys) applies option-level maps when provided', () => {
        const b = createBuilder();
        b.load({
            filters: [{id: 'root', label: 'Root'}, {id: 'T', label: 'T', bind_id: 'root'}],
            fields: [
                {
                    id: 'toggle', label: 'Toggle', type: 'radio', bind_id: 'T',
                    options: [{id: 'on', label: 'On'}, {id: 'off', label: 'Off'}]
                },
                {id: 'base', label: 'Base', type: 'text', bind_id: 'T'},
                {id: 'util', label: 'Util', type: 'text'}, // not bound; will be included by option map
            ],
            includes_for_buttons: {'toggle::on': ['util']},
            excludes_for_buttons: {'toggle::on': ['base']},
        });

        const visOn = b.visibleFields('T', ['toggle::on']);
        const visOff = b.visibleFields('T', ['toggle::off']);

        expect(visOn).toContain('util');  // included by option
        expect(visOn).not.toContain('base');   // excluded by option
        expect(visOff).not.toContain('util');  // not included without selection
        expect(visOff).toContain('base');      // not excluded without selection
    });

    it('visibleFields uses builder.setOptions({ selectedOptionKeys }) when no argument is passed', () => {
        const b = createBuilder();
        b.load({
            filters: [{id: 'root', label: 'Root'}, {id: 'T', label: 'T', bind_id: 'root'}],
            fields: [
                {
                    id: 'toggle', label: 'Toggle', type: 'radio', bind_id: 'T',
                    options: [{id: 'on', label: 'On'}, {id: 'off', label: 'Off'}]
                },
                {id: 'showme', label: 'ShowMe', type: 'text'},
            ],
            includes_for_buttons: {'toggle::on': ['showme']},
        });

        b.setOptions({selectedOptionKeys: ['toggle::on']});
        const vis = b.visibleFields('T'); // no arg; uses options
        expect(vis).toContain('showme');
    });

    it('errors() integrates validate(): duplicate visible labels and custom rules surface', () => {
        const b = createBuilder();
        b.load({
            filters: [{id: 'root', label: 'Root'}, {id: 'G', label: 'Group', bind_id: 'root'}],
            fields: [
                {id: 'x', label: 'Same', type: 'text', name: 'n1', bind_id: 'G'},
                {id: 'y', label: 'Same', type: 'text', name: 'n2', bind_id: 'G'}, // duplicate_visible_label under G
                {id: 'c', label: 'C', type: 'custom', bind_id: 'G'},              // custom missing component
            ],
        });
        const errs = b.errors().map(e => e.code);
        expect(errs).toContain('duplicate_visible_label');
        expect(errs).toContain('custom_component_missing');
    });

    it('cleanedProps() drops unbound utility fields that are excluded and prunes option maps', () => {
        const b = createBuilder();
        b.load({
            filters: [
                {id: 'root', label: 'Root'},
                {id: 'T', label: 'T', bind_id: 'root', excludes: ['u_orphan']}, // explicit exclude
            ],
            fields: [
                // unbound utility, excluded → will be dropped by cleanedProps()
                {id: 'u_orphan', label: 'U-orphan', type: 'text', pricing_role: 'utility'},
                // referenced via option include → kept
                {id: 'u_ref', label: 'U-ref', type: 'text', pricing_role: 'utility'},
                // regular bound field
                {id: 'f1', label: 'F1', type: 'text', bind_id: 'T'},
            ],
            includes_for_buttons: {
                'f1::o1': ['u_ref', 'ghost_field'],
            },
            excludes_for_buttons: {
                'f1::o2': ['ghost_field'],
            },
        });

        const cleaned = b.cleanedProps();

        const fieldIds = cleaned.fields.map(f => f.id);
        expect(fieldIds).not.toContain('u_orphan'); // dropped
        expect(fieldIds).toContain('u_ref');        // kept (referenced by option-map include)
        expect(fieldIds).toContain('f1');

        // option maps pruned to existing field ids only
        expect(cleaned.includes_for_buttons?.['f1::o1']).toEqual(['u_ref']);
        expect(cleaned.excludes_for_buttons?.['f1::o2']).toBeUndefined(); // entire entry removed (all ghost)
    });

    it('undo()/redo() restore previous/next props snapshots', () => {
        const b = createBuilder();

        // initial
        b.load({filters: [], fields: []}); // normalise injects root
        const firstId = b.getProps().filters[0].id;
        expect(firstId).toBe('root');

        // next
        b.load({
            filters: [{id: 'root', label: 'Root'}, {id: 'A', label: 'A', bind_id: 'root'}],
            fields: [],
        });
        expect(b.getProps().filters.some(t => t.id === 'A')).toBe(true);

        // undo → back to previous (no 'A')
        expect(b.undo()).toBe(true);
        expect(b.getProps().filters.some(t => t.id === 'A')).toBe(false);

        // redo → forward (has 'A')
        expect(b.redo()).toBe(true);
        expect(b.getProps().filters.some(t => t.id === 'A')).toBe(true);
    });

    it('cleanedProps preserves schema_version and returns canonical keys only', () => {
        const b = createBuilder();
        b.load({
            filters: [{id: 'root', label: 'Root'}],
            fields: [],
            unknown: 'x',
            schema_version: '2.0',
        } as any);

        const cleaned = b.cleanedProps();
        expect(cleaned.schema_version).toBe('2.0');
        expect(Object.keys(cleaned).sort()).toEqual(
            ['excludes_for_options', 'filters', 'fields', 'includes_for_options', 'schema_version']
                .filter(k => (cleaned as any)[k] !== undefined)
                .sort()
        );
    });

    it('visibleFields returns [] for unknown tag id', () => {
        const b = createBuilder();
        b.load({filters: [{id: 'root', label: 'Root'}], fields: []});
        expect(b.visibleFields('nope')).toEqual([]);
    });

    it('errors() can use serviceMap in options (e.g., rate mismatch check)', () => {
        const b = createBuilder({
            serviceMap: {
                1: {id: 1, rate: 10},
                2: {id: 2, rate: 20},
            } satisfies DgpServiceMap,
        });
        b.load({
            filters: [{id: 'root', label: 'Root'}],
            fields: [
                {
                    id: 'multi',
                    label: 'Multi',
                    type: 'multiselect',
                    options: [
                        {id: 'a', label: 'A', service_id: 1, pricing_role: 'base'},
                        {id: 'b', label: 'B', service_id: 2, pricing_role: 'base'},
                    ],
                },
            ],
        });
        const codes = b.errors().map(e => e.code);
        expect(codes).toContain('rate_mismatch_across_base');
    });
});
```

---
#### 2


` File: src/core/__tests__/fallback.spec.ts`  [↑ Back to top](#index)

```ts
import {describe, it, expect} from 'vitest';
import type {ServiceProps, Tag, Field, FieldOption} from '../../schema';
import type {DgpServiceMap} from '../../schema/provider';

import {collectFailedFallbacks} from '../fallback';
import {pruneInvalidNodeFallbacks} from '../../utils/prune-fallbacks';

// ----------------------- fixtures -----------------------

const svc = (
    id: number,
    rate: number,
    flags?: Partial<Pick<NonNullable<DgpServiceMap[0]>, 'dripfeed' | 'refill' | 'cancel'>>
) => ({
    id,
    rate,
    dripfeed: flags?.dripfeed ?? false,
    refill: flags?.refill ?? false,
    cancel: flags?.cancel ?? false,
});

const serviceMap: DgpServiceMap = {
    100: svc(100, 10, {dripfeed: false}), // base for T
    101: svc(101, 8, {dripfeed: false}),  // cheaper, fits constraints
    102: svc(102, 12, {dripfeed: false}), // more expensive (rate violation)
    103: svc(103, 9, {dripfeed: true}),   // cheaper but dripfeed true (constraint mismatch if tag wants false)
    104: svc(104, 7, {dripfeed: false}),  // cheaper, fits constraints
    105: svc(105, 11, {dripfeed: false}), // option base
    106: svc(106, 9, {dripfeed: false}),  // option base (multi-context)
};

function baseProps(): ServiceProps {
    const tags: Tag[] = [
        {id: 'root', label: 'Root'},
        // Single-context tag T
        {
            id: 'T',
            label: 'Group T',
            bind_id: 'root',
            service_id: 100,
            // Effective constraints should be 'dripfeed:false'
            constraints: {dripfeed: false},
        },
        // Multi-context tags
        {id: 'T1', label: 'T1', bind_id: 'root', constraints: {dripfeed: false}},
        {id: 'T2', label: 'T2', bind_id: 'root', constraints: {dripfeed: true}},
    ];

    const fields: Field[] = [
        // Field bound to T, with an option that yields a service (optA)
        {
            id: 'F_T',
            type: 'select',
            label: 'F_T',
            bind_id: 'T',
            options: [
                {id: 'optA', label: 'A', service_id: 105, pricing_role: 'base'} as FieldOption,
            ],
            pricing_role: 'base',
        },
        // Field bound to both T1 & T2 (multi-context), with option optM yielding a service
        {
            id: 'F_M',
            type: 'select',
            label: 'F_M',
            bind_id: ['T1', 'T2'],
            options: [
                {id: 'optM', label: 'M', service_id: 106, pricing_role: 'base'} as FieldOption,
            ],
            pricing_role: 'base',
        },
    ];

    const props: ServiceProps = {
        filters: tags,
        fields,
        schema_version: '1.0',
        // Fallbacks shape we agreed: nodes + global
        fallbacks: {
            nodes: {
                // For tag T's base node
                T: [101, 102, 103],
                // For option optA (single-context)
                optA: [104],
                // For option optM (multi-context)
                optM: [103, 102],
            },
            // Global is soft (client does not prune)
            global: {
                100: [104, 102],
            },
        },
    };

    return props;
}

// Convenience to find reasons in diagnostics
function reasonsFor(
    diags: any[],
    where: Partial<{
        scope: string;
        nodeId: string | string[];
        candidate: number | string;
        tagContext: string;
    }>
) {
    const wantedIds = Array.isArray(where.nodeId) ? where.nodeId : (where.nodeId ? [where.nodeId] : undefined);
    return diags
        .filter((d) => {
            const scopeOk = where.scope ? d.scope === where.scope : true;
            const nodeOk = wantedIds ? wantedIds.some((id) => String(d.nodeId) === String(id)) : true;
            const candOk = where.candidate !== undefined ? String(d.candidate) === String(where.candidate) : true;
            const ctxOk = where.tagContext ? d.tagContext === where.tagContext : true;
            return scopeOk && nodeOk && candOk && ctxOk;
        })
        .map((d) => d.reason)
        .sort();
}

// ----------------------- tests -----------------------

describe('fallbacks: node-scoped (rate + constraints)', () => {
    it('keeps a candidate that is cheaper and fits constraints', () => {
        const props = baseProps();

        const diags = collectFailedFallbacks(props, serviceMap, {mode: 'dev'});
        // Tag T → candidate 101 should be fine (no failures for that pair)
        expect(reasonsFor(diags, {nodeId: 'T', candidate: 101})).toEqual([]);

        const {props: pruned, removed} = pruneInvalidNodeFallbacks(props, serviceMap, {requireConstraintFit: true});
        expect(removed.find(r => r.nodeId === 'T' && String(r.candidate) === '101')).toBeFalsy();
        expect(pruned.fallbacks?.nodes?.T).toContain(101);
    });

    it('flags & prunes a rate violation (candidate more expensive than primary)', () => {
        const props = baseProps();

        const diags = collectFailedFallbacks(props, serviceMap, {mode: 'dev'});
        expect(reasonsFor(diags, {nodeId: 'T', candidate: 102})).toContain('rate_violation');

        const {props: pruned, removed} = pruneInvalidNodeFallbacks(props, serviceMap, {requireConstraintFit: true});
        // removed contains T::102
        expect(removed.some(r => r.nodeId === 'T' && String(r.candidate) === '102')).toBe(true);
        expect(pruned.fallbacks?.nodes?.T ?? []).not.toContain(102);
    });

    it('flags & prunes a constraint mismatch when the tag requires a flag (true) and the candidate lacks it', () => {
        const props = baseProps();

        // Make the tag require dripfeed=true so we actually have a requirement to check
        const t = props.filters.find(tt => tt.id === 'T')!;
        t.constraints = {dripfeed: true};

        const settings = {requireConstraintFit: true, ratePolicy: {kind: 'lte_primary' as const}};

        // Candidate 101 has dripfeed: false (lacks the required capability) → mismatch
        const diags = collectFailedFallbacks(props, serviceMap, settings);
        expect(reasonsFor(diags, {nodeId: ['T', 'tag:T'], candidate: 101}))
            .toContain('constraint_mismatch');

        const {props: pruned, removed} = pruneInvalidNodeFallbacks(props, serviceMap, settings);
        expect(removed.some(r => (r.nodeId === 'T' || r.nodeId === 'tag:T') && String(r.candidate) === '101')).toBe(true);
        expect(pruned.fallbacks?.nodes?.T ?? []).not.toContain(101);
    });
});

describe('fallbacks: option node with multi-tag context', () => {
    it('keeps a candidate that fails one context but passes another (fails-not-all rule)', () => {
        const props = baseProps();

        // Adjust contexts to actually require/passthrough
        const t1 = props.filters.find(tt => tt.id === 'T1')!;
        const t2 = props.filters.find(tt => tt.id === 'T2')!;
        t1.constraints = { dripfeed: true };   // requires true
        t2.constraints = { dripfeed: false };  // no requirement

        // Ensure optM fallbacks include a candidate that lacks dripfeed (to fail T1)
        // and one that is a rate violation (to be pruned).
        // service 101 -> dripfeed:false, service 102 -> rate 12 (violates lte_primary vs base 106=9)
        props.fallbacks!.nodes!.optM = [101, 102];

        const settings = { requireConstraintFit: true, ratePolicy: { kind: 'lte_primary' as const } };

        const diags = collectFailedFallbacks(props, serviceMap, settings);

        // 101 should have at least one constraint failure (against T1)
        expect(reasonsFor(diags, { nodeId: ['optM'], candidate: 101 }))
            .toContain('constraint_mismatch');

        // Prune only candidates that fail all contexts or violate rate policy
        const { props: pruned, removed } = pruneInvalidNodeFallbacks(props, serviceMap, settings);

        // 101 kept (fails T1, passes T2)
        expect(pruned.fallbacks?.nodes?.optM).toContain(101);

        // 102 pruned (rate violation vs base 106=9)
        expect(removed.some(r => r.nodeId === 'optM' && String(r.candidate) === '102')).toBe(true);
        expect(pruned.fallbacks?.nodes?.optM ?? []).not.toContain(102);
    });
});

describe('fallbacks: global (soft)', () => {
    it('does not prune global fallbacks on the client', () => {
        const props = baseProps();
        const before = JSON.stringify(props.fallbacks?.global ?? {});
        const {props: pruned} = pruneInvalidNodeFallbacks(props, serviceMap, {requireConstraintFit: true});
        const after = JSON.stringify(pruned.fallbacks?.global ?? {});
        expect(after).toBe(before); // untouched by design
    });
});
```

---
#### 3


` File: src/core/__tests__/normalise.constraints.test.ts`  [↑ Back to top](#index)

```ts
import {describe, it, expect} from 'vitest';
import {normalise} from '../normalise';
import type {ServiceProps} from '../../schema';

describe('normalise() constraint propagation', () => {
    it('overrides child flags with nearest ancestor explicit values', () => {
        const props: ServiceProps = {
            filters: [
                {id: 'root', label: 'Root', constraints: {refill: true}},
                {id: 'A', label: 'A', bind_id: 'root', constraints: {refill: false, cancel: true}},
                {id: 'B', label: 'B', bind_id: 'A', constraints: {dripfeed: true}},
            ],
            fields: [],
        };

        const out = normalise(props);
        const A = out.filters.find(t => t.id === 'A')!;
        const B = out.filters.find(t => t.id === 'B')!;

        // Parent refill:true overrides A.refill=false
        expect(A.constraints?.refill).toBe(true);
        // A.cancel:true is preserved (root didn’t set cancel), and passed to B
        expect(A.constraints?.cancel).toBe(true);

        // At B: inherits refill:true from root and cancel:true from A; keeps its own dripfeed:true
        expect(B.constraints?.refill).toBe(true);
        expect(B.constraints?.cancel).toBe(true);
        expect(B.constraints?.dripfeed).toBe(true);
    });

    it('does not invent constraints when none exist up the chain', () => {
        const props: ServiceProps = {
            filters: [
                {id: 'root', label: 'Root'},
                {id: 'A', label: 'A', bind_id: 'root'},
                {id: 'B', label: 'B', bind_id: 'A'},
            ],
            fields: [],
        };
        const out = normalise(props);
        expect(out.filters.find(t => t.id === 'root')?.constraints).toBeUndefined();
        expect(out.filters.find(t => t.id === 'A')?.constraints).toBeUndefined();
        expect(out.filters.find(t => t.id === 'B')?.constraints).toBeUndefined();
    });

    it('handles multiple roots / orphaned nodes gracefully', () => {
        const props: ServiceProps = {
            filters: [
                {id: 'root', label: 'Root', constraints: {cancel: false}},
                {id: 'X', label: 'X', constraints: {refill: true}}, // orphan (no bind_id)
                {id: 'Y', label: 'Y', bind_id: 'X'},
            ],
            fields: [],
        };
        const out = normalise(props);
        // Root branch: only cancel:false propagates
        expect(out.filters.find(t => t.id === 'root')?.constraints?.cancel).toBe(false);
        // Orphan X acts as its own root; its refill:true propagates to Y
        expect(out.filters.find(t => t.id === 'X')?.constraints?.refill).toBe(true);
        expect(out.filters.find(t => t.id === 'Y')?.constraints?.refill).toBe(true);
    });
});
```

---
#### 4


` File: src/core/__tests__/normalise.test.ts`  [↑ Back to top](#index)

```ts
// src/core/__tests__/normalise.test.ts
import {describe, it, expect} from 'vitest';
import {normalise} from '../normalise';
import type {Field} from '../../schema';

describe('normalise()', () => {
    it('injects a root tag and merges legacy rootIncludes/rootExcludes', () => {
        const input = {
            filters: [{id: 't1', label: 'Tag 1'}],
            fields: [],
            rootIncludes: ['f1', 'f2', 'fX'], // legacy
            rootExcludes: ['fX'], // should overrule include
        };

        const out = normalise(input);

        // root is injected and placed first
        expect(out.filters[0]).toMatchObject({id: 'root', label: 'Root'});

        // legacy includes/excludes merged into root and deduped
        const root = out.filters.find((t) => t.id === 'root')!;
        expect(root.includes).toEqual(['f1', 'f2']); // fX removed because excluded
        expect(root.excludes).toEqual(['fX']);
    });

    it('renames legacy keys to snake_case and keeps only canonical top-level keys', () => {
        const input = {
            tags: [{id: 't1', label: 'T1', bindId: 'root', serviceId: 42}],
            fields: [
                {
                    id: 'f1',
                    label: 'Field 1',
                    type: 'select',
                    bind: ['t1', 'root'],
                    options: [
                        {id: 'o1', label: 'Opt 1', serviceId: 1001},
                        {id: 'o2', label: 'Opt 2'},
                    ],
                },
            ],
            includesForOptions: {'f1::o1': ['f2']},
            excludeForOptions: {'f1::o2': ['f3']},
            foo: 'bar', // should be dropped
        };

        const out = normalise(input);
        // canonical keys exist
        expect(Object.keys(out).sort()).toEqual(
            ['excludes_for_options', 'filters', 'fields', 'includes_for_options', 'schema_version'].sort()
        );

        // tag conversion
        const t1 = out.filters.find((t) => t.id === 't1')!;
        expect(t1.bind_id).toBe('root');
        expect(t1.service_id).toBe(42);

        // field conversion
        const f1 = out.fields.find((f) => f.id === 'f1')!;
        expect(f1.bind_id).toEqual(['t1', 'root']);

        // option conversion
        expect(f1.options?.[0].service_id).toBe(1001);

        // option maps
        expect(out.includes_for_buttons).toEqual({'f1::o1': ['f2']});
        expect(out.excludes_for_buttons).toEqual({'f1::o2': ['f3']});
    });

    it('normalises bind_id: single => string, multi => array, dedupes arrays', () => {
        const input = {
            filters: [{id: 'root', label: 'Root'}, {id: 't1', label: 'T1'}, {id: 't2', label: 'T2'}],
            fields: [
                {id: 'f_single', label: 'A', type: 'text', bind: 't1'},
                {id: 'f_multi', label: 'B', type: 'text', bind: ['t2', 't2', 'root']},
                {id: 'f_none', label: 'C', type: 'text'},
            ],
        };

        const out = normalise(input);
        const fSingle = out.fields.find((f) => f.id === 'f_single')!;
        const fMulti = out.fields.find((f) => f.id === 'f_multi')!;
        const fNone = out.fields.find((f) => f.id === 'f_none')!;

        expect(typeof fSingle.bind_id).toBe('string');
        expect(fSingle.bind_id).toBe('t1');

        expect(Array.isArray(fMulti.bind_id)).toBe(true);
        expect(fMulti.bind_id).toEqual(['t2', 'root']); // deduped, order preserved

        expect(fNone.bind_id).toBeUndefined();
    });

    it('defaults pricing_role to "base" on fields and cascades to options', () => {
        const input = {
            filters: [{id: 'root', label: 'Root'}],
            fields: [
                {
                    id: 'f1',
                    label: 'F1',
                    type: 'select',
                    options: [{id: 'o1', label: 'O1'}, {id: 'o2', label: 'O2'}],
                },
            ],
        };

        const out = normalise(input);
        const f1 = out.fields.find((f) => f.id === 'f1')!;
        expect(f1.pricing_role).toBe('base');
        expect(f1.options?.map((o) => o.pricing_role)).toEqual(['base', 'base']);
    });

    it('respects option-level pricing_role override', () => {
        const input = {
            filters: [{id: 'root', label: 'Root'}],
            fields: [
                {
                    id: 'f1',
                    label: 'F1',
                    type: 'select',
                    pricing_role: 'base',
                    options: [
                        {id: 'o1', label: 'O1'}, // will inherit base
                        {id: 'o2', label: 'O2', pricing_role: 'utility'}, // override
                    ],
                },
            ],
        };

        const out = normalise(input);
        const f1 = out.fields.find((f) => f.id === 'f1')!;
        expect(f1.pricing_role).toBe('base');
        expect(f1.options?.map((o) => o.pricing_role)).toEqual(['base', 'utility']);
    });

    it('keeps component only for custom fields', () => {
        const input = {
            filters: [{id: 'root', label: 'Root'}],
            fields: [
                {id: 'f_custom', label: 'Custom', type: 'custom', component: 'ServiceForm/Thing'},
                {id: 'f_text', label: 'Text', type: 'text', component: 'ShouldBeIgnored'},
            ],
        };

        const out = normalise(input);
        const fCustom = out.fields.find((f) => f.id === 'f_custom')!;
        const fText = out.fields.find((f) => f.id === 'f_text')!;

        expect(fCustom.component).toBe('ServiceForm/Thing');
        expect((fText as Field).component).toBeUndefined();
    });

    it('sets schema_version default to "1.0" if missing, preserves if provided', () => {
        const out1 = normalise({filters: [], fields: []});
        expect(out1.schema_version).toBe('1.0');

        const out2 = normalise({filters: [], fields: [], schema_version: '2.0'});
        expect(out2.schema_version).toBe('2.0');
    });

    it('dedupes include/exclude arrays on tags', () => {
        const input = {
            filters: [
                {
                    id: 'root',
                    label: 'Root',
                    includes: ['a', 'a', 'b'],
                    excludes: ['x', 'x', 'y'],
                },
            ],
            fields: [],
        };

        const out = normalise(input);
        const root = out.filters[0];
        expect(root.includes).toEqual(['a', 'b']);
        expect(root.excludes).toEqual(['x', 'y']);
    });

    it('handles empty/invalid inputs gracefully with meaningful errors', () => {
        expect(() => normalise(null as unknown as object)).toThrowError(/expected an object payload/i);
        expect(() => normalise(undefined as unknown as object)).toThrowError();
    });
});
```

---
#### 5


` File: src/core/__tests__/policy.test.ts`  [↑ Back to top](#index)

```ts
import {describe, it, expect} from 'vitest';
import {compilePolicies, splitPolicyDiagnostics} from '../policy';

describe('compilePolicies()', () => {
    it('defaults scope/subject/filter.role/severity/projection', () => {
        const raw = [{id: 'r1', op: 'unique'}];
        const {policies, diagnostics} = compilePolicies(raw);

        expect(policies[0]).toMatchObject({
            id: 'r1',
            scope: 'visible_group',
            subject: 'services',
            filter: {role: 'both'},
            severity: 'error',
            projection: 'service.id',
            op: 'unique',
        });
        expect(diagnostics.length).toBe(0);
    });

    it('generates id when missing and warns', () => {
        const {policies, diagnostics} = compilePolicies([{op: 'unique'}]);
        expect(policies[0].id).toMatch(/^policy_\d+$/);
        const {warnings} = splitPolicyDiagnostics(diagnostics);
        expect(warnings.some(w => /Missing "id"/.test(w.message))).toBe(true);
    });

    it('errors on invalid op and on missing numeric value for max_count', () => {
        const {policies, diagnostics} = compilePolicies([
            {id: 'bad1', op: 'nope'},
            {id: 'bad2', op: 'max_count'},
        ]);
        expect(policies.length).toBe(0);
        const {errors} = splitPolicyDiagnostics(diagnostics);
        expect(errors.some(e => e.path === 'op')).toBe(true);
        expect(errors.some(e => e.path === 'value')).toBe(true);
    });

    it('warns when projection for services does not start with service.', () => {
        const {diagnostics} = compilePolicies([{id: 'r', op: 'unique', projection: 'key'}]);
        const {warnings} = splitPolicyDiagnostics(diagnostics);
        expect(warnings.some(w => w.path === 'projection')).toBe(true);
    });

    it('warns when value is provided but unused for all_true/any_true', () => {
        const {diagnostics} = compilePolicies([
            {id: 'r1', op: 'all_true', value: true},
            {id: 'r2', op: 'any_true', value: false},
        ]);
        const {warnings} = splitPolicyDiagnostics(diagnostics);
        expect(warnings.filter(w => w.path === 'value').length).toBe(2);
    });

    it('accepts arrays or scalars in filter ids and defaults role', () => {
        const {policies} = compilePolicies([
            {id: 'filt', op: 'unique', filter: {handler_id: 7, platform_id: [1, 2]}},
        ]);
        expect(policies[0].filter?.handler_id).toEqual([7]);
        expect(policies[0].filter?.platform_id).toEqual([1, 2]);
        expect(policies[0].filter?.role).toBe('both');
    });
});
```

---
#### 6


` File: src/core/__tests__/utility-validation.spec.ts`  [↑ Back to top](#index)

```ts
import { describe, it, expect } from "vitest";
import { validate } from "../validate";
import type { ServiceProps, Tag, Field, FieldOption } from "../../schema";

/* ───────────────────────── helpers & fixtures ───────────────────────── */

function rootOnly(): ServiceProps {
    const tags: Tag[] = [{ id: "root", label: "Root" }];
    return { filters: tags, fields: [], schema_version: "1.0" };
}

type Err = { code: string; nodeId?: string; details?: Record<string, unknown> };

function utilityErrors(all: Err[]): Err[] {
    return all.filter(
        (e: Err) => typeof e.code === "string" && e.code.startsWith("utility_"),
    );
}

function opt(id: string, patch?: Partial<FieldOption>): FieldOption {
    const base: FieldOption = {
        id,
        label: id,
        pricing_role: "utility" as const,
        meta: {},
    };
    return { ...base, ...(patch ?? {}) };
}

function field(id: string, patch?: Partial<Field>): Field {
    const base: Field = {
        id,
        type: "select",
        label: id,
        bind_id: "root",
        pricing_role: "utility",
        options: [],
        meta: {},
    };
    return { ...base, ...(patch ?? {}) } as Field;
}

/* ────────────────────────────── tests ─────────────────────────────── */

describe("utility validation", () => {
    it("flags an option marked as utility that also has a service_id (utility_with_service_id)", () => {
        const props: ServiceProps = rootOnly();

        const f = field("F1", {
            options: [
                opt("O1", {
                    pricing_role: "utility",
                    service_id: 999, // <-- not allowed for a utility option
                    // provide a seemingly valid utility meta to isolate the error under test
                    meta: { utility: { rate: 5, mode: "flat" } },
                }),
            ],
        });

        props.fields.push(f);

        const errors: Err[] = validate(props, { allowUnsafe: true }) as any;
        const util = utilityErrors(errors);

        expect(
            util.some(
                (e) =>
                    e.code === "utility_with_service_id" && e.nodeId === "O1",
            ),
        ).toBe(true);
    });

    it("flags an option marked as utility with missing/invalid rate (utility_missing_rate)", () => {
        const props: ServiceProps = rootOnly();

        props.fields.push(
            field("F2", {
                options: [
                    opt("O2", {
                        pricing_role: "utility",
                        meta: {
                            // @ts-expect-error
                            utility: {
                                /* rate missing */ mode: "per_quantity",
                            },
                        },
                    }),
                    opt("O3", {
                        pricing_role: "utility",
                        meta: { utility: { rate: Number.NaN, mode: "flat" } }, // invalid rate
                    }),
                ],
            }),
        );

        const errors: Err[] = validate(props, { allowUnsafe: true }) as any;
        const util = utilityErrors(errors);

        expect(
            util.some(
                (e) => e.code === "utility_missing_rate" && e.nodeId === "O2",
            ),
        ).toBe(true);
        expect(
            util.some(
                (e) => e.code === "utility_missing_rate" && e.nodeId === "O3",
            ),
        ).toBe(true);
    });

    it("flags an option marked as utility with invalid mode (utility_invalid_mode)", () => {
        const props: ServiceProps = rootOnly();

        props.fields.push(
            field("F3", {
                options: [
                    opt("O4", {
                        pricing_role: "utility",
                        meta: {
                            utility: {
                                rate: 2.5,
                                mode: "banana" as unknown as "flat",
                            },
                        }, // invalid
                    }),
                ],
            }),
        );

        const errors: Err[] = validate(props, { allowUnsafe: true }) as any;
        const util = utilityErrors(errors);

        expect(
            util.some(
                (e) => e.code === "utility_invalid_mode" && e.nodeId === "O4",
            ),
        ).toBe(true);
    });

    it("accepts a valid option-level utility (no service_id, finite rate, allowed mode)", () => {
        const props: ServiceProps = rootOnly();

        props.fields.push(
            field("F4", {
                options: [
                    opt("O5", {
                        pricing_role: "utility",
                        meta: { utility: { rate: 3.0, mode: "per_quantity" } },
                    }),
                ],
            }),
        );

        const errors: Err[] = validate(props, { allowUnsafe: true }) as any;
        const util = utilityErrors(errors);

        expect(util.find((e) => e.nodeId === "O5")).toBeUndefined();
    });

    it("accepts a valid field-level utility marker", () => {
        const props: ServiceProps = rootOnly();

        props.fields.push(
            field("UFEE", {
                pricing_role: "utility",
                // no options; this is a pure utility field (e.g., a checkbox/number/text)
                meta: { utility: { rate: 1.5, mode: "flat" } },
            }),
        );

        const errors: Err[] = validate(props, { allowUnsafe: true }) as any;
        const util = utilityErrors(errors);

        expect(util.find((e) => e.nodeId === "UFEE")).toBeUndefined();
    });

    it("accepts per_value utilities with or without valueBy", () => {
        const props: ServiceProps = rootOnly();

        props.fields.push(
            field("F5", {
                options: [
                    opt("O6", {
                        meta: {
                            utility: {
                                rate: 0.25,
                                mode: "per_value",
                                valueBy: "value",
                            },
                        },
                    }),
                    opt("O7", {
                        meta: { utility: { rate: 0.1, mode: "per_value" } }, // defaults are ok
                    }),
                ],
            }),
        );

        const errors: Err[] = validate(props, { allowUnsafe: true }) as any;
        const util = utilityErrors(errors);

        expect(util.find((e) => e.nodeId === "O6")).toBeUndefined();
        expect(util.find((e) => e.nodeId === "O7")).toBeUndefined();
    });
});
```

---
#### 7


` File: src/core/__tests__/validate.policies.test.ts`  [↑ Back to top](#index)

```ts
import {describe, it, expect} from 'vitest';
import {validate} from '../validate';
import type {ServiceProps} from '../../schema';
import type {DgpServiceMap} from '../../schema/provider';
import type {DynamicRule} from '../../schema/validation';

describe('validate() dynamic policies', () => {
    const baseProps: ServiceProps = {
        filters: [{id: 'root', label: 'Root'}, {id: 'A', label: 'A', bind_id: 'root'}],
        fields: [
            {
                id: 'f1',
                label: 'Base A',
                type: 'select',
                bind_id: 'A',
                options: [
                    {id: 'o1', label: 'S-1', service_id: 1, pricing_role: 'base'},
                    {id: 'o2', label: 'S-2', service_id: 2, pricing_role: 'base'},
                ],
            },
            {
                id: 'f2',
                label: 'Util A',
                type: 'select',
                bind_id: 'A',
                options: [{id: 'u1', label: 'U-1', service_id: 3, pricing_role: 'utility'}],
            },
        ],
    };

    const serviceMap: DgpServiceMap = {
        1: {id: 1, key: 'k1', rate: 10, handler_id: 9, platform_id: 100, dripfeed: true, meta: {type: 'alpha'} as any},
        2: {id: 2, key: 'k2', rate: 10, handler_id: 9, platform_id: 100, dripfeed: true, meta: {type: 'alpha'} as any},
        3: {id: 3, key: 'k1', rate: 5, handler_id: 7, platform_id: 200, dripfeed: false, meta: {type: 'beta'} as any},
    };

    it('visible_group: all_equal on service type passes when equal', () => {
        const rules: DynamicRule[] = [{
            id: 'grp-type-eq',
            scope: 'visible_group',
            subject: 'services',
            filter: {role: 'base'},
            projection: 'service.type',  // from meta.type above
            op: 'all_equal',
            message: 'Base services in a group must share the same type'
        }];

        const out = validate(baseProps, {serviceMap, policies: rules});
        expect(out.some(e => e.code === 'policy_violation' && e.details?.ruleId === 'grp-type-eq')).toBe(false);
    });

    it('visible_group: no_mix handler_id fails when handlers differ', () => {
        // Make one base use a different handler
        const props: ServiceProps = JSON.parse(JSON.stringify(baseProps));
        (props.fields[0].options![1] as any).service_id = 3; // handler 7 vs 9
        const rules: DynamicRule[] = [{
            id: 'grp-no-mix-handler',
            scope: 'visible_group',
            subject: 'services',
            filter: {role: 'base'},
            projection: 'service.handler_id',
            op: 'no_mix',
            message: 'Do not mix providers in one group',
        }];

        const out = validate(props, {serviceMap, policies: rules});
        expect(out.some(e => e.code === 'policy_violation' && e.details?.ruleId === 'grp-no-mix-handler' && e.nodeId === 'A')).toBe(true);
    });

    it('global: unique key fails if duplicate provider keys exist', () => {
        // k1 appears on service 1 and 3 globally
        const rules: DynamicRule[] = [{
            id: 'global-unique-key',
            scope: 'global',
            subject: 'services',
            projection: 'service.key',
            op: 'unique',
            message: 'Provider keys must be unique globally',
        }];

        const out = validate(baseProps, {serviceMap, policies: rules});
        expect(out.some(e => e.code === 'policy_violation' && e.details?.ruleId === 'global-unique-key' && e.nodeId === 'global')).toBe(true);
    });

    it('visible_group: all_true dripfeed fails if any is false', () => {
        const rules: DynamicRule[] = [{
            id: 'grp-dripfeed-alltrue',
            scope: 'visible_group',
            subject: 'services',
            projection: 'service.dripfeed',
            filter: {role: 'both'},
            op: 'all_true',
        }];

        const out = validate(baseProps, {serviceMap, policies: rules});
        // service 3 (utility) has dripfeed false → violation on tag A
        expect(out.some(e => e.code === 'policy_violation' && e.details?.ruleId === 'grp-dripfeed-alltrue' && e.nodeId === 'A')).toBe(true);
    });

    it('visible_group: max_count base=1 fails with two base items', () => {
        const rules: DynamicRule[] = [{
            id: 'grp-max-one-base',
            scope: 'visible_group',
            subject: 'services',
            filter: {role: 'base'},
            op: 'max_count',
            value: 1,
        }];

        const out = validate(baseProps, {serviceMap, policies: rules});
        expect(out.some(e => e.code === 'policy_violation' && e.details?.ruleId === 'grp-max-one-base' && e.nodeId === 'A')).toBe(true);
    });
});
```

---
#### 8


` File: src/core/__tests__/validate.rate-coherence.spec.ts`  [↑ Back to top](#index)

```ts
import { describe, it, expect } from "vitest";
import { ServiceProps } from "../../schema";
import { DgpServiceMap } from "../../schema/provider";
import { BuilderOptions, createBuilder } from "../builder";
import { validateRateCoherenceDeep } from "../rate-coherence";

// Helpers
const svc = (id: number, rate: number) =>
    ({ id, rate, platform_id: 1, handler_id: 1 }) as any;

function makeBuilder(props: ServiceProps, services?: DgpServiceMap) {
    const opts: BuilderOptions = { serviceMap: services ?? {} };
    const b = createBuilder(opts);
    b.load(props);
    return b;
}

describe("validateRateCoherenceDeep", () => {
    it("no diagnostics when all base rates are equal", () => {
        const services: DgpServiceMap = {
            1000: svc(1000, 100),
            1001: svc(1001, 100),
        };

        const props: ServiceProps = {
            schema_version: "1.0",
            filters: [{ id: "t:root", label: "Root", service_id: 1000 }],
            fields: [
                // non-option button with base service 100
                {
                    id: "f:btn",
                    type: "switch",
                    label: "Action",
                    bind_id: "t:root",
                    button: true,
                    pricing_role: "base",
                    // base service matches tag
                    service_id: 1001,
                },
                // option button with one base option 100
                {
                    id: "f:opts",
                    type: "select",
                    label: "Choice",
                    bind_id: "t:root",
                    options: [
                        {
                            id: "o:one",
                            label: "One",
                            pricing_role: "base",
                            service_id: 1000,
                        },
                    ],
                },
            ],
        };

        const b = makeBuilder(props, services);
        const diags = validateRateCoherenceDeep({
            builder: b,
            services,
            tagId: "t:root",
            // default lte_primary
        });

        expect(diags.length).toBe(0);
    });

    it("flags higher-rate candidate under lte_primary when simulated anchor has a lower primary", () => {
        const services: DgpServiceMap = {
            1000: svc(1000, 100), // tag base
            1001: svc(1001, 90), // low
            1002: svc(1002, 120), // high -> should trigger violation in some simulations
        };

        const props: ServiceProps = {
            schema_version: "1.0",
            filters: [{ id: "t:root", label: "Root", service_id: 1000 }],
            fields: [
                // non-option button with base=90
                {
                    id: "f:btnLow",
                    type: "switch",
                    label: "Low Btn",
                    bind_id: "t:root",
                    button: true,
                    pricing_role: "base",
                    service_id: 1001,
                },
                // options: one high(120), one not needed
                {
                    id: "f:opts",
                    type: "select",
                    label: "Options",
                    bind_id: "t:root",
                    options: [
                        {
                            id: "o:hi",
                            label: "Hi",
                            pricing_role: "base",
                            service_id: 1002,
                        },
                        {
                            id: "o:ok",
                            label: "Ok",
                            pricing_role: "base",
                            service_id: 1000,
                        },
                    ],
                },
            ],
        };

        const b = makeBuilder(props, services);
        const diags = validateRateCoherenceDeep({
            builder: b,
            services,
            tagId: "t:root",
        });

        // Expect at least one diagnostic where the offender is the high-rate service 1002
        const offenders = diags.filter((d) => d.offender.service_id === 1002);
        expect(offenders.length).toBeGreaterThan(0);

        // And messages should mention the policy and rates coherently
        expect(offenders[0].policy).toBe("lte_primary");
        expect(offenders[0].message).toMatch(/Rate coherence failed/);
    });

    it("within_pct policy: allows <=10% but flags beyond 10% (primary comes from a revealed base button, not the tag)", () => {
        const services: DgpServiceMap = {
            1100: { id: 1100, rate: 100 }, // will be the primary via a *button*, not via tag
            1101: { id: 1101, rate: 109 }, // within 9% of 100 => OK
            1102: { id: 1102, rate: 111 }, // 11% above 100 => should be flagged
        };

        const props: ServiceProps = {
            schema_version: "1.0",
            // tag service exists but is *not* used as primary by validator
            filters: [{ id: "t:root", label: "Root", service_id: 1100 }],
            fields: [
                // Anchor (bound): selecting this reveals others in order
                { id: "f:reveal", type: "switch", label: "Reveal", bind_id: "t:root", button: true, pricing_role: "base" },

                // Base button carrying 100 (UNBOUND, only becomes visible via includes_for_buttons)
                { id: "f:base100", type: "switch", label: "Base100", button: true, pricing_role: "base", service_id: 1100 },

                // Option buttons carrying 109 and 111 (UNBOUND; also revealed via includes_for_buttons)
                {
                    id: "f:optA",
                    type: "select",
                    label: "A",
                    button: true, // option-based ⇒ normalized to true anyway
                    options: [{ id: "o:109", label: "109", pricing_role: "base", service_id: 1101 }],
                },
                {
                    id: "f:optB",
                    type: "select",
                    label: "B",
                    button: true,
                    options: [{ id: "o:111", label: "111", pricing_role: "base", service_id: 1102 }],
                },
            ],
            includes_for_buttons: {
                // Order matters: primary in the simulation becomes 100 (f:base100), then compare 109 and 111 to it
                "f:reveal": ["f:base100", "f:optA", "f:optB"],
            },
        };

        const b = makeBuilder(props, services);
        const diags = validateRateCoherenceDeep({
            builder: b,
            services,
            tagId: "t:root",
            ratePolicy: { kind: "within_pct", pct: 10 },
        });

        // 111 should be flagged against primary 100
        const flagged111 = diags.filter((d) => d.offender.service_id === 1102);
        expect(flagged111.length).toBeGreaterThan(0);
        expect(flagged111.some((d) => d.simulationAnchor.id === "f:reveal")).toBe(true);

        // 109 should *not* be flagged against 100 under 10%
        const flagged109 = diags.filter((d) => d.offender.service_id === 1101);
        expect(flagged109.length).toBe(0);
    });

    it("ignores non-button fields (no button flag, no options)", () => {
        const services: DgpServiceMap = {
            2000: svc(2000, 100),
            2001: svc(2001, 130), // would be “bad” if considered
        };

        const props: ServiceProps = {
            schema_version: "1.0",
            filters: [{ id: "t:root", label: "Root", service_id: 2000 }],
            fields: [
                // Plain text field with a service_id by mistake — should be ignored by the deep validator
                // @ts-expect-error ensure it's ignored; not a button
                {
                    id: "f:text",
                    type: "text",
                    label: "Note",
                    bind_id: "t:root",
                    service_id: 2001,
                },
                // A real button but equal rate, to keep things calm
                {
                    id: "f:btn",
                    type: "switch",
                    label: "Do",
                    bind_id: "t:root",
                    button: true,
                    pricing_role: "base",
                    service_id: 2000,
                },
            ],
        };

        const b = makeBuilder(props, services);
        const diags = validateRateCoherenceDeep({
            builder: b,
            services,
            tagId: "t:root",
        });

        // No violations because the only real (button) base is equal to the tag base,
        // and the stray service on the text field is ignored.
        expect(diags.length).toBe(0);
    });

    it("ignores utility-role services for coherence checks", () => {
        const services: DgpServiceMap = {
            3000: svc(3000, 100), // tag base
            3001: svc(3001, 500), // utility rate — should be ignored in coherence
        };

        const props: ServiceProps = {
            schema_version: "1.0",
            filters: [{ id: "t:root", label: "Root", service_id: 3000 }],
            fields: [
                {
                    id: "f:u",
                    type: "select",
                    label: "Util",
                    bind_id: "t:root",
                    options: [
                        {
                            id: "o:u",
                            label: "U",
                            pricing_role: "utility",
                            service_id: 3001,
                        },
                    ],
                },
            ],
        };

        const b = makeBuilder(props, services);
        const diags = validateRateCoherenceDeep({
            builder: b,
            services,
            tagId: "t:root",
        });

        expect(diags.length).toBe(0);
    });
});
```

---
#### 9


` File: src/core/__tests__/validate.test.ts`  [↑ Back to top](#index)

```ts
// src/core/__tests__/validate.test.ts
import {describe, it, expect} from 'vitest';
import {validate} from '../validate';
import type {ServiceProps, Field} from '../../schema';
import type {DgpServiceMap} from '../../schema/provider';
import {normalise} from "../normalise";

function errs(props: ServiceProps, serviceMap: DgpServiceMap = {}, shouldNormalise = true) {
    return validate(shouldNormalise ? normalise(props) : props, {serviceMap});
}

describe('validate()', () => {
    it('flags root_missing', () => {
        const out = errs({
            filters: [{id: 't1', label: 'T1'}],
            fields: [],
        }, undefined, false);
        expect(out.some(e => e.code === 'root_missing')).toBe(true);
    });

    it('detects cycles and bad bind references (tags & fields)', () => {
        const props: ServiceProps = {
            filters: [
                {id: 'root', label: 'Root'},
                {id: 'a', label: 'A', bind_id: 'b'},
                {id: 'b', label: 'B', bind_id: 'a'}, // cycle a <-> b
                {id: 'c', label: 'C', bind_id: 'zzz'}, // bad ref
            ],
            fields: [
                {id: 'f1', label: 'F1', type: 'text', name: 'n1', bind_id: 'nope'}, // bad ref
            ],
        };
        const out = errs(props);
        expect(out.some(e => e.code === 'cycle_in_tags')).toBe(true);
        expect(out.find(e => e.code === 'bad_bind_reference' && e.details?.ref === 'zzz')).toBeTruthy();
        expect(out.find(e => e.code === 'bad_bind_reference' && e.details?.ref === 'nope')).toBeTruthy();
    });

    it('flags duplicate_id, duplicate_tag_label, duplicate_field_name, and label_missing', () => {
        const props: ServiceProps = {
            filters: [
                {id: 'root', label: ''}, // label_missing
                {id: 'dup', label: 'Same'},
                {id: 't2', label: 'Same'}, // duplicate_tag_label
            ],
            fields: [
                {id: 'dup', label: '   ', type: 'text', name: 'email'}, // duplicate_id + label_missing
                {id: 'f2', label: 'Field', type: 'text', name: 'email'}, // duplicate_field_name
                {
                    id: 'f3',
                    label: 'With options',
                    type: 'select',
                    name: 'shouldNotHaveService',
                    options: [{id: 'o1', label: ''}], // option label_missing
                },
            ],
        };
        const out = errs(props);
        expect(out.some(e => e.code === 'duplicate_id' && e.nodeId === 'dup')).toBe(true);
        expect(out.some(e => e.code === 'duplicate_tag_label')).toBe(true);
        expect(out.some(e => e.code === 'duplicate_field_name' && e.nodeId === 'f2')).toBe(true);
        expect(out.filter(e => e.code === 'label_missing').length).toBeGreaterThanOrEqual(3);
    });

    it('validates option map keys and include/exclude conflicts', () => {
        const props: ServiceProps = {
            filters: [{id: 'root', label: 'Root'}],
            fields: [
                {
                    id: 'f1',
                    label: 'Sel',
                    type: 'select',
                    options: [{id: 'o1', label: 'O1'}],
                },
            ],
            includes_for_buttons: {
                'f1::o1': ['x'],
                'f1::bad': ['y'], // bad key (option not found)
            },
            excludes_for_buttons: {
                'f1::o1': ['z'], // conflict with includes_for_options
            },
        };
        const out = errs(props);
        expect(out.some(e => e.code === 'bad_option_key' && e.details?.key === 'f1::bad')).toBe(true);
        expect(out.some(e => e.code === 'option_include_exclude_conflict' && e.details?.key === 'f1::o1')).toBe(true);
    });

    it('detects duplicate_visible_label under a tag (bind/include − exclude)', () => {
        const props: ServiceProps = {
            filters: [{id: 'root', label: 'Root'}],
            fields: [
                {id: 'a', label: 'Same Label', type: 'text', name: 'x', bind_id: 'root'},
                {id: 'b', label: 'Same Label', type: 'text', name: 'y', bind_id: 'root'},
            ],
        };
        const out = errs(props);
        expect(out.some(e => e.code === 'duplicate_visible_label')).toBe(true);
    });

    it('service vs user-input rules', () => {
        const props: ServiceProps = {
            filters: [{id: 'root', label: 'Root'}],
            fields: [
                {id: 'svc_missing', label: 'No Name No Service', type: 'select', options: []}, // should require service option
                {
                    id: 'user_with_service',
                    label: 'User Field',
                    type: 'select',
                    name: 'username',
                    options: [{id: 'o1', label: 'O1', service_id: 1}], // not allowed for user-input
                },
                {
                    id: 'custom_with_service',
                    label: 'Custom Svc',
                    type: 'custom',
                    component: 'X/Y',
                    options: [{id: 'o1', label: 'O1', service_id: 2}], // custom cannot map services
                },
            ],
        };
        const out = errs(props);
        expect(out.some(e => e.code === 'service_field_missing_service_id' && e.nodeId === 'svc_missing')).toBe(true);
        expect(out.some(e => e.code === 'user_input_field_has_service_option' && e.nodeId === 'user_with_service')).toBe(true);
        expect(out.some(e => e.code === 'user_input_field_has_service_option' && e.nodeId === 'custom_with_service')).toBe(true);
    });

    it('custom fields must have a component', () => {
        const props: ServiceProps = {
            filters: [{id: 'root', label: 'Root'}],
            fields: [{id: 'c1', label: 'C', type: 'custom'}],
        };
        const out = errs(props);
        expect(out.some(e => e.code === 'custom_component_missing' && e.nodeId === 'c1')).toBe(true);
    });

    it('rate mismatch across BASE options (multi-select) uses DgpServiceMap', () => {
        const props: ServiceProps = {
            filters: [{id: 'root', label: 'Root'}],
            fields: [
                {
                    id: 'f_multi',
                    label: 'Multi',
                    type: 'multiselect', // triggers multi
                    options: [
                        {id: 'o1', label: 'A', service_id: 1, pricing_role: 'base'},
                        {id: 'o2', label: 'B', service_id: 2, pricing_role: 'base'},
                        {id: 'o3', label: 'C', service_id: 3, pricing_role: 'utility'}, // utility ignored for rate match
                    ],
                },
            ],
        };
        const serviceMap: DgpServiceMap = {
            1: {id: 1, rate: 10, refill: true, cancel: false, dripfeed: false},
            2: {id: 2, rate: 20, refill: true, cancel: false, dripfeed: false},
            3: {id: 3, rate: 999, refill: true, cancel: true, dripfeed: true},
        };
        const out = errs(props, serviceMap);
        expect(out.some(e => e.code === 'rate_mismatch_across_base' && e.nodeId === 'f_multi')).toBe(true);
    });

    it('utility_without_base (per visible group): utility visible under root but no base → error on root', () => {
        const props: ServiceProps = {
            filters: [{id: 'root', label: 'Root'}],
            fields: [
                {
                    id: 'f',
                    label: 'F',
                    type: 'select',
                    bind_id: 'root', // <-- make it visible under root
                    options: [{id: 'oU', label: 'U', service_id: 10, pricing_role: 'utility'}],
                },
            ],
        };
        const serviceMap: DgpServiceMap = {10: {id: 10, rate: 30}};
        const out = validate(normalise(props), {serviceMap});
        // error is attached to the TAG (group), with the list of utility option ids
        expect(out.some(e => e.code === 'utility_without_base' && e.nodeId === 'root')).toBe(true);
        const err = out.find(e => e.code === 'utility_without_base' && e.nodeId === 'root');
        expect(err?.details?.utilityOptionIds).toContain('oU');
    });

    it('constraints: descendant cannot contradict ancestor; tag promises must be supported by service', () => {
        const props: ServiceProps = {
            filters: [
                {id: 'root', label: 'Root', constraints: {refill: true}},
                {id: 't1', label: 'Child', bind_id: 'root', constraints: {refill: false}}, // contradiction
                {id: 't2', label: 'SvcTag', service_id: 100, constraints: {cancel: true}}, // unsupported by service
            ],
            fields: [],
        };
        const serviceMap: DgpServiceMap = {
            100: {id: 100, rate: 5, cancel: false, refill: true, dripfeed: true},
        };
        const out = errs(props, serviceMap);
        expect(out.some(e => (e.code === 'constraint_contradiction' || e.code === 'constraint_overridden') && e.nodeId === 't1')).toBe(true);
        expect(out.some(e => e.code === 'unsupported_constraint' && e.nodeId === 't2' && e.details?.flag === 'cancel')).toBe(true);
    });

    it('treats meta.multi as multi-select for custom type strings', () => {
        const props: ServiceProps = {
            filters: [{id: 'root', label: 'Root'}],
            fields: [
                {
                    id: 'fX',
                    label: 'X',
                    type: 'my_custom_multi', // not a known keyword
                    meta: {multi: true},
                    options: [
                        {id: 'o1', label: 'A', service_id: 1, pricing_role: 'base'},
                        {id: 'o2', label: 'B', service_id: 2, pricing_role: 'base'},
                    ],
                } as unknown as Field,
            ],
        };
        const serviceMap: DgpServiceMap = {
            1: {id: 1, rate: 1},
            2: {id: 2, rate: 2},
        };
        const out = errs(props, serviceMap);
        expect(out.some(e => e.code === 'rate_mismatch_across_base' && e.nodeId === 'fX')).toBe(true);
    });

    it('utility_without_base is scoped per visible tag group', () => {
        const props: ServiceProps = {
            filters: [
                {id: 'root', label: 'Root'},
                {id: 'A', label: 'Group A', bind_id: 'root'},
                {id: 'B', label: 'Group B', bind_id: 'root'}
            ],
            fields: [
                // Utility under A (provider-backed)
                {
                    id: 'fU',
                    label: 'Theme',
                    type: 'select',
                    bind_id: 'A',
                    options: [{id: 'u1', label: 'Premium', service_id: 3001, pricing_role: 'utility'}]
                },
                // Base under B (provider-backed)
                {
                    id: 'fB',
                    label: 'Site Type',
                    type: 'select',
                    bind_id: 'B',
                    options: [{id: 'b1', label: 'Basic', service_id: 2001, pricing_role: 'base'}]
                }
            ]
        };

        const out = validate(props, {serviceMap: {}});
        // Error only on tag A (its group has utility but no base)
        expect(out.some(e => e.code === 'utility_without_base' && e.nodeId === 'A')).toBe(true);
        expect(out.some(e => e.code === 'utility_without_base' && e.nodeId === 'B')).toBe(false);
    });

    it('group visibility respects excludes (base excluded → utility_without_base fires)', () => {
        const props: ServiceProps = {
            filters: [
                {id: 'root', label: 'Root'},
                // Tag T excludes the base field, so only utility remains visible
                {id: 'T', label: 'Group T', bind_id: 'root', excludes: ['fBase']}
            ],
            fields: [
                {
                    id: 'fBase',
                    label: 'Base Choice',
                    type: 'select',
                    bind_id: 'T',
                    options: [{id: 'b1', label: 'Base', service_id: 10, pricing_role: 'base'}]
                },
                {
                    id: 'fUtil',
                    label: 'Add-on',
                    type: 'select',
                    bind_id: 'T',
                    options: [{id: 'u1', label: 'Addon', service_id: 11, pricing_role: 'utility'}]
                }
            ]
        };

        const out = validate(props, {serviceMap: {}});
        expect(out.some(e => e.code === 'utility_without_base' && e.nodeId === 'T')).toBe(true);
    });

    it('option-level include/exclude: util included, base excluded → utility_without_base on T', () => {
        const props: ServiceProps = {
            filters: [{id: 'root', label: 'Root'}, {id: 'T', label: 'Group', bind_id: 'root'}],
            fields: [
                {
                    id: 'toggle',
                    label: 'Toggle',
                    type: 'radio',
                    bind_id: 'T',
                    options: [{id: 'on', label: 'On'}, {id: 'off', label: 'Off'}],
                },
                // Base (bound to T) but will be excluded when toggle:on
                {
                    id: 'base',
                    label: 'Base',
                    type: 'select',
                    bind_id: 'T',
                    options: [{id: 'b', label: 'B', service_id: 1, pricing_role: 'base'}],
                },
                // Utility (bound to T) but only included when toggle:on
                {
                    id: 'util',
                    label: 'Util',
                    type: 'select',
                    bind_id: 'T',
                    options: [{id: 'u', label: 'U', service_id: 2, pricing_role: 'utility'}],
                },
            ],
            includes_for_buttons: {'toggle::on': ['util']},
            excludes_for_buttons: {'toggle::on': ['base']}, // <-- hide base when "on"
        };

        const out = validate(props, {selectedOptionKeys: ['toggle::on']});
        expect(out.some(e => e.code === 'utility_without_base' && e.nodeId === 'T')).toBe(true);

        const out2 = validate(props, {selectedOptionKeys: ['toggle::off']});
        expect(out2.some(e => e.code === 'utility_without_base' && e.nodeId === 'T')).toBe(false);
    });

    it('option-level exclude hides base; util remains visible → utility_without_base fires', () => {
        const props: ServiceProps = {
            filters: [{id: 'root', label: 'Root'}, {id: 'T', label: 'Group', bind_id: 'root'}],
            fields: [
                {
                    id: 'toggle', label: 'Toggle', type: 'radio', bind_id: 'T', options: [
                        {id: 'hideBase', label: 'Hide Base'}, {id: 'showAll', label: 'Show All'}
                    ]
                },
                // Base field (bound to T)
                {
                    id: 'base', label: 'Base', type: 'select', bind_id: 'T', options: [
                        {id: 'b', label: 'B', service_id: 1, pricing_role: 'base'}
                    ]
                },
                // Util field (bound to T)
                {
                    id: 'util', label: 'Util', type: 'select', bind_id: 'T', options: [
                        {id: 'u', label: 'U', service_id: 2, pricing_role: 'utility'}
                    ]
                }
            ],
            excludes_for_buttons: {
                'toggle::hideBase': ['base']
            }
        };

        // Select "hideBase": base excluded → util visible without base → error
        const out = validate(props, {selectedOptionKeys: ['toggle::hideBase']});
        expect(out.some(e => e.code === 'utility_without_base' && e.nodeId === 'T')).toBe(true);

        // Select "showAll": nothing excluded → base present → OK
        const out2 = validate(props, {selectedOptionKeys: ['toggle::showAll']});
        expect(out2.some(e => e.code === 'utility_without_base')).toBe(false);
    });

    it('globalUtilityGuard: flags when utilities exist anywhere but no base exists', () => {
        const props: ServiceProps = {
            filters: [{id: 'root', label: 'Root'}],
            fields: [
                {
                    id: 'f',
                    label: 'F',
                    type: 'select',
                    bind_id: 'root',
                    options: [{id: 'u', label: 'U', service_id: 10, pricing_role: 'utility'}],
                },
            ],
        };
        const out = validate(props, {globalUtilityGuard: true});
        expect(out.some(e => e.code === 'utility_without_base' && e.nodeId === 'global')).toBe(true);
    });

    it('globalUtilityGuard: no error when any base exists anywhere', () => {
        const props: ServiceProps = {
            filters: [{id: 'root', label: 'Root'}],
            fields: [
                {
                    id: 'uF',
                    label: 'Util',
                    type: 'select',
                    bind_id: 'root',
                    options: [{id: 'u', label: 'U', service_id: 10, pricing_role: 'utility'}],
                },
                {
                    id: 'bF',
                    label: 'Base',
                    type: 'select',
                    bind_id: 'root',
                    options: [{id: 'b', label: 'B', service_id: 99, pricing_role: 'base'}],
                },
            ],
        };
        const out = validate(props, {globalUtilityGuard: true});
        expect(out.some(e => e.code === 'utility_without_base' && e.nodeId === 'global')).toBe(false);
    });

    it('flags field_unbound when a field is neither bound nor included by tag/option', () => {
        const props: ServiceProps = {
            filters: [{id: 'root', label: 'Root'}],
            fields: [
                {id: 'orphan', label: 'Orphan', type: 'text'},                 // ❌
                {id: 'bound', label: 'Bound', type: 'text', bind_id: 'root'}, // ✅
            ],
        };
        const out = validate(props);
        expect(out.some(e => e.code === 'field_unbound' && e.nodeId === 'orphan')).toBe(true);
        expect(out.some(e => e.code === 'field_unbound' && e.nodeId === 'bound')).toBe(false);
    });

    it('does NOT flag when the field is only included by tag.includes', () => {
        const props: ServiceProps = {
            filters: [{id: 'root', label: 'Root', includes: ['incOnly']}],
            fields: [{id: 'incOnly', label: 'Included', type: 'text'}],
        };
        const out = validate(props);
        expect(out.some(e => e.code === 'field_unbound')).toBe(false);
    });

    it('does NOT flag when the field is only included via includes_for_options', () => {
        const props: ServiceProps = {
            filters: [{id: 'root', label: 'Root'}],
            fields: [
                {
                    id: 'toggle', label: 'Toggle', type: 'radio', bind_id: 'root',
                    options: [{id: 'on', label: 'On'}]
                },
                {id: 'incByOpt', label: 'IncludedByOption', type: 'text'},
            ],
            includes_for_buttons: {'toggle::on': ['incByOpt']},
        };
        const out = validate(props);
        expect(out.some(e => e.code === 'field_unbound' && e.nodeId === 'incByOpt')).toBe(false);
    });

    it('validator emits constraint_overridden warnings from normaliser meta', () => {
        const props = normalise({
            filters: [
                {id: 'root', label: 'Root', constraints: {dripfeed: false}},
                {id: 'T', label: 'T', bind_id: 'root', constraints: {dripfeed: true}} // overridden → false
            ],
            fields: []
        });
        const out = validate(props);
        const warn = out.find(e => e.code === 'constraint_overridden' && e.nodeId === 'T');
        expect(warn?.details?.flag).toBe('dripfeed');
        expect(warn?.details?.from).toBe(true);
        expect(warn?.details?.to).toBe(false);
        expect(warn?.details?.origin).toBe('root');
    });
});
```

---
#### 10


` File: src/core/__tests__/validation.rate-coherence2.spec.ts`  [↑ Back to top](#index)

```ts
import { describe, it, expect } from "vitest";
import { ServiceProps } from "../../schema";
import { DgpServiceMap } from "../../schema/provider";
import { Builder, createBuilder } from "../builder";
import { validateRateCoherenceDeep } from "../rate-coherence";

/* helpers */
function svc(id: number, rate: number) {
    return { id, rate };
}
function makeBuilder(props: ServiceProps, services: DgpServiceMap): Builder {
    const b = createBuilder({ serviceMap: services });
    b.load(props);
    return b;
}

describe("validateRateCoherenceDeep (no tag-base primary)", () => {
    it("within_pct: anchor without base → first revealed base becomes primary; flags > 10% over primary", () => {
        const services: DgpServiceMap = {
            // tag base present but must not be used
            2100: svc(2100, 999),
            2101: svc(2101, 100), // will be chosen as primary (first revealed)
            2102: svc(2102, 112), // 12% above -> violation
        };

        const props: ServiceProps = {
            schema_version: "1.0",
            filters: [{ id: "t:root", label: "Root", service_id: 2100 }],
            fields: [
                {
                    id: "f:probe",
                    type: "switch",
                    label: "Probe",
                    bind_id: "t:root",
                    button: true,
                    pricing_role: "base",
                },
                // order matters: f:A before f:B to make 100 the primary
                {
                    id: "f:A",
                    type: "select",
                    label: "A",
                    bind_id: "t:root",
                    options: [
                        {
                            id: "o:100",
                            label: "100",
                            pricing_role: "base",
                            service_id: 2101,
                        },
                    ],
                },
                {
                    id: "f:B",
                    type: "select",
                    label: "B",
                    bind_id: "t:root",
                    options: [
                        {
                            id: "o:112",
                            label: "112",
                            pricing_role: "base",
                            service_id: 2102,
                        },
                    ],
                },
            ],
            includes_for_buttons: {
                "f:probe": ["f:A", "f:B"],
            },
        };

        const b = makeBuilder(props, services);
        const diags = validateRateCoherenceDeep({
            builder: b,
            services,
            tagId: "t:root",
            ratePolicy: { kind: "within_pct", pct: 10 },
        });

        // offender 112 must be flagged; 100 is primary
        const flagged112 = diags.filter((d) => d.offender.service_id === 2102);
        expect(flagged112.length).toBeGreaterThan(0);
        expect(
            flagged112.some((d) => d.simulationAnchor.id === "f:probe"),
        ).toBe(true);

        const flagged100 = diags.filter((d) => d.offender.service_id === 2101);
        expect(flagged100.length).toBe(0);
    });

    it("lte_primary: when reveal shows 100 then 105, 105 violates vs primary 100", () => {
        const services: DgpServiceMap = {
            2200: { id: 2200, rate: 777 }, // tag base (ignored for primary)
            2201: { id: 2201, rate: 100 }, // primary candidate
            2202: { id: 2202, rate: 105 }, // offender
        };

        const props: ServiceProps = {
            schema_version: "1.0",
            filters: [{ id: "t:root", label: "Root", service_id: 2200 }],
            fields: [
                // Anchor (bound) – selecting this should reveal the two base candidates
                { id: "f:reveal", type: "switch", label: "Reveal", bind_id: "t:root", button: true, pricing_role: "base" },

                // Two base buttons (UNBOUND): only become visible during the simulation via includes_for_buttons
                { id: "f:ok",  type: "switch", label: "OK",  /* no bind_id */ button: true, pricing_role: "base", service_id: 2201 },
                { id: "f:aux", type: "switch", label: "Aux", /* no bind_id */ button: true, pricing_role: "base", service_id: 2202 },
            ],
            includes_for_buttons: {
                // selecting f:reveal reveals f:ok then f:aux (order matters; 100 becomes primary)
                "f:reveal": ["f:ok", "f:aux"],
            },
        };

        const b = createBuilder({ serviceMap: services });
        b.load(props);

        const diags = validateRateCoherenceDeep({
            builder: b,
            services,
            tagId: "t:root",
            ratePolicy: { kind: "lte_primary" },
        });

        // 105 must be flagged against primary 100
        const flagged105 = diags.filter((d) => d.offender.service_id === 2202);
        expect(flagged105.length).toBeGreaterThan(0);
        expect(flagged105.some((d) => d.simulationAnchor.id === "f:reveal")).toBe(true);

        // 100 never flagged
        const flagged100 = diags.filter((d) => d.offender.service_id === 2201);
        expect(flagged100.length).toBe(0);
    });

    it("anchor with its own base uses itself as primary (no tag), other ≤10% is OK", () => {
        const services: DgpServiceMap = {
            2300: svc(2300, 999),
            2301: svc(2301, 109),
            2302: svc(2302, 111), // within ~1.83% of 109 -> OK
        };

        const props: ServiceProps = {
            schema_version: "1.0",
            filters: [{ id: "t:root", label: "Root", service_id: 2300 }],
            fields: [
                {
                    id: "f:opt",
                    type: "select",
                    label: "Opt",
                    bind_id: "t:root",
                    options: [
                        {
                            id: "o:109",
                            label: "109",
                            pricing_role: "base",
                            service_id: 2301,
                        },
                        {
                            id: "o:111",
                            label: "111",
                            pricing_role: "base",
                            service_id: 2302,
                        },
                    ],
                },
            ],
            includes_for_buttons: {},
        };

        const b = makeBuilder(props, services);
        const diags = validateRateCoherenceDeep({
            builder: b,
            services,
            tagId: "t:root",
            ratePolicy: { kind: "within_pct", pct: 10 },
        });

        expect(diags.length).toBe(0);
    });

    it("utility-role candidates are ignored as base even if they carry service_id", () => {
        const services: DgpServiceMap = {
            2400: svc(2400, 100),
            2401: svc(2401, 1000), // absurd, but utility → must be ignored
        };

        const props: ServiceProps = {
            schema_version: "1.0",
            filters: [{ id: "t:root", label: "Root", service_id: 2400 }],
            fields: [
                {
                    id: "f:u",
                    type: "select",
                    label: "Util",
                    bind_id: "t:root",
                    options: [
                        {
                            id: "o:util",
                            label: "Util",
                            pricing_role: "utility",
                            service_id: 2401 as any,
                        },
                    ],
                },
            ],
            includes_for_buttons: {
                "f:u::o:util": [],
            },
        };

        const b = makeBuilder(props, services);
        const diags = validateRateCoherenceDeep({
            builder: b,
            services,
            tagId: "t:root",
            ratePolicy: { kind: "lte_primary" },
        });

        expect(diags.length).toBe(0);
    });

    it("at_least_pct_lower: primary=190 (first), 195 violates (not ≥5% lower)", () => {
        const services: DgpServiceMap = {
            2500: { id: 2500, rate: 777 }, // tag base (ignored for primary)
            2501: { id: 2501, rate: 190 }, // primary
            2502: { id: 2502, rate: 195 }, // offender
        };

        const props: ServiceProps = {
            schema_version: "1.0",
            filters: [{ id: "t:root", label: "Root", service_id: 2500 }],
            fields: [
                // Anchor (bound)
                { id: "f:probe", type: "switch", label: "Probe", bind_id: "t:root", button: true, pricing_role: "base" },

                // Two base buttons (UNBOUND), revealed (in order) by selecting the anchor
                { id: "f:A", type: "switch", label: "A", /* no bind_id */ button: true, pricing_role: "base", service_id: 2501 }, // first => primary
                { id: "f:B", type: "switch", label: "B", /* no bind_id */ button: true, pricing_role: "base", service_id: 2502 },
            ],
            includes_for_buttons: {
                "f:probe": ["f:A", "f:B"],
            },
        };

        const b = createBuilder({ serviceMap: services });
        b.load(props);

        const diags = validateRateCoherenceDeep({
            builder: b,
            services,
            tagId: "t:root",
            ratePolicy: { kind: "at_least_pct_lower", pct: 5 },
        });

        const bad = diags.filter((d) => d.offender.service_id === 2502);
        const good = diags.filter((d) => d.offender.service_id === 2501);

        expect(bad.length).toBeGreaterThan(0);
        expect(bad.some((d) => d.simulationAnchor.id === "f:probe")).toBe(true);
        expect(good.length).toBe(0);
    });
});
```

---
#### 11


` File: src/core/builder.ts`  [↑ Back to top](#index)

```ts
// src/core/builder.ts
import { normalise } from "./normalise";
import { validate } from "./validate";

import type { ServiceProps, Tag, Field } from "../schema";
import type {
    GraphNode,
    GraphEdge,
    GraphSnapshot,
    NodeKind,
    EdgeKind,
} from "../schema/graph";
import type { DgpServiceMap } from "../schema/provider";
import type { ValidationError, ValidatorOptions } from "../schema/validation";

/** Options you can set on the builder (used for validation/visibility) */
export type BuilderOptions = Omit<ValidatorOptions, "serviceMap"> & {
    serviceMap?: DgpServiceMap;
    /** max history entries for undo/redo */
    historyLimit?: number;
    /**
     * Field ids whose options should be shown as nodes in the graph.
     * If a field id is NOT in this set, its options are not materialized as nodes:
     * - include/exclude wires keyed by an option id will be drawn from the FIELD instead.
     */
    showOptionNodes?: Set<string> | string[];
};

export interface Builder {
    /** Replace current payload (injects root if missing, rebuilds indexes) */
    load(props: ServiceProps): void;

    /** Graph for visualisation */
    tree(): GraphSnapshot;

    /** Deterministic save payload (drops unbound utility fields, prunes dead maps) */
    cleanedProps(): ServiceProps;

    /** Validation errors for current state */
    errors(): ValidationError[];

    /**
     * Compute IDs of fields visible under a tag.
     * If selectedOptionKeys provided, applies option-level include/exclude.
     * NOTE: keys are “button ids”: either option.id or field.id for option-less buttons.
     */
    visibleFields(tagId: string, selectedOptionKeys?: string[]): string[];

    /** Update builder options (validator context etc.) */
    setOptions(patch: Partial<BuilderOptions>): void;

    /** History */
    undo(): boolean;
    redo(): boolean;

    /** Access the current props (already normalised) */
    getProps(): ServiceProps;

    /** Service map for validation/rules */
    getServiceMap(): DgpServiceMap;
}

export function createBuilder(opts: BuilderOptions = {}): Builder {
    return new BuilderImpl(opts);
}

/* ────────────────────────────────────────────────────────────────────────── */

class BuilderImpl implements Builder {
    private props: ServiceProps = {
        filters: [],
        fields: [],
        schema_version: "1.0",
    };
    private tagById = new Map<string, Tag>();
    private fieldById = new Map<string, Field>();
    private optionOwnerById = new Map<string, { fieldId: string }>(); // option.id → fieldId

    private options: BuilderOptions;
    private readonly history: ServiceProps[] = [];
    private readonly future: ServiceProps[] = [];
    private readonly historyLimit: number;

    constructor(opts: BuilderOptions = {}) {
        this.options = { ...opts };
        this.historyLimit = opts.historyLimit ?? 50;
    }

    /* ───── lifecycle ─────────────────────────────────────────────────────── */

    load(raw: ServiceProps): void {
        const next = normalise(raw, { defaultPricingRole: "base" });
        this.pushHistory(this.props);
        this.future.length = 0; // clear redo stack
        this.props = next;
        this.rebuildIndexes();
    }

    getProps(): ServiceProps {
        return this.props;
    }

    setOptions(patch: Partial<BuilderOptions>): void {
        this.options = { ...this.options, ...patch };
    }

    getServiceMap(): DgpServiceMap {
        return this.options.serviceMap ?? {};
    }

    /* ───── querying ─────────────────────────────────────────────────────── */

    tree(): GraphSnapshot {
        const nodes: GraphNode[] = [];
        const edges: GraphEdge[] = [];

        const showSet = toStringSet(this.options.showOptionNodes);

        // 1) tags as nodes
        for (const t of this.props.filters) {
            nodes.push({ id: t.id, kind: "tag" as NodeKind, label: t.label });
        }

        // 2) tag hierarchy edges
        for (const t of this.props.filters) {
            if (t.bind_id) {
                edges.push({
                    from: t.bind_id,
                    to: t.id,
                    kind: "child" as EdgeKind,
                });
            }
        }

        // 3) fields as nodes
        for (const f of this.props.fields) {
            nodes.push({
                id: f.id,
                kind: "field" as NodeKind,
                label: f.label,
                bind_type:
                    f.pricing_role === "utility"
                        ? "utility"
                        : f.bind_id
                          ? "bound"
                          : null,
            });
        }

        // 4) field bind edges
        for (const f of this.props.fields) {
            const b = f.bind_id;
            if (Array.isArray(b)) {
                for (const tagId of b)
                    edges.push({
                        from: tagId,
                        to: f.id,
                        kind: "bind" as EdgeKind,
                    });
            } else if (typeof b === "string") {
                edges.push({ from: b, to: f.id, kind: "bind" as EdgeKind });
            }
        }

        // 5) Option nodes (only for fields in showOptionNodes)
        for (const f of this.props.fields) {
            const showOptions = showSet.has(f.id);
            if (!showOptions) continue;
            if (!Array.isArray(f.options)) continue;

            for (const o of f.options) {
                nodes.push({
                    id: o.id,
                    kind: "option",
                    label: o.label,
                });
                // field → option edge
                const e: any = {
                    from: f.id,
                    to: o.id,
                    kind: "option" as EdgeKind,
                    meta: { ownerField: f.id },
                };
                edges.push(e as GraphEdge);
            }
        }

        // 6) tag includes/excludes
        for (const t of this.props.filters) {
            for (const id of t.includes ?? []) {
                edges.push({ from: t.id, to: id, kind: "include" as EdgeKind });
            }
            for (const id of t.excludes ?? []) {
                edges.push({ from: t.id, to: id, kind: "exclude" as EdgeKind });
            }
        }

        // 7) button-level includes/excludes (keys are button IDs: option.id OR field.id)
        const incMap = this.props.includes_for_buttons ?? {};
        const excMap = this.props.excludes_for_buttons ?? {};

        const pushButtonEdge = (
            keyId: string,
            targetFieldId: string,
            kind: EdgeKind,
        ) => {
            const owner = this.optionOwnerById.get(keyId);
            const ownerFieldId =
                owner?.fieldId ??
                (this.fieldById.has(keyId) ? keyId : undefined);
            if (!ownerFieldId) return; // dangling key, ignore

            // If the key is an option AND its field is being shown, draw from the option
            const fromNode =
                owner && showSet.has(owner.fieldId)
                    ? keyId // option node → visible, draw from option
                    : ownerFieldId; // else draw from the field

            const meta: any = owner
                ? showSet.has(owner.fieldId)
                    ? {
                          via: "option-visible",
                          ownerField: owner.fieldId,
                          sourceOption: keyId,
                      }
                    : {
                          via: "option-hidden",
                          ownerField: owner.fieldId,
                          sourceOption: keyId,
                      }
                : { via: "field-button" };

            const e: any = { from: fromNode, to: targetFieldId, kind, meta };
            edges.push(e as GraphEdge);
        };

        for (const [keyId, arr] of Object.entries(incMap)) {
            for (const fid of arr ?? [])
                pushButtonEdge(keyId, fid, "include" as EdgeKind);
        }
        for (const [keyId, arr] of Object.entries(excMap)) {
            for (const fid of arr ?? [])
                pushButtonEdge(keyId, fid, "exclude" as EdgeKind);
        }

        return { nodes, edges };
    }

    cleanedProps(): ServiceProps {
        // Build quick indexes
        const fieldIds = new Set(this.props.fields.map((f) => f.id));
        const optionIds = new Set<string>();
        this.optionOwnerById.forEach((_v, oid) => optionIds.add(oid));

        // 1) drop utility fields that are truly "orphaned"
        //    (unbound + not included by tag or button includes + not referenced as a key)
        const includedByTag = new Set<string>();
        const excludedAnywhere = new Set<string>();
        for (const t of this.props.filters) {
            for (const id of t.includes ?? []) includedByTag.add(id);
            for (const id of t.excludes ?? []) excludedAnywhere.add(id);
        }

        const incMap = this.props.includes_for_buttons ?? {};
        const excMap = this.props.excludes_for_buttons ?? {};
        const includedByButtons = new Set<string>(); // field ids that might be pulled in
        const referencedKeys = new Set<string>(); // keys in maps (field button or option id)
        const referencedOwnerFields = new Set<string>();

        for (const [key, arr] of Object.entries(incMap)) {
            referencedKeys.add(key);
            const owner = this.optionOwnerById.get(key);
            if (owner) referencedOwnerFields.add(owner.fieldId);
            for (const fid of arr ?? []) {
                includedByButtons.add(fid);
            }
        }
        for (const [key, arr] of Object.entries(excMap)) {
            referencedKeys.add(key);
            const owner = this.optionOwnerById.get(key);
            if (owner) referencedOwnerFields.add(owner.fieldId);
            for (const fid of arr ?? []) {
                // exclusion targets don’t “include”, but record that these field ids are referenced
                // (so we don’t accidentally drop something host intentionally excludes/controls)
                // not strictly necessary, but conservative:
                void fid;
            }
        }

        const boundIds = new Set<string>();
        for (const f of this.props.fields) {
            const b = f.bind_id;
            if (Array.isArray(b)) b.forEach((id) => boundIds.add(id));
            else if (typeof b === "string") boundIds.add(b);
        }

        const fields = this.props.fields.filter((f) => {
            const isUtility = (f.pricing_role ?? "base") === "utility";
            if (!isUtility) return true;

            const bound = !!f.bind_id;
            const included =
                includedByTag.has(f.id) || includedByButtons.has(f.id);
            const referenced =
                referencedOwnerFields.has(f.id) || referencedKeys.has(f.id);
            const excluded = excludedAnywhere.has(f.id);

            // keep if bound OR included OR referenced by maps; drop if truly orphaned or globally excluded
            return bound || included || referenced || !excluded;
        });

        // 2) prune button maps: keep only valid keys and existing field targets
        const allowedTargets = new Set(fields.map((f) => f.id)); // targets must be existing fields

        const pruneButtons = (src?: Record<string, string[]>) => {
            if (!src) return undefined;
            const out: Record<string, string[]> = {};
            for (const [key, arr] of Object.entries(src)) {
                // key must be an existing option.id OR field.id
                const keyIsValid = optionIds.has(key) || fieldIds.has(key);
                if (!keyIsValid) continue;

                const cleaned = (arr ?? []).filter((fid) =>
                    allowedTargets.has(fid),
                );
                if (cleaned.length) out[key] = Array.from(new Set(cleaned));
            }
            return Object.keys(out).length ? out : undefined;
        };

        const includes_for_buttons = pruneButtons(
            this.props.includes_for_buttons,
        );
        const excludes_for_buttons = pruneButtons(
            this.props.excludes_for_buttons,
        );

        // 3) return canonical object
        const out: ServiceProps = {
            filters: this.props.filters.slice(),
            fields,
            ...(includes_for_buttons && { includes_for_buttons }),
            ...(excludes_for_buttons && { excludes_for_buttons }),
            schema_version: this.props.schema_version ?? "1.0",
            // keep fallbacks & other maps as-is
            ...(this.props.fallbacks
                ? { fallbacks: this.props.fallbacks }
                : {}),
        };
        return out;
    }

    errors(): ValidationError[] {
        return validate(this.props, this.options);
    }

    visibleFields(tagId: string, selectedKeys?: string[]): string[] {
        const props = this.props;
        const selected = new Set(
            selectedKeys ?? this.options.selectedOptionKeys ?? [],
        );

        const tag = (props.filters ?? []).find((t) => t.id === tagId);
        if (!tag) return [];

        const tagInclude = new Set(tag.includes ?? []);
        const tagExclude = new Set(tag.excludes ?? []);

        // Button maps (can be keyed by fieldId OR "fieldId::optionId")
        const incMap = props.includes_for_buttons ?? {};
        const excMap = props.excludes_for_buttons ?? {};

        // Collect includes/excludes coming from the current selection,
        // and keep an ordered list of *revealed* ids to preserve determinism.
        const revealedOrder: string[] = [];
        const includeFromSelection = new Set<string>();
        const excludeFromSelection = new Set<string>();

        for (const key of selected) {
            const inc = incMap[key] ?? [];
            for (const id of inc) {
                if (!includeFromSelection.has(id)) revealedOrder.push(id);
                includeFromSelection.add(id);
            }
            const exc = excMap[key] ?? [];
            for (const id of exc) excludeFromSelection.add(id);
        }

        // Build candidate pool
        const pool = new Map<string, Field>();
        for (const f of props.fields ?? []) {
            if (isBoundTo(f, tagId)) pool.set(f.id, f);
            if (tagInclude.has(f.id)) pool.set(f.id, f);
            if (includeFromSelection.has(f.id)) pool.set(f.id, f);
        }

        // Remove excludes
        for (const id of tagExclude) pool.delete(id);
        for (const id of excludeFromSelection) pool.delete(id);

        // Optional explicit ordering per tag
        const order = props.order_for_tags?.[tagId];

        if (order && order.length) {
            // 1) tag order
            const ordered: string[] = [];
            for (const fid of order) if (pool.has(fid)) ordered.push(fid);
            // 2) any remaining (preserve insertion order)
            for (const fid of pool.keys())
                if (!ordered.includes(fid)) ordered.push(fid);
            return ordered;
        }

        // No tag order → promote revealed fields FIRST (in the exact reveal order),
        // then anything else in the natural field order.
        const promoted = revealedOrder.filter((fid) => pool.has(fid));
        const rest: string[] = [];
        for (const fid of pool.keys()) {
            if (!promoted.includes(fid)) rest.push(fid);
        }
        return [...promoted, ...rest];
    }

    /* ───── history ─────────────────────────────────────────────────────── */

    undo(): boolean {
        if (this.history.length === 0) return false;
        const prev = this.history.pop()!;
        this.future.push(structuredCloneSafe(this.props));
        this.props = prev;
        this.rebuildIndexes();
        return true;
    }

    redo(): boolean {
        if (this.future.length === 0) return false;
        const next = this.future.pop()!;
        this.pushHistory(this.props);
        this.props = next;
        this.rebuildIndexes();
        return true;
    }

    /* ───── internals ──────────────────────────────────────────────────── */

    private rebuildIndexes(): void {
        this.tagById.clear();
        this.fieldById.clear();
        this.optionOwnerById.clear();

        for (const t of this.props.filters) this.tagById.set(t.id, t);
        for (const f of this.props.fields) {
            this.fieldById.set(f.id, f);
            if (Array.isArray(f.options)) {
                for (const o of f.options)
                    this.optionOwnerById.set(o.id, { fieldId: f.id });
            }
        }
    }

    private pushHistory(state: ServiceProps): void {
        // avoid pushing initial empty state on the very first load
        if (!state || (!state.filters.length && !state.fields.length)) return;
        this.history.push(structuredCloneSafe(state));
        if (this.history.length > this.historyLimit) this.history.shift();
    }
}

/* ───────────────────────── helpers ───────────────────────── */

function isBoundTo(f: Field, tagId: string): boolean {
    const b = f.bind_id;
    if (!b) return false;
    return Array.isArray(b) ? b.includes(tagId) : b === tagId;
}

function structuredCloneSafe<T>(v: T): T {
    if (typeof (globalThis as any).structuredClone === "function") {
        return (globalThis as any).structuredClone(v);
    }
    return JSON.parse(JSON.stringify(v));
}

function toStringSet(v: Set<string> | string[] | undefined): Set<string> {
    if (!v) return new Set();
    if (v instanceof Set) return new Set(Array.from(v).map(String));
    return new Set((v as string[]).map(String));
}
```

---
#### 12


` File: src/core/fallback.ts`  [↑ Back to top](#index)

```ts
// src/core/utils/fallback.ts
import type {
    ServiceProps,
    ServiceFallback,
    ServiceIdRef,
    NodeIdRef,
} from "../schema";
import type { DgpServiceMap } from "../schema/provider";
import type { FallbackSettings } from "../schema/validation";

export type FailedFallbackContext = {
    scope: "node" | "global";
    nodeId?: string; // when scope='node'
    primary: ServiceIdRef;
    candidate: ServiceIdRef;
    tagContext?: string; // tag.id when evaluating constraints
    reason:
        | "unknown_service"
        | "no_primary"
        | "rate_violation"
        | "constraint_mismatch"
        | "cycle"
        | "no_tag_context";
    details?: Record<string, unknown>;
};

const DEFAULT_SETTINGS: Required<FallbackSettings> = {
    requireConstraintFit: true,
    ratePolicy: { kind: "lte_primary" },
    selectionStrategy: "priority",
    mode: "strict",
};

export function resolveServiceFallback(params: {
    primary: ServiceIdRef;
    nodeId?: NodeIdRef; // prefer node-scoped first if provided
    tagId?: string; // constraints context (if known)
    services: DgpServiceMap;
    fallbacks?: ServiceFallback;
    settings?: FallbackSettings;
    props: ServiceProps;
}): ServiceIdRef | null {
    const s = { ...DEFAULT_SETTINGS, ...(params.settings ?? {}) };
    const { primary, nodeId, tagId, services } = params;
    const fb = params.fallbacks ?? {};
    const tried: ServiceIdRef[] = [];

    const lists: ServiceIdRef[][] = [];
    if (nodeId && fb.nodes?.[nodeId]) lists.push(fb.nodes[nodeId]);
    if (fb.global?.[primary]) lists.push(fb.global[primary]);

    const primaryRate = rateOf(services, primary);

    for (const list of lists) {
        for (const cand of list) {
            if (tried.includes(cand)) continue;
            tried.push(cand);

            const candCap = services[Number(cand)] ?? services[cand as any];
            if (!candCap) continue;

            if (!passesRate(s.ratePolicy, primaryRate, candCap.rate)) continue;
            if (s.requireConstraintFit && tagId) {
                const ok = satisfiesTagConstraints(tagId, params, candCap);
                if (!ok) continue;
            }
            return cand;
        }
    }
    return null;
}

export function collectFailedFallbacks(
    props: ServiceProps,
    services: DgpServiceMap,
    settings?: FallbackSettings,
): FailedFallbackContext[] {
    const s = { ...DEFAULT_SETTINGS, ...(settings ?? {}) };
    const out: FailedFallbackContext[] = [];
    const fb = props.fallbacks ?? {};
    const primaryRate = (p: ServiceIdRef) => rateOf(services, p);

    // Node-scoped (tags or options)
    for (const [nodeId, list] of Object.entries(fb.nodes ?? {})) {
        const { primary, tagContexts } = primaryForNode(props, nodeId);
        if (!primary) {
            out.push({
                scope: "node",
                nodeId,
                primary: "" as any,
                candidate: "" as any,
                reason: "no_primary",
            });
            continue;
        }
        for (const cand of list) {
            const cap = getCap(services, cand);
            if (!cap) {
                out.push({
                    scope: "node",
                    nodeId,
                    primary,
                    candidate: cand,
                    reason: "unknown_service",
                });
                continue;
            }
            if (String(cand) === String(primary)) {
                out.push({
                    scope: "node",
                    nodeId,
                    primary,
                    candidate: cand,
                    reason: "cycle",
                });
                continue;
            }
            if (!passesRate(s.ratePolicy, primaryRate(primary), cap.rate)) {
                out.push({
                    scope: "node",
                    nodeId,
                    primary,
                    candidate: cand,
                    reason: "rate_violation",
                });
                continue;
            }
            // Tag contexts
            if (tagContexts.length === 0) {
                out.push({
                    scope: "node",
                    nodeId,
                    primary,
                    candidate: cand,
                    reason: "no_tag_context",
                });
                continue;
            }
            let anyPass = false;
            let anyFail = false;
            for (const tagId of tagContexts) {
                const ok = s.requireConstraintFit
                    ? satisfiesTagConstraints(tagId, { services, props }, cap)
                    : true;
                if (ok) anyPass = true;
                else {
                    anyFail = true;
                    out.push({
                        scope: "node",
                        nodeId,
                        primary,
                        candidate: cand,
                        tagContext: tagId,
                        reason: "constraint_mismatch",
                    });
                }
            }
            // If none passed, we already added per-context mismatches above
            void anyPass;
            void anyFail;
        }
    }

    // Global (soft; no tag context)
    for (const [primary, list] of Object.entries(fb.global ?? {})) {
        for (const cand of list) {
            const cap = getCap(services, cand);
            if (!cap) {
                out.push({
                    scope: "global",
                    primary,
                    candidate: cand,
                    reason: "unknown_service",
                });
                continue;
            }
            if (String(cand) === String(primary)) {
                out.push({
                    scope: "global",
                    primary,
                    candidate: cand,
                    reason: "cycle",
                });
                continue;
            }
            if (!passesRate(s.ratePolicy, primaryRate(primary), cap.rate)) {
                out.push({
                    scope: "global",
                    primary,
                    candidate: cand,
                    reason: "rate_violation",
                });
            }
        }
    }
    return out;
}

/* ───────────────────────── helpers ───────────────────────── */

function getCap(map: DgpServiceMap, id: ServiceIdRef) {
    return map[Number(id)] ?? map[id as any];
}

function rateOf(
    map: DgpServiceMap,
    id: ServiceIdRef | undefined,
): number | undefined {
    if (id === undefined || id === null) return undefined;
    const c = getCap(map, id);
    return c?.rate ?? undefined;
}

function passesRate(
    policy: Required<FallbackSettings>["ratePolicy"],
    primaryRate?: number,
    candRate?: number,
): boolean {
    if (typeof candRate !== "number" || !Number.isFinite(candRate))
        return false;
    if (typeof primaryRate !== "number" || !Number.isFinite(primaryRate))
        return false;
    switch (policy.kind) {
        case "lte_primary":
            return candRate <= primaryRate;
        case "within_pct":
            return candRate <= primaryRate * (1 + policy.pct / 100);
        case "at_least_pct_lower":
            return candRate <= primaryRate * (1 - policy.pct / 100);
    }
}

function satisfiesTagConstraints(
    tagId: string,
    ctx: { props: ServiceProps; services: DgpServiceMap },
    cap: { dripfeed?: boolean; refill?: boolean; cancel?: boolean },
): boolean {
    const tag = ctx.props.filters.find((t) => t.id === tagId);
    const eff = tag?.constraints; // effective constraints (should already be propagated)
    if (!eff) return true;
    // Only enforce flags explicitly set TRUE at the tag; false/undefined = no requirement
    if (eff.dripfeed === true && !cap.dripfeed) return false;
    if (eff.refill === true && !cap.refill) return false;
    return !(eff.cancel === true && !cap.cancel);
}

function primaryForNode(
    props: ServiceProps,
    nodeId: string,
): {
    primary?: ServiceIdRef;
    tagContexts: string[];
    reasonNoPrimary?: string;
} {
    // Tag node?
    const tag = props.filters.find((t) => t.id === nodeId);
    if (tag) {
        return { primary: tag.service_id as any, tagContexts: [tag.id] };
    }
    // Option node: locate its parent field
    const field = props.fields.find(
        (f) =>
            Array.isArray(f.options) && f.options.some((o) => o.id === nodeId),
    );
    if (!field) return { tagContexts: [], reasonNoPrimary: "no_parent_field" };
    const opt = field.options!.find((o) => o.id === nodeId)!;
    const contexts = bindIdsToArray(field.bind_id);
    return { primary: opt.service_id as any, tagContexts: contexts };
}

function bindIdsToArray(bind: string | string[] | undefined): string[] {
    if (!bind) return [];
    return Array.isArray(bind) ? bind.slice() : [bind];
}

/**
 * Return all fallback candidates that are eligible for the given primary,
 * respecting:
 *  - node-scoped list first (if nodeId provided), then global list for `primary`
 *  - rate policy vs. primary
 *  - (optional) tag constraint fit, only when tagId is provided and requireConstraintFit=true
 *  - excludes (including primary automatically)
 *  - selectionStrategy: 'priority' keeps list order, 'cheapest' sorts by rate asc
 *  - unique (dedupe) and optional limit
 */
export function getEligibleFallbacks(params: {
    primary: ServiceIdRef;
    nodeId?: NodeIdRef; // prefer node-scoped list first
    tagId?: string; // constraints context (if known)
    services: DgpServiceMap;
    fallbacks?: ServiceFallback;
    settings?: FallbackSettings;
    props: ServiceProps;
    exclude?: Array<ServiceIdRef>; // additional ids to ignore
    unique?: boolean; // default true
    limit?: number; // optional cap
}): ServiceIdRef[] {
    const s = { ...DEFAULT_SETTINGS, ...(params.settings ?? {}) };
    const { primary, nodeId, tagId, services } = params;
    const fb = params.fallbacks ?? {};
    const excludes = new Set<string>((params.exclude ?? []).map(String));
    excludes.add(String(primary)); // never return the primary itself
    const unique = params.unique ?? true;

    // Gather source lists: node → global
    const lists: ServiceIdRef[][] = [];
    if (nodeId && fb.nodes?.[nodeId]) lists.push(fb.nodes[nodeId]);
    if (fb.global?.[primary]) lists.push(fb.global[primary]);

    if (!lists.length) return [];

    const primaryRate = rateOf(services, primary);
    const seen = new Set<string>();
    const eligible: ServiceIdRef[] = [];

    for (const list of lists) {
        for (const cand of list) {
            const key = String(cand);
            if (excludes.has(key)) continue;
            if (unique && seen.has(key)) continue;
            seen.add(key);

            const cap = getCap(services, cand);
            if (!cap) continue;

            // Rate policy must pass
            if (!passesRate(s.ratePolicy, primaryRate, cap.rate)) continue;

            // Tag constraint fit is only enforced if we know tagId and setting requires it
            if (s.requireConstraintFit && tagId) {
                const ok = satisfiesTagConstraints(
                    tagId,
                    { props: params.props, services },
                    cap,
                );
                if (!ok) continue;
            }

            eligible.push(cand);
        }
    }

    // Selection strategy
    if (s.selectionStrategy === "cheapest") {
        eligible.sort((a, b) => {
            const ra = rateOf(services, a) ?? Infinity;
            const rb = rateOf(services, b) ?? Infinity;
            return ra - rb;
        });
    }
    // 'priority' keeps original order

    // Optional limit
    if (typeof params.limit === "number" && params.limit >= 0) {
        return eligible.slice(0, params.limit);
    }
    return eligible;
}
```

---
#### 13


` File: src/core/index.ts`  [↑ Back to top](#index)

```ts
export * from "./normalise";
export * from "./validate";
export * from "./builder";
export * from "./fallback";
export * from "./rate-coherence";
```

---
#### 14


` File: src/core/normalise.ts`  [↑ Back to top](#index)

```ts
// src/core/normalise.ts

import type {
    ServiceProps,
    Tag,
    Field,
    FieldOption,
    PricingRole,
    ServiceFallback,
    ServiceIdRef,
} from "../schema";

export type NormaliseOptions = {
    /** default pricing role for fields/options when missing */
    defaultPricingRole?: PricingRole; // default: 'base'
};

export function normalise(
    input: unknown,
    opts: NormaliseOptions = {},
): ServiceProps {
    const defRole: PricingRole = opts.defaultPricingRole ?? "base";
    const obj = toObject(input);

    // ── Canonical top-level keys only
    const rawFilters = Array.isArray((obj as any).filters)
        ? (obj as any).filters
        : [];
    const rawFields = Array.isArray((obj as any).fields)
        ? (obj as any).fields
        : [];

    const includes_for_buttons = toStringArrayMap(
        (obj as any).includes_for_buttons,
    );
    const excludes_for_buttons = toStringArrayMap(
        (obj as any).excludes_for_buttons,
    );

    // Tags & fields
    let filters: Tag[] = rawFilters.map(coerceTag);
    const fields: Field[] = rawFields.map((f: any) => coerceField(f, defRole));

    // ── Ensure a root tag exists (id: 't:root')
    if (!filters.some((t) => t.id === "t:root")) {
        filters = [{ id: "t:root", label: "Root" }, ...filters];
    }

    // Canonical fallbacks only
    const fallbacks = coerceFallbacks((obj as any).fallbacks);

    const out: ServiceProps = {
        filters,
        fields,
        ...(isNonEmpty(includes_for_buttons) && { includes_for_buttons }),
        ...(isNonEmpty(excludes_for_buttons) && { excludes_for_buttons }),
        ...(fallbacks &&
            (isNonEmpty(fallbacks.nodes) || isNonEmpty(fallbacks.global)) && {
                fallbacks,
            }),
        schema_version:
            typeof (obj as any).schema_version === "string"
                ? (obj as any).schema_version
                : "1.0",
    };

    propagateConstraints(out);
    return out;
}

/* ───────────────────────── Constraint propagation ───────────────────────── */

const FLAG_KEYS = ["refill", "cancel", "dripfeed"] as const;
type FlagKey = (typeof FLAG_KEYS)[number];

/**
 * Propagate constraint flags down the tag tree:
 * - Any flag defined on an ancestor overrides the child's local value.
 * - Writes back the effective value to each tag.constraints.
 * - Records provenance in tag.constraints_origin[flag] = <originTagId>.
 * - Records child overrides in tag.constraints_overrides[flag] = { from, to, origin }.
 *
 * IMPORTANT: Children inherit the **effective** value from their parent,
 * not the parent's raw local. This ensures overridden values keep propagating.
 */
function propagateConstraints(props: ServiceProps): void {
    const tags = Array.isArray(props.filters) ? props.filters : [];
    if (!tags.length) return;

    const byId = new Map(tags.map((t) => [t.id, t]));
    const children = new Map<string, Tag[]>();

    for (const t of tags) {
        const pid = t.bind_id;
        if (!pid || !byId.has(pid)) continue;
        if (!children.has(pid)) children.set(pid, []);
        children.get(pid)!.push(t);
    }

    const roots = tags.filter((t) => !t.bind_id || !byId.has(t.bind_id));
    const starts = roots.length ? roots : tags;

    type Inherited = Partial<Record<FlagKey, { val: boolean; origin: string }>>;
    const visited = new Set<string>();

    const visit = (tag: Tag, inherited: Inherited) => {
        if (visited.has(tag.id)) return;
        visited.add(tag.id);

        const local = tag.constraints ?? {};
        const next: Partial<Record<FlagKey, boolean>> = {};
        const origin: Partial<Record<FlagKey, string>> = {};
        const overrides: NonNullable<Tag["constraints_overrides"]> = {};

        for (const k of FLAG_KEYS) {
            const inh = inherited[k];
            const prev = local[k];

            if (inh) {
                if (prev === undefined) {
                    next[k] = inh.val;
                    origin[k] = inh.origin;
                } else if (prev === inh.val) {
                    next[k] = inh.val;
                    origin[k] = tag.id;
                } else {
                    next[k] = inh.val;
                    origin[k] = inh.origin;
                    overrides[k] = {
                        from: prev as boolean,
                        to: inh.val,
                        origin: inh.origin,
                    };
                }
            } else if (prev !== undefined) {
                next[k] = prev as boolean;
                origin[k] = tag.id;
            }
        }

        // Persist only defined keys (keep JSON lean)
        const definedConstraints: Partial<Record<FlagKey, boolean>> = {};
        const definedOrigin: Partial<Record<FlagKey, string>> = {};
        const definedOverrides: NonNullable<Tag["constraints_overrides"]> = {};

        for (const k of FLAG_KEYS) {
            if (next[k] !== undefined)
                definedConstraints[k] = next[k] as boolean;
            if (origin[k] !== undefined) definedOrigin[k] = origin[k] as string;
            if (overrides[k] !== undefined) definedOverrides[k] = overrides[k]!;
        }

        tag.constraints = Object.keys(definedConstraints).length
            ? definedConstraints
            : undefined;
        tag.constraints_origin = Object.keys(definedOrigin).length
            ? definedOrigin
            : undefined;
        tag.constraints_overrides = Object.keys(definedOverrides).length
            ? definedOverrides
            : undefined;

        // Children inherit effective values + nearest origin
        const passDown: Inherited = { ...inherited };
        for (const k of FLAG_KEYS) {
            if (next[k] !== undefined && origin[k] !== undefined) {
                passDown[k] = { val: next[k] as boolean, origin: origin[k]! };
            }
        }
        for (const c of children.get(tag.id) ?? []) visit(c, passDown);
    };

    for (const r of starts) visit(r, {});
}

/* ───────────────────────────── coercers ───────────────────────────── */

function coerceTag(src: any): Tag {
    if (!src || typeof src !== "object") src = {};
    const id = str(src.id);
    const label = str(src.label);
    const bind_id = str(src.bind_id) || undefined;
    const service_id = toNumberOrUndefined(src.service_id);

    const includes = toStringArray(src.includes);
    const excludes = toStringArray(src.excludes);

    const constraints =
        src.constraints && typeof src.constraints === "object"
            ? {
                  refill: bool((src.constraints as any).refill),
                  cancel: bool((src.constraints as any).cancel),
                  dripfeed: bool((src.constraints as any).dripfeed),
              }
            : undefined;

    const meta =
        src.meta && typeof src.meta === "object"
            ? (src.meta as Record<string, unknown>)
            : undefined;

    const tag: Tag = {
        id: "",
        label: "",
        ...(id && { id }),
        ...(label && { label }),
        ...(bind_id && { bind_id }),
        ...(service_id !== undefined && { service_id }),
        ...(constraints && { constraints }),
        ...(includes.length && { includes: dedupe(includes) }),
        ...(excludes.length && { excludes: dedupe(excludes) }),
        ...(meta && { meta }),
    };
    return tag;
}
function coerceField(src: any, defRole: PricingRole): Field {
    if (!src || typeof src !== "object") src = {};

    const bind_id = normaliseBindId(src.bind_id);
    const type = str(src.type) || "text";
    const id = str(src.id);
    const name = typeof src.name === "string" ? src.name : undefined;

    // BaseFieldUI (trimmed)
    const label = str(src.label) || "";
    const required = !!src.required;

    // host-defined UI schema + defaults (pass-through if objects)
    const ui =
        src.ui && typeof src.ui === "object"
            ? (src.ui as Record<string, unknown>)
            : undefined;
    const defaults =
        src.defaults && typeof src.defaults === "object"
            ? (src.defaults as Record<string, unknown>)
            : undefined;

    // field-level role (used as default for options)
    const pricing_role: PricingRole =
        src.pricing_role === "utility" || src.pricing_role === "base"
            ? src.pricing_role
            : defRole;

    // options
    const srcHasOptions = Array.isArray(src.options) && src.options.length > 0;
    const options = srcHasOptions
        ? (src.options as any[]).map((o) => coerceOption(o, pricing_role))
        : undefined;

    // custom component (only for type === 'custom')
    const component =
        type === "custom" ? str(src.component) || undefined : undefined;

    // meta (pass-through)
    const meta =
        src.meta && typeof src.meta === "object"
            ? { ...(src.meta as any) }
            : undefined;

    // button rule:
    // - option-based fields are always buttons
    // - otherwise, respect explicit boolean true
    const button: boolean = srcHasOptions ? true : src.button === true;

    // field-level service_id is allowed only for *buttons* with base role
    const field_service_id_raw = toNumberOrUndefined(src.service_id);
    const field_service_id =
        button &&
        pricing_role !== "utility" &&
        field_service_id_raw !== undefined
            ? field_service_id_raw
            : undefined;

    const field: Field = {
        id,
        type,
        ...(bind_id !== undefined && { bind_id }),
        ...(name && { name }),
        ...(options && options.length && { options }),
        ...(component && { component }),
        pricing_role,
        label,
        required,
        ...(ui && { ui: ui as any }),
        ...(defaults && { defaults }),
        ...(meta && { meta }),
        ...(button ? { button } : {}),
        ...(field_service_id !== undefined && { service_id: field_service_id }),
    };

    return field;
}

function coerceOption(src: any, inheritRole: PricingRole): FieldOption {
    if (!src || typeof src !== "object") src = {};
    const id = str(src.id);
    const label = str(src.label);
    const service_id = toNumberOrUndefined(src.service_id);
    const value =
        typeof src.value === "string" || typeof src.value === "number"
            ? (src.value as string | number)
            : undefined;

    const pricing_role: PricingRole =
        src.pricing_role === "utility" || src.pricing_role === "base"
            ? src.pricing_role
            : inheritRole;

    const meta =
        src.meta && typeof src.meta === "object"
            ? (src.meta as Record<string, unknown>)
            : undefined;

    const option: FieldOption = {
        id: "",
        label: "",
        ...(id && { id }),
        ...(label && { label }),
        ...(value !== undefined && { value }),
        ...(service_id !== undefined && { service_id }),
        pricing_role,
        ...(meta && { meta }),
    };
    return option;
}

/* ───────────────────────── fallbacks (canonical only) ───────────────────────── */

function coerceFallbacks(src: any): ServiceFallback | undefined {
    if (!src || typeof src !== "object") return undefined;

    const out: ServiceFallback = {};
    const g = (src as any).global;
    const n = (src as any).nodes;

    if (g && typeof g === "object") {
        const rg: Record<string, ServiceIdRef[]> = {};
        for (const [k, v] of Object.entries(g)) {
            const key = String(k);
            const arr = toServiceIdArray(v);
            const clean = dedupe(arr.filter((x) => String(x) !== key));
            if (clean.length) rg[key] = clean;
        }
        if (Object.keys(rg).length) out.global = rg;
    }

    if (n && typeof n === "object") {
        const rn: Record<string, ServiceIdRef[]> = {};
        for (const [nodeId, v] of Object.entries(n)) {
            const key = String(nodeId);
            const arr = toServiceIdArray(v);
            const clean = dedupe(arr.filter((x) => String(x) !== key));
            if (clean.length) rn[key] = clean;
        }
        if (Object.keys(rn).length) out.nodes = rn;
    }

    return out.nodes || out.global ? out : undefined;
}

/* ───────────────────────── utilities ───────────────────────── */

function toObject(input: unknown): Record<string, unknown> {
    if (input && typeof input === "object")
        return input as Record<string, unknown>;
    throw new TypeError("normalise(): expected an object payload");
}

function normaliseBindId(bind: unknown): string | string[] | undefined {
    if (typeof bind === "string" && bind.trim()) return bind.trim();
    if (Array.isArray(bind)) {
        const arr = dedupe(bind.map((b) => String(b).trim()).filter(Boolean));
        if (arr.length === 0) return undefined;
        if (arr.length === 1) return arr[0];
        return arr;
    }
    return undefined;
}

function toStringArrayMap(src: any): Record<string, string[]> | undefined {
    if (!src || typeof src !== "object") return undefined;
    const out: Record<string, string[]> = {};
    for (const [k, v] of Object.entries(src)) {
        if (!k) continue;
        const arr = toStringArray(v);
        if (arr.length) out[k] = dedupe(arr);
    }
    return Object.keys(out).length ? out : undefined;
}

function toStringArray(v: any): string[] {
    if (!Array.isArray(v)) return [];
    return v.map((x) => String(x)).filter((s) => !!s && s.trim().length > 0);
}

function toNumberOrUndefined(v: any): number | undefined {
    if (v === null || v === undefined) return undefined;
    const n = Number(v);
    return Number.isFinite(n) ? n : undefined;
}

function str(v: any): string | undefined {
    if (typeof v === "string" && v.trim().length > 0) return v.trim();
    return undefined;
}

function bool(v: any): boolean | undefined {
    if (v === undefined) return undefined;
    return !!v;
}

function dedupe<T>(arr: T[]): T[] {
    return Array.from(new Set(arr));
}

function isNonEmpty<T extends Record<string, any> | undefined>(
    obj: T,
): obj is NonNullable<T> {
    return !!obj && Object.keys(obj).length > 0;
}

function toServiceIdArray(v: any): ServiceIdRef[] {
    if (!Array.isArray(v)) return [];
    return v
        .map((x) =>
            typeof x === "number" || typeof x === "string" ? x : String(x),
        )
        .filter(
            (x) => x !== "" && x !== null && x !== undefined,
        ) as ServiceIdRef[];
}
```

---
#### 15


` File: src/core/policy.ts`  [↑ Back to top](#index)

```ts
// src/core/policy.ts
import type { DynamicRule, ValidatorOptions } from '../schema/validation';

export type PolicyDiagnostic = {
    ruleIndex: number;
    ruleId?: string;
    severity: 'error' | 'warning';
    message: string;
    path?: string; // e.g. "filter.role", "op"
};

const ALLOWED_SCOPES = new Set<DynamicRule['scope']>(['global', 'visible_group']);
const ALLOWED_SUBJECTS = new Set<DynamicRule['subject']>(['services']);
const ALLOWED_OPS = new Set<DynamicRule['op']>([
    'all_equal', 'unique', 'no_mix', 'all_true', 'any_true', 'max_count', 'min_count',
]);
const ALLOWED_ROLES = new Set<NonNullable<DynamicRule['filter']>['role']>(['base', 'utility', 'both']);
const ALLOWED_SEVERITIES = new Set<NonNullable<DynamicRule['severity']>>(['error', 'warning']);

function asArray<T>(v: T | T[] | undefined): T[] | undefined {
    if (v === undefined) return undefined;
    return Array.isArray(v) ? v : [v];
}

/**
 * Compile & validate arbitrary JSON into DynamicRule[] with defaults:
 * - scope: (default) "visible_group"
 * - subject: (default) "services"
 * - filter.role: (default) "both"
 * - severity: (default) "error"
 * - projection: (default) "service.id"
 *
 * Returns normalized rules + diagnostics (errors/warnings).
 */
export function compilePolicies(raw: unknown): {
    policies: DynamicRule[];
    diagnostics: PolicyDiagnostic[];
} {
    const diagnostics: PolicyDiagnostic[] = [];
    const policies: DynamicRule[] = [];

    if (!Array.isArray(raw)) {
        diagnostics.push({
            ruleIndex: -1,
            severity: 'error',
            message: 'Policies root must be an array.',
        });
        return { policies, diagnostics };
    }

    raw.forEach((entry, i) => {
        const d: PolicyDiagnostic[] = [];
        const src = (entry && typeof entry === 'object') ? (entry as any) : {};
        let id: string | undefined = typeof src.id === 'string' && src.id.trim() ? src.id.trim() : undefined;

        // id default
        if (!id) {
            id = `policy_${i + 1}`;
            d.push({ ruleIndex: i, ruleId: id, severity: 'warning', message: 'Missing "id"; generated automatically.', path: 'id' });
        }

        // scope default + validation
        let scope: DynamicRule['scope'] =
            ALLOWED_SCOPES.has(src.scope) ? src.scope : (src.scope === undefined ? 'visible_group' : 'visible_group');
        if (src.scope !== undefined && !ALLOWED_SCOPES.has(src.scope)) {
            d.push({ ruleIndex: i, ruleId: id, severity: 'warning', message: 'Unknown "scope"; defaulted to "visible_group".', path: 'scope' });
        }

        // subject default + validation
        let subject: DynamicRule['subject'] =
            ALLOWED_SUBJECTS.has(src.subject) ? src.subject : 'services';
        if (src.subject !== undefined && !ALLOWED_SUBJECTS.has(src.subject)) {
            d.push({ ruleIndex: i, ruleId: id, severity: 'warning', message: 'Unknown "subject"; defaulted to "services".', path: 'subject' });
        }

        // op required & valid
        const op: DynamicRule['op'] = src.op;
        if (!ALLOWED_OPS.has(op)) {
            d.push({ ruleIndex: i, ruleId: id, severity: 'error', message: `Invalid "op": ${String(op)}.`, path: 'op' });
        }

        // projection default
        let projection: string | undefined = typeof src.projection === 'string' && src.projection.trim()
            ? src.projection.trim()
            : 'service.id';

        // For services subject, encourage service.* projection
        if (subject === 'services' && projection && !projection.startsWith('service.')) {
            d.push({ ruleIndex: i, ruleId: id, severity: 'warning', message: 'Projection should start with "service." for subject "services".', path: 'projection' });
        }

        // filter defaults & shape
        const filterSrc = (src.filter && typeof src.filter === 'object') ? src.filter as DynamicRule['filter'] : undefined;
        const role: NonNullable<DynamicRule['filter']>['role'] =
            filterSrc?.role && ALLOWED_ROLES.has(filterSrc.role) ? filterSrc.role : 'both';
        if (filterSrc?.role && !ALLOWED_ROLES.has(filterSrc.role)) {
            d.push({ ruleIndex: i, ruleId: id, severity: 'warning', message: 'Unknown filter.role; defaulted to "both".', path: 'filter.role' });
        }

        const filter: DynamicRule['filter'] | undefined = {
            role,
            handler_id: filterSrc?.handler_id !== undefined ? (Array.isArray(filterSrc.handler_id) ? filterSrc.handler_id : [filterSrc.handler_id]) : undefined,
            platform_id: filterSrc?.platform_id !== undefined ? (Array.isArray(filterSrc.platform_id) ? filterSrc.platform_id : [filterSrc.platform_id]) : undefined,
            tag_id: filterSrc?.tag_id !== undefined ? (Array.isArray(filterSrc.tag_id) ? filterSrc.tag_id : [filterSrc.tag_id]) : undefined,
            field_id: filterSrc?.field_id !== undefined ? (Array.isArray(filterSrc.field_id) ? filterSrc.field_id : [filterSrc.field_id]) : undefined,
        };

        // severity default
        const severity: NonNullable<DynamicRule['severity']> =
            ALLOWED_SEVERITIES.has(src.severity) ? src.severity : 'error';
        if (src.severity !== undefined && !ALLOWED_SEVERITIES.has(src.severity)) {
            d.push({ ruleIndex: i, ruleId: id, severity: 'warning', message: 'Unknown "severity"; defaulted to "error".', path: 'severity' });
        }

        // value requirements by op
        const value = src.value;
        if (op === 'max_count' || op === 'min_count') {
            if (!(typeof value === 'number' && Number.isFinite(value))) {
                d.push({ ruleIndex: i, ruleId: id, severity: 'error', message: `"${op}" requires numeric "value".`, path: 'value' });
            }
        } else if (op === 'all_true' || op === 'any_true') {
            if (value !== undefined) {
                d.push({ ruleIndex: i, ruleId: id, severity: 'warning', message: `"${op}" ignores "value"; it checks all/any true.`, path: 'value' });
            }
        } else {
            if (value !== undefined) {
                d.push({ ruleIndex: i, ruleId: id, severity: 'warning', message: `"${op}" does not use "value".`, path: 'value' });
            }
        }

        // assemble rule if no fatal (error-level) diagnostics for op/value
        const hasFatal = d.some(x => x.severity === 'error');
        if (!hasFatal) {
            const rule: DynamicRule = {
                id,
                scope,
                subject,
                filter,
                projection,
                op,
                value: value as any,
                severity,
                message: typeof src.message === 'string' ? src.message : undefined,
            };
            policies.push(rule);
        }

        diagnostics.push(...d);
    });

    return { policies, diagnostics };
}

/** Split diagnostics for convenience in UI */
export function splitPolicyDiagnostics(diags: PolicyDiagnostic[]): {
    errors: PolicyDiagnostic[];
    warnings: PolicyDiagnostic[];
} {
    return {
        errors: diags.filter(d => d.severity === 'error'),
        warnings: diags.filter(d => d.severity === 'warning'),
    };
}

/**
 * Convenience helper: compile policies and pass to validator options.
 * You can use this in your editor before calling validate().
 */
export function withCompiledPolicies(
    opts: ValidatorOptions,
    rawPolicies: unknown,
): { opts: ValidatorOptions; diagnostics: PolicyDiagnostic[] } {
    const { policies, diagnostics } = compilePolicies(rawPolicies);
    return { opts: { ...opts, policies }, diagnostics };
}
```

---
#### 16


` File: src/core/rate-coherence.ts`  [↑ Back to top](#index)

```ts
import { RatePolicy } from "../schema/validation";
import { Builder } from "./builder";
import { DgpServiceCapability, DgpServiceMap } from "../schema/provider";
import { Field, PricingRole, ServiceProps, Tag } from "../schema";

type BaseCandidate = {
    kind: "field" | "option";
    id: string;
    label?: string;
    service_id: number;
    rate: number;
};

/** Result for each violation discovered during deep simulation. */
export type RateCoherenceDiagnostic = {
    scope: "visible_group";
    tagId: string;
    /** The “primary” used for comparison in this simulation:
     *  anchor service if present; otherwise, the first base service among simulated candidates.
     *  (Tag service is never used as primary.)
     */
    primary: BaseCandidate;
    /** The item that violated the policy against the primary. */
    offender: {
        kind: "field" | "option";
        id: string;
        label?: string;
        service_id: number;
        rate: number;
    };
    policy: RatePolicy["kind"];
    policyPct?: number; // for within_pct / at_least_pct_lower
    message: string;
    /** Which button triggered this simulation */
    simulationAnchor: {
        kind: "field" | "option";
        id: string;
        fieldId: string;
        label?: string;
    };
};

/** Run deep rate-coherence validation by simulating each button selection in the active tag. */
export function validateRateCoherenceDeep(params: {
    builder: Builder;
    services: DgpServiceMap;
    tagId: string;
    /** Optional rate policy (defaults to { kind: 'lte_primary' }) */
    ratePolicy?: RatePolicy;
}): RateCoherenceDiagnostic[] {
    const { builder, services, tagId } = params;
    const ratePolicy: RatePolicy = params.ratePolicy ?? { kind: "lte_primary" };
    const props = builder.getProps() as ServiceProps;

    // Indexes
    const fields = props.fields ?? [];
    const fieldById = new Map(fields.map((f) => [f.id, f]));
    const tagById = new Map((props.filters ?? []).map((t) => [t.id, t]));
    const tag: Tag | undefined = tagById.get(tagId);

    // Baseline visible fields (no selection)
    const baselineFieldIds = builder.visibleFields(tagId, []);
    const baselineFields = baselineFieldIds
        .map((fid) => fieldById.get(fid))
        .filter(Boolean) as Field[];

    // Build the list of *simulation anchors* = every button in the baseline group
    const anchors: Array<{
        kind: "field" | "option";
        id: string;
        fieldId: string;
        label?: string;
        service_id?: number;
    }> = [];

    for (const f of baselineFields) {
        if (!isButton(f)) continue;

        if (Array.isArray(f.options) && f.options.length) {
            // Option buttons → every option becomes an anchor (even if it has no base service)
            for (const o of f.options) {
                anchors.push({
                    kind: "option",
                    id: o.id,
                    fieldId: f.id,
                    label: o.label ?? o.id,
                    service_id: numberOrUndefined((o as any).service_id),
                });
            }
        } else {
            // Non-option button → the field itself is an anchor (even if it has no base service)
            anchors.push({
                kind: "field",
                id: f.id,
                fieldId: f.id,
                label: f.label ?? f.id,
                service_id: numberOrUndefined((f as any).service_id),
            });
        }
    }

    const diags: RateCoherenceDiagnostic[] = [];
    const seen = new Set<string>(); // dedupe across simulations

    for (const anchor of anchors) {
        // Build the simulated “selected keys” (how includes_for_buttons is addressed)
        const selectedKeys =
            anchor.kind === "option"
                ? [`${anchor.fieldId}::${anchor.id}`]
                : [anchor.fieldId];

        // Recompute the visible group under this simulation
        const vgFieldIds = builder.visibleFields(tagId, selectedKeys);
        const vgFields = vgFieldIds
            .map((fid) => fieldById.get(fid))
            .filter(Boolean) as Field[];

        // Collect base service candidates in this simulated group
        const baseCandidates: Array<BaseCandidate> = [];

        for (const f of vgFields) {
            if (!isButton(f)) continue;

            if (Array.isArray(f.options) && f.options.length) {
                for (const o of f.options) {
                    const sid = numberOrUndefined((o as any).service_id);
                    const role = normalizeRole(o.pricing_role, "base");
                    if (sid == null || role !== "base") continue;
                    const r = rateOf(services, sid);
                    if (!isFiniteNumber(r)) continue;
                    baseCandidates.push({
                        kind: "option",
                        id: o.id,
                        label: o.label ?? o.id,
                        service_id: sid,
                        rate: r!,
                    });
                }
            } else {
                const sid = numberOrUndefined((f as any).service_id);
                const role = normalizeRole((f as any).pricing_role, "base");
                if (sid == null || role !== "base") continue;
                const r = rateOf(services, sid);
                if (!isFiniteNumber(r)) continue;
                baseCandidates.push({
                    kind: "field",
                    id: f.id,
                    label: f.label ?? f.id,
                    service_id: sid,
                    rate: r!,
                });
            }
        }

        if (baseCandidates.length === 0) continue;

        // Choose the “primary” for this simulation:
        // 1) Anchor’s base service (if present),
        // 2) else first base candidate (deterministic).
        const anchorPrimary =
            anchor.service_id != null
                ? pickByServiceId(baseCandidates, anchor.service_id)
                : undefined;

        const primary = anchorPrimary ? anchorPrimary : baseCandidates[0]!;

        // Compare every *other* candidate against the primary using the configured policy
        for (const cand of baseCandidates) {
            if (sameService(primary, cand)) continue;

            if (!rateOkWithPolicy(ratePolicy, cand.rate, primary.rate)) {
                const key = dedupeKey(tagId, anchor, primary, cand, ratePolicy);
                if (seen.has(key)) continue;
                seen.add(key);

                diags.push({
                    scope: "visible_group",
                    tagId,
                    primary,
                    offender: {
                        kind: cand.kind,
                        id: cand.id,
                        label: cand.label,
                        service_id: cand.service_id,
                        rate: cand.rate,
                    },
                    policy: ratePolicy.kind,
                    policyPct: "pct" in ratePolicy ? ratePolicy.pct : undefined,
                    message: explainRateMismatch(
                        ratePolicy,
                        primary.rate,
                        cand.rate,
                        describeLabel(tag),
                    ),
                    simulationAnchor: {
                        kind: anchor.kind,
                        id: anchor.id,
                        fieldId: anchor.fieldId,
                        label: anchor.label,
                    },
                });
            }
        }
    }

    return diags;
}

/* ───────────────────────── helpers ───────────────────────── */

function isButton(f: Field): boolean {
    // Buttons = explicit flag OR any option-based field
    if ((f as any).button === true) return true;
    return Array.isArray(f.options) && f.options.length > 0;
}

function normalizeRole(
    role: PricingRole | undefined,
    d: PricingRole,
): PricingRole {
    return role === "utility" || role === "base" ? role : d;
}

function numberOrUndefined(v: unknown): number | undefined {
    const n = Number(v);
    return Number.isFinite(n) ? n : undefined;
}

function isFiniteNumber(v: unknown): v is number {
    return typeof v === "number" && Number.isFinite(v);
}

function rateOf(
    map: DgpServiceMap,
    id: number | string | undefined,
): number | undefined {
    if (id === undefined || id === null) return undefined;
    const cap: DgpServiceCapability | undefined =
        map[Number(id)] ?? (map as any)[id];
    return cap?.rate;
}

function pickByServiceId<T extends BaseCandidate>(
    arr: T[],
    sid: number,
): T | undefined {
    return arr.find((x) => x.service_id === sid);
}

function sameService(a: { service_id: number }, b: { service_id: number }) {
    return a.service_id === b.service_id;
}

function rateOkWithPolicy(
    policy: RatePolicy,
    candRate: number,
    primaryRate: number,
): boolean {
    const rp = policy ?? { kind: "lte_primary" as const };
    switch (rp.kind) {
        case "lte_primary":
            return candRate <= primaryRate;
        case "within_pct": {
            const pct = Math.max(0, rp.pct ?? 0);
            return candRate <= primaryRate * (1 + pct / 100);
        }
        case "at_least_pct_lower": {
            const pct = Math.max(0, rp.pct ?? 0);
            return candRate <= primaryRate * (1 - pct / 100);
        }
        default:
            return candRate <= primaryRate;
    }
}

function describeLabel(tag?: Tag): string {
    const tagName = tag?.label ?? tag?.id ?? "tag";
    return `${tagName}`;
}

function explainRateMismatch(
    policy: RatePolicy,
    primary: number,
    candidate: number,
    where: string,
): string {
    switch (policy.kind) {
        case "lte_primary":
            return `Rate coherence failed (${where}): candidate ${candidate} must be ≤ primary ${primary}.`;
        case "within_pct":
            return `Rate coherence failed (${where}): candidate ${candidate} must be within ${policy.pct}% of primary ${primary}.`;
        case "at_least_pct_lower":
            return `Rate coherence failed (${where}): candidate ${candidate} must be at least ${policy.pct}% lower than primary ${primary}.`;
        default:
            return `Rate coherence failed (${where}): candidate ${candidate} mismatches primary ${primary}.`;
    }
}

function dedupeKey(
    tagId: string,
    anchor: { kind: "field" | "option"; id: string },
    primary: { service_id: number },
    cand: { service_id: number; id: string },
    rp: RatePolicy,
) {
    const rpKey =
        rp.kind +
        ("pct" in rp && typeof rp.pct === "number" ? `:${rp.pct}` : "");
    return `${tagId}|${anchor.kind}:${anchor.id}|p${primary.service_id}|c${cand.service_id}:${cand.id}|${rpKey}`;
}
```

---
#### 17


` File: src/core/validate.ts`  [↑ Back to top](#index)

```ts
// src/core/validate.ts
import type {
    ServiceProps,
    Tag,
    Field,

} from '../schema';
import type {
    DgpServiceMap,
} from '../schema/provider';
import type {
    DynamicRule,
    ValidationError,
    ValidatorOptions,
} from '../schema/validation';
import {isMultiField} from "../utils";
import {collectFailedFallbacks} from "./fallback";

const FLAG_KEYS = ['refill', 'cancel', 'dripfeed'] as const;
type FlagKey = typeof FLAG_KEYS[number];

/**
 * Validate a ServiceProps payload against structural, identity, visibility,
 * service/input, rates, constraints, and custom-field rules.
 *
 * Notes:
 * - JSON Schema should handle shape; this performs business logic checks.
 * - "custom component resolvable" requires a registry — not covered here.
 */
export function validate(
    props: ServiceProps,
    ctx: ValidatorOptions = {}
): ValidationError[] {
    const errors: ValidationError[] = [];
    const serviceMap: DgpServiceMap = ctx.serviceMap ?? {};
    const selectedKeys = new Set(ctx.selectedOptionKeys ?? []);

    const tagById = new Map<string, Tag>();
    const fieldById = new Map<string, Field>();

    /* ────────────────────────────────────────────────────────────────
     * 1) STRUCTURE: root, cycles, bind references
     * ──────────────────────────────────────────────────────────────── */
    const tags = Array.isArray(props.filters) ? props.filters : [];
    const fields = Array.isArray(props.fields) ? props.fields : [];

    // root present
    if (!tags.some(t => t.id === 'root')) {
        errors.push({code: 'root_missing'});
    }

    // indexes
    for (const t of tags) tagById.set(t.id, t);
    for (const f of fields) fieldById.set(f.id, f);

    // cycles in tag parentage
    const visiting = new Set<string>();
    const visited = new Set<string>();
    const hasCycleFrom = (id: string): boolean => {
        if (visiting.has(id)) return true;
        if (visited.has(id)) return false;
        visiting.add(id);
        const parent = tagById.get(id)?.bind_id;
        if (parent && tagById.has(parent) && hasCycleFrom(parent)) return true;
        visiting.delete(id);
        visited.add(id);
        return false;
    };
    for (const t of tags) {
        if (hasCycleFrom(t.id)) {
            errors.push({code: 'cycle_in_tags', nodeId: t.id});
            break; // one is enough to signal
        }
    }

    // tag.bind_id must point to existing tag (if present)
    for (const t of tags) {
        if (t.bind_id && !tagById.has(t.bind_id)) {
            errors.push({code: 'bad_bind_reference', nodeId: t.id, details: {ref: t.bind_id}});
        }
    }

    // field.bind_id must reference tags
    for (const f of fields) {
        const b = f.bind_id;
        if (Array.isArray(b)) {
            for (const id of b) {
                if (!tagById.has(id)) {
                    errors.push({code: 'bad_bind_reference', nodeId: f.id, details: {ref: id}});
                }
            }
        } else if (typeof b === 'string') {
            if (!tagById.has(b)) {
                errors.push({code: 'bad_bind_reference', nodeId: f.id, details: {ref: b}});
            }
        }
    }

    /* ────────────────────────────────────────────────────────────────
     * 2) IDENTITY & LABELS
     * ──────────────────────────────────────────────────────────────── */
    // duplicate ids across tags + fields
    {
        const seen = new Set<string>();
        for (const t of tags) {
            if (seen.has(t.id)) errors.push({code: 'duplicate_id', nodeId: t.id});
            seen.add(t.id);
        }
        for (const f of fields) {
            if (seen.has(f.id)) errors.push({code: 'duplicate_id', nodeId: f.id});
            seen.add(f.id);
        }
    }

    // tag labels unique
    {
        const seen = new Map<string, string>(); // label -> tagId
        for (const t of tags) {
            if (!t.label || !t.label.trim()) {
                errors.push({code: 'label_missing', nodeId: t.id, details: {kind: 'tag'}});
            }
            const k = t.label;
            if (seen.has(k)) errors.push({code: 'duplicate_tag_label', nodeId: t.id, details: {other: seen.get(k)}});
            else seen.set(k, t.id);
        }
    }

    // field labels required; names unique among user-input fields
    {
        const seenNames = new Map<string, string>(); // name -> fieldId
        for (const f of fields) {
            if (!f.label || !f.label.trim()) {
                errors.push({code: 'label_missing', nodeId: f.id, details: {kind: 'field'}});
            }
            const isUserInput = !!f.name && !hasAnyServiceOption(f);
            if (isUserInput && f.name) {
                const k = f.name;
                if (seenNames.has(k)) errors.push({
                    code: 'duplicate_field_name',
                    nodeId: f.id,
                    details: {other: seenNames.get(k)}
                });
                else seenNames.set(k, f.id);
            }
        }
    }

    // option labels required
    for (const f of fields) {
        for (const o of f.options ?? []) {
            if (!o.label || !o.label.trim()) {
                errors.push({code: 'label_missing', nodeId: o.id, details: {kind: 'option', fieldId: f.id}});
            }
        }
    }

    /* ────────────────────────────────────────────────────────────────
     * 3) OPTION MAPS: key validity + conflict
     * ──────────────────────────────────────────────────────────────── */
    const incMap = props.includes_for_buttons ?? {};
    const excMap = props.excludes_for_buttons ?? {};

    const parseKey = (key: string): { fieldId: string; optionId: string } | null => {
        const [fid, oid] = key.split('::');
        if (!fid || !oid) return null;
        return {fieldId: fid, optionId: oid};
    };

    const hasOption = (fid: string, oid: string): boolean => {
        const f = fieldById.get(fid);
        if (!f) return false;
        return !!(f.options ?? []).find(o => o.id === oid);
    };

    // bad_option_key
    for (const [k] of Object.entries(incMap)) {
        const p = parseKey(k);
        if (!p || !hasOption(p.fieldId, p.optionId)) {
            errors.push({code: 'bad_option_key', details: {key: k}});
        }
    }
    for (const [k] of Object.entries(excMap)) {
        const p = parseKey(k);
        if (!p || !hasOption(p.fieldId, p.optionId)) {
            errors.push({code: 'bad_option_key', details: {key: k}});
        }
    }

    // option_include_exclude_conflict
    for (const k of Object.keys(incMap)) {
        if (k in excMap) {
            const p = parseKey(k);
            errors.push({code: 'option_include_exclude_conflict', nodeId: p?.fieldId, details: {key: k}});
        }
    }

    /* ────────────────────────────────────────────────────────────────
     * 4) VISIBILITY: duplicate labels under a tag (bind/include − exclude)
     * (Option-level maps depend on runtime selection; ignored here)
     * ──────────────────────────────────────────────────────────────── */
    /* ───────── visibility helper (now selection-aware) ───────── */
    const fieldsVisibleUnder = (tagId: string): Field[] => {
        const tag = tagById.get(tagId);
        const includesTag = new Set(tag?.includes ?? []);
        const excludesTag = new Set(tag?.excludes ?? []);

        // Option-level maps only for the provided selections
        const incForOpt = props.includes_for_buttons ?? {};
        const excForOpt = props.excludes_for_buttons ?? {};

        const includesOpt = new Set<string>();
        const excludesOpt = new Set<string>();
        for (const key of selectedKeys) {
            for (const id of incForOpt[key] ?? []) includesOpt.add(id);
            for (const id of excForOpt[key] ?? []) excludesOpt.add(id);
        }

        // Base pool: bound + tag-includes + opt-includes
        const merged = new Map<string, Field>();
        for (const f of fields) {
            // bound to tag
            if (isBoundTo(f, tagId)) merged.set(f.id, f);
            // explicit includes (tag)
            if (includesTag.has(f.id)) merged.set(f.id, f);
            // option includes
            if (includesOpt.has(f.id)) merged.set(f.id, f);
        }

        // Remove excludes (tag + option)
        for (const id of excludesTag) merged.delete(id);
        for (const id of excludesOpt) merged.delete(id);

        return Array.from(merged.values());
    };

    /* ───────── duplicate visible labels (now selection-aware) ───────── */
    for (const t of tags) {
        const visible = fieldsVisibleUnder(t.id);
        const seen = new Map<string, string>();
        for (const f of visible) {
            const label = (f.label ?? '').trim();
            if (!label) continue;
            if (seen.has(label)) {
                errors.push({
                    code: 'duplicate_visible_label',
                    nodeId: f.id,
                    details: {tagId: t.id, other: seen.get(label)}
                });
            } else {
                seen.set(label, f.id);
            }
        }
    }

    /* ── Quantity marker rule: at most one marker per visible group (tag) ── */
    {
        for (const t of tags) {
            const visible = fieldsVisibleUnder(t.id);
            const markers: string[] = [];
            for (const f of visible) {
                const q = (f.meta as any)?.quantity;
                if (q) markers.push(f.id);
            }
            if (markers.length > 1) {
                errors.push({
                    code: 'quantity_multiple_markers',
                    nodeId: t.id,
                    details: {tagId: t.id, markers},
                });
            }
        }
    }

    /* ───────── utility_without_base per visible tag group (selection-aware) ───────── */
    for (const t of tags) {
        const visible = fieldsVisibleUnder(t.id);
        let hasBase = false;
        let hasUtility = false;
        const utilityOptionIds: string[] = [];

        for (const f of visible) {
            for (const o of f.options ?? []) {
                if (!isFiniteNumber(o.service_id)) continue;
                const role = o.pricing_role ?? f.pricing_role ?? 'base';
                if (role === 'base') hasBase = true;
                else if (role === 'utility') {
                    hasUtility = true;
                    utilityOptionIds.push(o.id);
                }
            }
        }
        if (hasUtility && !hasBase) {
            errors.push({code: 'utility_without_base', nodeId: t.id, details: {utilityOptionIds}});
        }
    }

    // --------- Dynamic policies (super-admin) --------------------------
    applyPolicies(errors, props, serviceMap, ctx.policies, fieldsVisibleUnder, tags);

    /* ────────────────────────────────────────────────────────────────
     * 5) SERVICE vs USER-INPUT RULES
     * ──────────────────────────────────────────────────────────────── */
    for (const f of fields) {
        const anySvc = hasAnyServiceOption(f);
        const hasName = !!(f.name && f.name.trim());
        // "custom" must not carry service options
        if (f.type === 'custom' && anySvc) {
            errors.push({
                code: 'user_input_field_has_service_option',
                nodeId: f.id,
                details: {reason: 'custom_cannot_map_service'}
            });
        }
        if (!hasName) {
            // treated as service-backed → require at least one service option
            if (!anySvc) {
                errors.push({code: 'service_field_missing_service_id', nodeId: f.id});
            }
        } else {
            // user-input → options must not carry service_id
            if (anySvc) {
                errors.push({code: 'user_input_field_has_service_option', nodeId: f.id});
            }
        }
    }

    // Utility rules — option-level (conflicts and marker validity)
    {
        const ALLOWED_UTILITY_MODES = new Set(['flat', 'per_quantity', 'per_value', 'percent']);
        for (const f of fields) {
            const optsArr = Array.isArray(f.options) ? f.options : [];
            for (const o of optsArr) {
                const role = o.pricing_role ?? f.pricing_role ?? 'base';
                const hasService = isFiniteNumber(o.service_id);
                const util = (o.meta as any)?.utility;

                if (role === 'utility' && hasService) {
                    errors.push({
                        code: 'utility_with_service_id',
                        nodeId: o.id,
                        details: {fieldId: f.id, optionId: o.id, service_id: o.service_id},
                    });
                }

                if (util) {
                    const mode = util.mode;
                    const rate = util.rate;
                    if (!isFiniteNumber(rate)) {
                        errors.push({
                            code: 'utility_missing_rate',
                            nodeId: o.id,
                            details: {fieldId: f.id, optionId: o.id},
                        });
                    }
                    if (!ALLOWED_UTILITY_MODES.has(mode)) {
                        errors.push({
                            code: 'utility_invalid_mode',
                            nodeId: o.id,
                            details: {fieldId: f.id, optionId: o.id, mode},
                        });
                    }
                }
            }
        }

        // Field-level utility marker validity
        for (const f of fields) {
            const util = (f.meta as any)?.utility;
            if (!util) continue;
            const mode = util.mode;
            const rate = util.rate;
            if (!isFiniteNumber(rate)) {
                errors.push({
                    code: 'utility_missing_rate',
                    nodeId: f.id,
                    details: {fieldId: f.id},
                });
            }
            if (!ALLOWED_UTILITY_MODES.has(mode)) {
                errors.push({
                    code: 'utility_invalid_mode',
                    nodeId: f.id,
                    details: {fieldId: f.id, mode},
                });
            }
        }
    }

    // within validate(), after fieldsVisibleUnder() is defined and before constraints section:

    /* ────────────────────────────────────────────────────────────────
     * 6) RATES & PRICING ROLES
     *    - utility_without_base: now per visible tag group
     *    - rate coherence across BASE options (unchanged)
     * ──────────────────────────────────────────────────────────────── */

    // A) utility_without_base per tag (visible group)
    for (const t of tags) {
        const visible = fieldsVisibleUnder(t.id);
        let hasBase = false;
        let hasUtility = false;
        const utilityOptionIds: string[] = [];

        for (const f of visible) {
            for (const o of f.options ?? []) {
                const sid = o.service_id;
                if (!isFiniteNumber(sid)) continue;
                const role = (o.pricing_role ?? f.pricing_role ?? 'base');
                if (role === 'base') hasBase = true;
                else if (role === 'utility') {
                    hasUtility = true;
                    utilityOptionIds.push(o.id);
                }
            }
        }

        if (hasUtility && !hasBase) {
            errors.push({
                code: 'utility_without_base',
                nodeId: t.id, // attach to the tag/group
                details: {utilityOptionIds}
            });
        }
    }

    // B) Per-field base-only rate coherence (kept as before)
    for (const f of fields) {
        if (!isMultiField(f)) continue;
        const baseRates = new Set<number>();
        for (const o of f.options ?? []) {
            const role = o.pricing_role ?? f.pricing_role ?? 'base';
            if (role !== 'base') continue;
            const sid = o.service_id;
            if (!isFiniteNumber(sid)) continue;
            const rate = serviceMap[sid!]?.rate;
            if (isFiniteNumber(rate)) baseRates.add(Number(rate));
        }
        if (baseRates.size > 1) {
            errors.push({code: 'rate_mismatch_across_base', nodeId: f.id});
        }
    }

    /* ────────────────────────────────────────────────────────────────
     * 7) CONSTRAINTS vs CAPABILITIES + INHERITANCE
     * ──────────────────────────────────────────────────────────────── */
    // Build ancestor chain resolver
// Inheritance contradiction (nearest ancestor wins; descendants cannot contradict)
    // effective constraint resolution (nearest ancestor wins)
    const flags: Array<keyof NonNullable<Tag['constraints']>> = ['refill', 'cancel', 'dripfeed'];

    function effectiveConstraints(tagId: string): Partial<Record<typeof flags[number], boolean>> {
        const out: Partial<Record<typeof flags[number], boolean>> = {};
        for (const key of flags) {
            // walk up until you find a defined value
            let cur: string | undefined = tagId;
            const seen = new Set<string>();
            while (cur && !seen.has(cur)) {
                seen.add(cur);
                const t = tagById.get(cur);
                const v = t?.constraints?.[key];
                if (v !== undefined) {
                    out[key] = v;
                    break;
                }
                cur = t?.bind_id;
            }
        }
        return out;
    }

    // Enforce tag constraints on visible options' services
    for (const t of tags) {
        const eff = effectiveConstraints(t.id);
        if (!FLAG_KEYS.some(k => eff[k] === true)) continue; // nothing to enforce

        const visible = fieldsVisibleUnder(t.id);
        for (const f of visible) {
            for (const o of f.options ?? []) {
                if (!isFiniteNumber(o.service_id)) continue;
                const svc = serviceMap[o.service_id];
                if (!svc) continue;

                for (const k of FLAG_KEYS) {
                    if (eff[k] === true && (svc as any)[k] === false) {
                        errors.push({
                            code: 'unsupported_constraint_option',
                            nodeId: o.id,
                            details: {tagId: t.id, flag: k, serviceId: o.service_id},
                        });
                    }
                }
            }
        }
    }

    // Unsupported constraint vs tag's mapped service capabilities
    for (const t of tags) {
        const sid = t.service_id;
        if (!isFiniteNumber(sid)) continue;
        const svc = serviceMap[Number(sid)];
        if (!svc) continue;

        const eff = effectiveConstraints(t.id); // ← use inherited constraints

        if (eff.refill === true && svc.refill === false) {
            errors.push({code: 'unsupported_constraint', nodeId: t.id, details: {flag: 'refill', serviceId: sid}});
        }
        if (eff.cancel === true && svc.cancel === false) {
            errors.push({code: 'unsupported_constraint', nodeId: t.id, details: {flag: 'cancel', serviceId: sid}});
        }
        if (eff.dripfeed === true && svc.dripfeed === false) {
            errors.push({code: 'unsupported_constraint', nodeId: t.id, details: {flag: 'dripfeed', serviceId: sid}});
        }
    }

    // src/core/validate.ts (near other constraint checks)
    for (const t of tags) {
        const ov = t.constraints_overrides;
        if (!ov) continue;
        for (const k of Object.keys(ov) as FlagKey[]) {
            const {from, to, origin} = ov[k]!;
            errors.push({
                code: 'constraint_overridden',
                nodeId: t.id,
                details: {
                    flag: k,
                    from, to,
                    origin,
                    severity: 'warning'
                },
            } as any);
        }
    }

    /* ────────────────────────────────────────────────────────────────
     * 8) CUSTOM FIELD RULES
     * ──────────────────────────────────────────────────────────────── */
    for (const f of fields) {
        if (f.type === 'custom') {
            if (!f.component || !String(f.component).trim()) {
                errors.push({code: 'custom_component_missing', nodeId: f.id});
            }
            // "unresolvable" would require a registry; not checked here
        }
    }

    // ─── Optional global guard (lint) ───────────────────────────────
    if (ctx.globalUtilityGuard) {
        let hasUtility = false;
        let hasBase = false;

        for (const f of fields) {
            for (const o of f.options ?? []) {
                if (!isFiniteNumber(o.service_id)) continue;
                const role = o.pricing_role ?? f.pricing_role ?? 'base';
                if (role === 'base') hasBase = true;
                else if (role === 'utility') hasUtility = true;
                if (hasUtility && hasBase) break;
            }
            if (hasUtility && hasBase) break;
        }

        if (hasUtility && !hasBase) {
            errors.push({
                code: 'utility_without_base',
                nodeId: 'global',                 // ← signals it’s the global lint
                details: {scope: 'global'}      // ← consumers can treat as warning
            });
        }
    }


    // ─── Unbound fields: must be bound or included somewhere ────────────────
    {
        const boundFieldIds = new Set<string>();
        for (const f of fields) {
            if (f.bind_id) boundFieldIds.add(f.id);
        }

        const includedByTag = new Set<string>();
        for (const t of tags) {
            for (const id of t.includes ?? []) includedByTag.add(id);
        }

        const includedByOption = new Set<string>();
        for (const arr of Object.values(props.includes_for_buttons ?? {})) {
            for (const id of arr ?? []) includedByOption.add(id);
        }

        for (const f of fields) {
            if (
                !boundFieldIds.has(f.id) &&
                !includedByTag.has(f.id) &&
                !includedByOption.has(f.id)
            ) {
                errors.push({code: 'field_unbound', nodeId: f.id});
            }
        }
    }

    // ── Fallback validation ────────────────────────────────────────────────
    const mode = ctx.fallbackSettings?.mode ?? 'strict';
    if (props.fallbacks) {
        const diags = collectFailedFallbacks(
            props,
            ctx.serviceMap ?? {},
            {...ctx.fallbackSettings, mode: 'dev'} // collect non-fatal diagnostics
        );

        if (mode === 'strict') {
            // Convert node-scoped violations into ValidationError; global stays soft
            for (const d of diags) {
                if (d.scope === 'global') continue;
                // Only report when the candidate failed in all of its contexts. We approximate:
                // group by (nodeId,candidate) and check if we only saw failing reasons.
                // For simplicity, we emit per-failing context; editor may prune accordingly.
                const code =
                    d.reason === 'unknown_service' ? 'fallback_unknown_service' :
                        d.reason === 'no_primary' ? 'fallback_no_primary' :
                            d.reason === 'rate_violation' ? 'fallback_rate_violation' :
                                d.reason === 'constraint_mismatch' ? 'fallback_constraint_mismatch' :
                                    d.reason === 'cycle' ? 'fallback_cycle' :
                                        'fallback_bad_node';

                errors.push({
                    code: code as any,
                    nodeId: d.nodeId,
                    details: {
                        primary: d.primary,
                        candidate: d.candidate,
                        tagContext: d.tagContext,
                        scope: d.scope,
                    },
                });
            }
        }
    }

    return errors;
}


// ───────────────────── Policy helpers ─────────────────────

type ServiceItem = {
    tagId?: string;
    fieldId: string;
    optionId: string;
    serviceId: number;
    role: 'base' | 'utility';
    // capability snapshot (if present in serviceMap)
    service?: {
        id?: number;
        key?: string;
        type?: string;
        rate?: number;
        handler_id?: number;
        platform_id?: number;
        dripfeed?: boolean;
        refill?: boolean;
        cancel?: boolean;
        [k: string]: unknown;
    };
};

function asArray<T>(v: T | T[] | undefined): T[] | undefined {
    if (v === undefined) return undefined;
    return Array.isArray(v) ? v : [v];
}

function getByPath(obj: any, path: string | undefined): unknown {
    if (!path) return undefined;
    const parts = path.split('.');
    let cur = obj;
    for (const p of parts) {
        if (cur == null) return undefined;
        cur = cur[p];
    }
    return cur;
}

/** Build a list of ServiceItems from a set of fields, filtered by role and id filters */
function collectServiceItems(
    fields: Field[],
    tagId: string | undefined,
    serviceMap: DgpServiceMap,
    filter?: DynamicRule['filter'],
): ServiceItem[] {
    const roleFilter = filter?.role ?? 'both';
    const fieldIdAllow = asArray(filter?.field_id);
    const tagIdAllow = asArray(filter?.tag_id);
    const handlerAllow = asArray(filter?.handler_id);
    const platformAllow = asArray(filter?.platform_id);

    const out: ServiceItem[] = [];

    for (const f of fields) {
        if (fieldIdAllow && !fieldIdAllow.includes(f.id)) continue;

        for (const o of f.options ?? []) {
            const sid = o.service_id;
            if (typeof sid !== 'number' || !Number.isFinite(sid)) continue;

            const role = (o.pricing_role ?? f.pricing_role ?? 'base') as 'base' | 'utility';
            if (roleFilter !== 'both' && role !== roleFilter) continue;

            const svc = serviceMap[sid];
            if (handlerAllow && (svc?.handler_id == null || !handlerAllow.includes(svc.handler_id))) continue;
            if (platformAllow && (svc?.platform_id == null || !platformAllow.includes(svc.platform_id))) continue;
            if (tagIdAllow && (!tagId || !tagIdAllow.includes(tagId))) continue;

            out.push({
                tagId,
                fieldId: f.id,
                optionId: o.id,
                serviceId: sid,
                role,
                service: svc ? {
                    id: svc.id,
                    key: svc.key as any,
                    type: (svc as any).type as any, // optional in your map
                    rate: svc.rate,
                    handler_id: (svc as any).handler_id as any,
                    platform_id: (svc as any).platform_id as any,
                    dripfeed: svc.dripfeed,
                    refill: svc.refill,
                    cancel: svc.cancel,
                    ...svc.meta,
                } : undefined,
            });
        }
    }
    return out;
}

function evalPolicyOp(op: DynamicRule['op'], values: unknown[], rule: DynamicRule): boolean {
    switch (op) {
        case 'all_equal': {
            const set = new Set(values.map(v => JSON.stringify(v)));
            return set.size <= 1;
        }
        case 'no_mix': {
            const set = new Set(values.map(v => JSON.stringify(v)));
            return set.size <= 1;
        }
        case 'unique': {
            const seen = new Set<string>();
            for (const v of values) {
                const k = JSON.stringify(v);
                if (seen.has(k)) return false;
                seen.add(k);
            }
            return true;
        }
        case 'all_true': {
            return values.every(v => v === true);
        }
        case 'any_true': {
            return values.some(v => v === true);
        }
        case 'max_count': {
            const limit = typeof rule.value === 'number' ? rule.value : Infinity;
            return values.length <= limit;
        }
        case 'min_count': {
            const min = typeof rule.value === 'number' ? rule.value : 0;
            return values.length >= min;
        }
        default:
            return true;
    }
}

function applyPolicies(
    errors: ValidationError[],
    props: ServiceProps,
    serviceMap: DgpServiceMap,
    policies: DynamicRule[] | undefined,
    fieldsVisibleUnder: (tagId: string) => Field[],
    tags: Tag[],
): void {
    if (!policies?.length) return;

    for (const rule of policies) {
        const projPath = rule.projection ?? 'service.id';

        if (rule.scope === 'global') {
            const allFields = props.fields ?? [];
            const items = collectServiceItems(allFields, undefined, serviceMap, rule.filter);
            const values = items.map(it => getByPath(it, projPath));

            if (!evalPolicyOp(rule.op, values, rule)) {
                errors.push({
                    code: 'policy_violation',
                    nodeId: 'global',
                    details: {
                        ruleId: rule.id,
                        scope: 'global',
                        severity: rule.severity ?? 'error',
                        op: rule.op,
                        projection: projPath,
                        count: items.length,
                    },
                });
            }
            continue;
        }

        // visible_group
        for (const t of tags) {
            const visibleFields = fieldsVisibleUnder(t.id);
            const items = collectServiceItems(visibleFields, t.id, serviceMap, rule.filter);
            if (!items.length) continue;

            const values = items.map(it => getByPath(it, projPath));

            if (!evalPolicyOp(rule.op, values, rule)) {
                errors.push({
                    code: 'policy_violation',
                    nodeId: t.id,
                    details: {
                        ruleId: rule.id,
                        scope: 'visible_group',
                        severity: rule.severity ?? 'error',
                        op: rule.op,
                        projection: projPath,
                        count: items.length,
                    },
                });
            }
        }
    }
}

/* ───────────────────────── helpers ───────────────────────── */

function hasAnyServiceOption(f: Field): boolean {
    return (f.options ?? []).some(o => isFiniteNumber(o.service_id));
}

function isFiniteNumber(v: unknown): v is number {
    return typeof v === 'number' && Number.isFinite(v);
}

// ─── helper: is a field bound to a given tag? ───────────────────────────────────
function isBoundTo(f: Field, tagId: string): boolean {
    const b = f.bind_id;
    if (!b) return false;
    return Array.isArray(b) ? b.includes(tagId) : b === tagId;
}
```


---
*Generated with [Prodex](https://github.com/emxhive/prodex) — Codebase decoded.*
<!-- PRODEx v1.4.11 | 2026-01-20T14:32:20.260Z -->