*Generated by [Prodex](https://github.com/emxhive/prodex#readme)*
> Note for LLMs: `Lx-Ly` ranges refer to lines in this Prodex trace file, not the original source files. Index metadata is provided via the HTML comment markers in this section.

# Index
<!-- PRODEX_INDEX_RANGE: L8-L27 -->
<!-- PRODEX_FILE_COUNT: 20 -->
<!-- PRODEX_INDEX_LIST_START -->
- [src/react/workspace/app.tsx](#1)  L31-L105
- [src/react/workspace/components/canvas.tsx](#2)  L106-L230
- [src/react/workspace/components/context-menu-renderer.tsx](#3)  L231-L390
- [src/react/workspace/components/reactflow/edge.tsx](#4)  L391-L400
- [src/react/workspace/components/reactflow/index.tsx](#5)  L401-L422
- [src/react/workspace/components/reactflow/nodes/comments.tsx](#6)  L423-L432
- [src/react/workspace/components/reactflow/nodes/field.tsx](#7)  L433-L467
- [src/react/workspace/components/reactflow/nodes/node.tsx](#8)  L468-L636
- [src/react/workspace/components/reactflow/nodes/options.tsx](#9)  L637-L655
- [src/react/workspace/components/reactflow/nodes/tags.tsx](#10)  L656-L678
- [src/react/workspace/context/backend.ts](#11)  L679-L1078
- [src/react/workspace/context/context.tsx](#12)  L1079-L1390
- [src/react/workspace/context/ctxmenu.tsx](#13)  L1391-L1689
- [src/react/workspace/context/index.tsx](#14)  L1690-L2756
- [src/react/workspace/context/memory-backend.ts](#15)  L2757-L3394
- [src/react/workspace/context/provider/context.ts](#16)  L3395-L3422
- [src/react/workspace/context/provider/helpers.ts](#17)  L3423-L3480
- [src/react/workspace/context/provider/provider.tsx](#18)  L3481-L4552
- [src/react/workspace/context/provider/types.ts](#19)  L4553-L4773
- [src/react/workspace/index.ts](#20)  L4774-L4789
<!-- PRODEX_INDEX_LIST_END -->

---
---
#### 1


` File: src/react/workspace/app.tsx`  [‚Üë Back to top](#index)

```tsx
// src/react/workspace/app.tsx
import * as React from "react";
import { WorkspaceProvider } from "./context/provider";
import type { WorkspaceProviderProps } from "./context/provider";
import type { Actor, WorkspaceBackend } from "./context/backend";
import FlowCanvas, { type ToolsConfig } from "../adapters/reactflow";
import { CanvasProvider } from "@/context/context";

/**
 * Props for the Workspace wrapper. Mirrors WorkspaceProvider options.
 */
export interface WorkspaceProps {
    readonly backend: WorkspaceBackend;
    readonly actor: Actor;

    /** Optional pre-hydration to avoid blank first paint */
    readonly initial?: WorkspaceProviderProps["initial"];

    /** Ensure a 'main' branch exists; otherwise first branch is used (default true) */
    readonly ensureMain?: WorkspaceProviderProps["ensureMain"];

    /** Live refresh mode (poll/SSE/WS/off). Defaults to off. */
    readonly live?: WorkspaceProviderProps["live"];

    /** Autosave debounce window in ms (default 9000) */
    readonly autosaveMs?: WorkspaceProviderProps["autosaveMs"];

    /** Auto-run autosave when dirty (default true) */
    readonly autoAutosave?: WorkspaceProviderProps["autoAutosave"];
    readonly tools?: ToolsConfig;
    children: (tools?: ToolsConfig) => React.ReactNode;
}

/**
 * Workspace: wraps app panels with WorkspaceProvider.
 * Accepts the same inputs as WorkspaceProvider and passes them through.
 */
export function Workspace(props: WorkspaceProps): React.JSX.Element {
    const {
        backend,
        actor,
        initial,
        ensureMain,
        live,
        autosaveMs,
        autoAutosave,
        tools,
        children,
    } = props;

    return (
        <WorkspaceProvider
            backend={backend}
            actor={actor}
            initial={initial}
            ensureMain={ensureMain}
            live={live}
            autosaveMs={autosaveMs}
            autoAutosave={autoAutosave}
        >
            <CanvasProvider>{children(tools)}</CanvasProvider>
        </WorkspaceProvider>
    );
}

export default Workspace;
```

---
#### 2


` File: src/react/workspace/components/canvas.tsx`  [‚Üë Back to top](#index)

```tsx
// src/react/adapters/reactflow/ReactFlowCanvas.tsx
import React, { useMemo, useState } from "react";
import ReactFlow, {
    Background,
    ConnectionMode,
    MiniMap,
} from "reactflow";
import "reactflow/dist/style.css";

import {
    type AdapterOptions,
    useReactFlowAdapter,
} from "../../adapters/reactflow/adapter";
import type { CanvasAPI } from "../../canvas/api";
import { Toolbar } from "../../adapters/reactflow/Toolbar";
import type { LabelPlacement, ToolsConfig } from "../../adapters/reactflow";
import { edgeTypes, nodeTypes } from "@/components/reactflow";

export type ReactFlowCanvasProps = {
    api: CanvasAPI;
    options?: AdapterOptions;

    showToolbar?: boolean;
    tools?: ToolsConfig;
    labelPlacement?: LabelPlacement;
    renderTool?: Parameters<typeof Toolbar>[0]["renderButton"];

    initialShowGrid?: boolean;
    initialShowMiniMap?: boolean;

    /** absolute position classes relative to the ReactFlow canvas */
    toolbarPositionClassName?: string; // e.g. "left-2 top-2"
};

export function Canvas({
    api,
    options,
    showToolbar = true,
    tools,
    labelPlacement = "tooltip",
    renderTool,
    initialShowGrid = true,
    initialShowMiniMap = false,
    toolbarPositionClassName = "left-2 top-2",
}: ReactFlowCanvasProps) {
    const [showGrid, setShowGrid] = useState(initialShowGrid);
    const [showMiniMap, setShowMiniMap] = useState(initialShowMiniMap);

    const {
        nodes,
        edges,
        onNodesChange,
        onEdgesChange,
        onConnect,
        onConnectStart,
        onConnectEnd,
        onMoveEnd,
        onSelectionChange,
        isValidConnection,
        snapVector,
    } = useReactFlowAdapter(api, options);

    const snapToGrid = useMemo(
        () => !!options?.snapToGrid,
        [options?.snapToGrid],
    );
    const snapGrid = useMemo<[number, number] | undefined>(
        () => snapVector,
        [snapVector],
    );

    return (
        <div className="relative h-full w-full bg-gray-50">
            <ReactFlow
                nodes={nodes}
                edges={edges}
                nodeTypes={nodeTypes}
                edgeTypes={edgeTypes}
                connectionMode={ConnectionMode.Loose}
                onNodesChange={onNodesChange}
                onEdgesChange={onEdgesChange}
                onConnectStart={onConnectStart}
                onConnectEnd={onConnectEnd}
                onConnect={onConnect}
                onMoveEnd={onMoveEnd}
                onSelectionChange={onSelectionChange}
                isValidConnection={isValidConnection}
                fitView
                snapToGrid={snapToGrid}
                snapGrid={snapGrid}
            >
                {/* toolbar inside ReactFlow so useReactFlow() works */}
                {showToolbar && (
                    <div
                        className={`pointer-events-none absolute z-10 ${toolbarPositionClassName}`}
                    >
                        <Toolbar
                            api={api}
                            mode="dev"
                            showGrid={showGrid}
                            setShowGrid={setShowGrid}
                            showMiniMap={showMiniMap}
                            setShowMiniMap={setShowMiniMap}
                            tools={tools}
                            labelPlacement={labelPlacement}
                            renderButton={renderTool}
                        />
                    </div>
                )}

                {showMiniMap && <MiniMap />}
                {showGrid && <Background />}
            </ReactFlow>
        </div>
    );
}
```

---
#### 3


` File: src/react/workspace/components/context-menu-renderer.tsx`  [‚Üë Back to top](#index)

```tsx
import type { ContextState, MenuItem } from "@/context/ContextMenuProvider";
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';

/**
 * Pure presentational menu. Mirrors Stitch spec:
 * - 8px+ padding groups with 1px separators
 * - Icons on the left, label, right-aligned hint
 * - Disabled shows muted colors + not-allowed cursor
 * - Danger shows red accents
 */
export const ContextMenuRenderer: React.FC<{
    items: MenuItem[];
    ctx: ContextState;
    onClose: () => void;
    onAction: (item: MenuItem, e: MouseEvent | KeyboardEvent) => void;
}> = ({ items, ctx, onClose, onAction }) => {
    const rootRef = useRef<HTMLDivElement | null>(null);
    const [focusIdx, setFocusIdx] = useState<number>(() => nextFocusable(items, ctx, -1));

    const flat = useMemo(
        () => items, // simple 1-level for now; submenus can extend this
        [items],
    );

    const isDisabled = useCallback((it: MenuItem) => (typeof it.disabled === 'function' ? it.disabled(ctx) : !!it.disabled), [ctx]);

    const handleActivate = useCallback(
        (it: MenuItem, e: MouseEvent | KeyboardEvent) => {
            if (isDisabled(it) || it.divider || !it.onSelect) return;
            onAction(it, e);
            onClose();
        },
        [isDisabled, onClose, onAction],
    );

    // Keyboard support
    useEffect(() => {
        const onKey = (e: KeyboardEvent) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                onClose();
                return;
            }
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                setFocusIdx((i) => nextFocusable(flat, ctx, i));
                return;
            }
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                setFocusIdx((i) => prevFocusable(flat, ctx, i));
                return;
            }
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                const it = flat[focusIdx];
                if (it) handleActivate(it, e);
            }
        };
        document.addEventListener('keydown', onKey, true);
        return () => document.removeEventListener('keydown', onKey, true);
    }, [flat, ctx, focusIdx, handleActivate, onClose]);

    return (
        <div
            ref={rootRef}
            className="w-64 min-w-max rounded-lg border border-slate-200/80 bg-white shadow-xl shadow-slate-950/5 backdrop-blur-sm dark:border-slate-800 dark:bg-slate-900"
            role="menu"
            aria-orientation="vertical"
        >
            <div className="flex flex-col gap-0.5 p-1.5">
                {flat.map((it, idx) => {
                    if (it.divider) {
                        return <hr key={`div-${idx}`} className="my-1.5 border-t border-slate-200 dark:border-slate-800" aria-hidden />;
                    }

                    const disabled = isDisabled(it);
                    const danger = !!it.danger;
                    const focused = idx === focusIdx;

                    return (
                        <button
                            key={it.key ?? idx}
                            type="button"
                            role="menuitem"
                            aria-disabled={disabled || undefined}
                            onMouseEnter={() => setFocusIdx(idx)}
                            onClick={(e) => {
                                e.preventDefault();
                                if (disabled) return;
                                handleActivate(it, e.nativeEvent);
                            }}
                            className={[
                                'flex min-h-10 w-full items-center justify-between gap-3 rounded-md px-3 text-sm font-medium',
                                disabled
                                    ? 'cursor-not-allowed text-slate-400 dark:text-slate-600'
                                    : danger
                                      ? 'text-red-600 hover:bg-red-50 hover:text-red-700 dark:text-red-400 dark:hover:bg-red-950/30 dark:hover:text-red-300'
                                      : focused
                                        ? 'bg-primary/10 text-slate-900 dark:text-slate-100'
                                        : 'text-slate-700 hover:bg-primary/10 dark:text-slate-300',
                            ].join(' ')}
                        >
                            <span className="flex items-center gap-3">
                                {it.icon ?? null}
                                <span className="truncate">{it.label}</span>
                            </span>
                            {it.hint ? <span className="text-xs text-slate-400 dark:text-slate-500">{it.hint}</span> : <span />}
                        </button>
                    );
                })}
            </div>
        </div>
    );
};

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

function nextFocusable(items: MenuItem[], ctx: ContextState, from: number): number {
    for (let i = from + 1; i < items.length; i++) {
        const it = items[i];
        if (it.divider) continue;
        const disabled = typeof it.disabled === 'function' ? it.disabled(ctx) : !!it.disabled;
        if (!disabled) return i;
    }
    // wrap
    for (let i = 0; i <= from && i < items.length; i++) {
        const it = items[i];
        if (it.divider) continue;
        const disabled = typeof it.disabled === 'function' ? it.disabled(ctx) : !!it.disabled;
        if (!disabled) return i;
    }
    return Math.max(0, Math.min(items.length - 1, from));
}

function prevFocusable(items: MenuItem[], ctx: ContextState, from: number): number {
    for (let i = from - 1; i >= 0; i--) {
        const it = items[i];
        if (it.divider) continue;
        const disabled = typeof it.disabled === 'function' ? it.disabled(ctx) : !!it.disabled;
        if (!disabled) return i;
    }
    // wrap
    for (let i = items.length - 1; i >= from && i >= 0; i--) {
        const it = items[i];
        if (it.divider) continue;
        const disabled = typeof it.disabled === 'function' ? it.disabled(ctx) : !!it.disabled;
        if (!disabled) return i;
    }
    return Math.max(0, Math.min(items.length - 1, from));
}
```

---
#### 4


` File: src/react/workspace/components/reactflow/edge.tsx`  [‚Üë Back to top](#index)

```tsx

```

---
#### 5


` File: src/react/workspace/components/reactflow/index.tsx`  [‚Üë Back to top](#index)

```tsx
import Tag from "@/components/reactflow/nodes/tags";
import Field from "@/components/reactflow/nodes/field";
import Options from "@/components/reactflow/nodes/options";

const nodeTypes = {
    tag: Tag,
    field: Field,
    option: Options,
};

const edgeTypes = {};

export { nodeTypes, edgeTypes };
```

---
#### 6


` File: src/react/workspace/components/reactflow/nodes/comments.tsx`  [‚Üë Back to top](#index)

```tsx

```

---
#### 7


` File: src/react/workspace/components/reactflow/nodes/field.tsx`  [‚Üë Back to top](#index)

```tsx
import Node from "@/components/reactflow/nodes/node";
import React from "react";
import { FlowNode } from "../../../../../schema/graph";

const Field: React.FC<FlowNode> = (props) => {
    const {
        id,
        data: {
            node: { label },
        },
    } = props;
    return (
        <Node label={label} id={id} type={"field"}>
            {(label, icon) => {
                return (
                    <span className="flex gap-2 items-center">
                        {icon}
                        {label}
                    </span>
                );
            }}
        </Node>
    );
};

export default Field;
```

---
#### 8


` File: src/react/workspace/components/reactflow/nodes/node.tsx`  [‚Üë Back to top](#index)

```tsx
import React, { ReactNode, useEffect, useRef } from "react";
import { cn } from "@/lib/utils";
import { LiaTagsSolid } from "react-icons/lia";
import { RxInput } from "react-icons/rx";
import { TbHandClick } from "react-icons/tb";
import { LuTextSelect } from "react-icons/lu";
import { TfiComments } from "react-icons/tfi";
import { useCanvasAPI } from "@/context/context";
import { Handle, Position } from "reactflow";

interface Errors {
    title?: string;
    description: string;
    meta?: Record<string, unknown>;
}
interface NodeProps {
    children?: (
        label: ReactNode,
        icon: ReactNode,
        errors?: Errors[],
    ) => React.ReactNode;
    description?: string;
    label: string;
    id: string;
    type: "tag" | "field" | "option" | "button" | "comment";
    errors?: Errors[];
    meta?: Record<string, unknown>;
}

function getIcon(
    type: NodeProps["type"],
): React.FC<React.SVGProps<SVGSVGElement>> {
    switch (type) {
        case "tag":
            return LiaTagsSolid;
        case "field":
            return RxInput;
        case "option":
            return LuTextSelect;
        case "button":
            return TbHandClick;
        case "comment":
            return TfiComments;
    }
}
const Node: React.FC<NodeProps> = ({
    children,
    label,
    errors,
    id,
    type,
    description,
}) => {
    const labelRef = useRef<HTMLDivElement>(null);
    const descRef = useRef<HTMLDivElement>(null);
    const { editor } = useCanvasAPI();

    useEffect(() => {
        if (labelRef.current && labelRef.current.innerText !== label) {
            labelRef.current.innerText = label;
        }
        if (
            descRef.current &&
            descRef.current.innerText !== (description ?? "")
        ) {
            descRef.current.innerText = description ?? "";
        }
    }, [label, description]);
    const Icon = getIcon(type);
    const Label = (
        <div
            contentEditable
            suppressContentEditableWarning
            tabIndex={0} // make it focusable
            onPointerDown={(e) => e.stopPropagation()}
            onMouseDown={(e) => e.stopPropagation()}
            onContextMenu={(e) => {
                e.preventDefault(); // prevent default context menu
                labelRef.current?.focus(); // focus the editable div
            }}
            onDoubleClick={(e) => {
                e.stopPropagation();
                labelRef.current?.focus();
            }}
            onBlur={() => {
                const newText = labelRef.current?.innerText.trim() || "";
                if (newText && newText !== label) {
                    editor.reLabel(id, newText);
                }
            }}
            className="text-[12px] outline-none w-full cursor-text text-center"
        >
            {label}
        </div>
    );
    return (
        <div
            className={cn(
                "px-4 items-center gap-2 relative min-h-[40px] flex h-fit bg-card ring ring-grey-100 rounded-md shadow text-card-foreground font-black",
            )}
        >
            {children ? (
                children(Label, <Icon />, errors)
            ) : (
                <span className={"flex gap-2 items-center"}>
                    <Icon /> {Label}
                </span>
            )}

            <Handle
                id="mid-top"
                type="target"
                position={Position.Top}
                style={{
                    top: 0,
                    left: "50%",
                    transform: "translate(-50%, -50%)",
                    zIndex: 10,
                }}
            />
            <Handle
                id="mid-top"
                type="source"
                position={Position.Top}
                style={{
                    top: 0,
                    left: "50%",
                    transform: "translate(-50%, -50%)",
                    zIndex: 10,
                }}
            />

            {/* mid-bottom: target + source */}
            <Handle
                id="mid-bottom"
                type="target"
                position={Position.Bottom}
                style={{
                    bottom: 0,
                    left: "50%",
                    transform: "translate(-50%, 50%)",
                    zIndex: 10,
                }}
            />
            <Handle
                id="mid-bottom"
                type="source"
                position={Position.Bottom}
                style={{
                    bottom: 0,
                    left: "50%",
                    transform: "translate(-50%, 50%)",
                    zIndex: 10,
                }}
            />
        </div>
    );
};

export default Node;
```

---
#### 9


` File: src/react/workspace/components/reactflow/nodes/options.tsx`  [‚Üë Back to top](#index)

```tsx
import Node from "@/components/reactflow/nodes/node";
import { NodeProps } from "reactflow";
import { GraphNode } from "../../../../../schema/graph";
import React from "react";

const Options: React.FC<NodeProps<GraphNode>> = ({ id, data: { label } }) => {
    return <Node label={label} id={id} type={"option"} />;
};

export default Options;
```

---
#### 10


` File: src/react/workspace/components/reactflow/nodes/tags.tsx`  [‚Üë Back to top](#index)

```tsx
import Node from "@/components/reactflow/nodes/node";
import React from "react";
import type { FlowNode } from "../../../../../schema/graph";

const Tag: React.FC<FlowNode> = ({
    id,
    data: {
        node: { label },
    },
}) => {
    return <Node type={"tag"} label={label} id={id} />;
};

export default Tag;
```

---
#### 11


` File: src/react/workspace/context/backend.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/backend.ts
// Transport-agnostic contracts for the Workspace layer.
// Explicit types only (no implicit any). Result shape: { ok, value | error }.

import type { EditorSnapshot } from "@/schema/editor";
import type { DgpServiceCapability, DgpServiceMap } from "@/schema/provider";

/* ---------------- core result & identity ---------------- */

export interface BackendError {
    readonly code: string;
    readonly message: string;
    readonly status?: number;
    readonly hint?: string;
    readonly cause?: unknown;
}

export type BackendResult<T> =
    | { ok: true; value: T }
    | { ok: false; error: BackendError };

export type Result<T> = Promise<BackendResult<T>>;

export interface Actor {
    readonly id: string;
    readonly name?: string;
    readonly roles?: readonly string[];
    readonly meta?: Readonly<Record<string, unknown>>;
}

/* ---------------- common entities ---------------- */

export interface Author {
    readonly id: string;
    readonly name: string;
    readonly handle?: string;
    readonly avatarUrl?: string;
    readonly meta?: Readonly<Record<string, unknown>>;
    readonly createdAt?: string;
    readonly updatedAt?: string;
}

export type PermissionsMap = Readonly<Record<string, boolean>>;

export interface Branch {
    readonly id: string;
    readonly name: string;
    readonly isMain: boolean;
    readonly headVersionId?: string;
    readonly createdAt: string;
    readonly updatedAt: string;
}

export interface MergeResult {
    readonly sourceId: string;
    readonly targetId: string;
    readonly conflicts?: number;
    readonly message?: string;
}

/* ---------------- services ---------------- */

export type ServicesInput = readonly DgpServiceCapability[] | DgpServiceMap;

export interface ServicesBackend {
    get(workspaceId: string): Result<ServicesInput>;
    refresh(
        workspaceId: string,
        params?: Readonly<{ since?: number | string }>,
    ): Result<ServicesInput>;
}

/* ---------------- branch access / participants ---------------- */

export interface BranchParticipant {
    readonly id: string;
    readonly workspaceId: string;
    readonly branchId: string;

    /** points into Authors directory */
    readonly authorId: string;

    /** roles are intentionally loose; host decides taxonomy */
    readonly roles?: readonly string[];

    readonly canRead: boolean;
    readonly canWrite: boolean;

    readonly meta?: Readonly<Record<string, unknown>>;
    readonly createdAt?: string;
    readonly updatedAt?: string;
}

export interface BranchAccessBackend {
    listParticipants(
        workspaceId: string,
        branchId: string,
    ): Result<readonly BranchParticipant[]>;
    refreshParticipants(
        workspaceId: string,
        branchId: string,
        params?: Readonly<{ since?: number | string }>,
    ): Result<readonly BranchParticipant[]>;
}

/* ---------------- snapshots (editor state) ---------------- */

export interface ServiceSnapshot {
    readonly schema_version: string;
    readonly data: EditorSnapshot;
    readonly meta?: Readonly<Record<string, unknown>>;
}

export interface Draft {
    readonly id: string;
    readonly branchId: string;
    readonly status: "uncommitted";
    readonly etag?: string;
    readonly meta?: Readonly<Record<string, unknown>>;
    readonly createdAt: string;
    readonly updatedAt: string;
}

export interface Commit {
    readonly id: string;
    readonly branchId: string;
    readonly message?: string;
    readonly versionId?: string;
    readonly etag?: string;
    readonly createdAt: string;
}

export interface SnapshotsLoadResult {
    readonly head?: Commit;
    readonly draft?: Draft;
    readonly snapshot: ServiceSnapshot;
}

export interface SnapshotsBackend {
    load(
        params: Readonly<{
            workspaceId: string;
            branchId: string;
            actorId: string;
            versionId?: string;
        }>,
    ): Result<SnapshotsLoadResult>;
    autosave(
        params: Readonly<{
            workspaceId: string;
            branchId: string;
            actorId: string;
            snapshot: ServiceSnapshot;
            clientId?: string;
            since?: number | string;
            etag?: string;
        }>,
    ): Result<Readonly<{ draft: Draft }>>;
    save(
        params: Readonly<{
            workspaceId: string;
            branchId: string;
            actorId: string;
            snapshot: ServiceSnapshot;
            message?: string;
            draftId?: string;
            etag?: string;
        }>,
    ): Result<Readonly<{ commit: Commit }>>;
    publish(
        params: Readonly<{
            workspaceId: string;
            actorId: string;
            draftId: string;
            message?: string;
        }>,
    ): Result<Readonly<{ commit: Commit }>>;
    discard(
        params: Readonly<{
            workspaceId: string;
            actorId: string;
            draftId: string;
        }>,
    ): Result<void>;
    refresh(
        params: Readonly<{
            workspaceId: string;
            branchId: string;
            actorId: string;
            since?: number | string;
        }>,
    ): Result<Readonly<{ head?: Commit; draft?: Draft }>>;
}

/* ---------------- templates (replacing "assets") ---------------- */

export interface TemplateValidator {
    readonly type: string; // e.g., "required" | "regex" | "min" | "max" | custom code
    readonly rule?: unknown; // params for the validator
    readonly message?: string;
}

export interface FieldTemplate {
    readonly id: string;
    /** Unique key (per workspace, optionally per branch) used to reference this template */
    readonly key: string;
    readonly name: string;
    /** logical kind e.g. "text", "number", "date", "select", "relation", ... */
    readonly kind: string;

    /** Optional branch scoping (can be global if undefined) */
    readonly branchId?: string;

    /** Canonical, builder-consumable definition (shape up to your app) */
    readonly definition: Readonly<Record<string, unknown>>;

    /** Default values the editor may inject when using this template */
    readonly defaults?: Readonly<Record<string, unknown>>;

    /** UI metadata (icons, color, sizing, render hints, etc.) */
    readonly ui?: Readonly<Record<string, unknown>>;

    /** Client- or server-side validators */
    readonly validators?: readonly TemplateValidator[];

    readonly tags?: readonly string[];
    readonly category?: string;

    /** Published templates are selectable by default in the editor palette */
    readonly published: boolean;

    /** Incremented on every update */
    readonly version: number;

    readonly createdAt: string;
    readonly updatedAt: string;
}

/** Narrow list/search input */
export interface TemplatesListParams {
    readonly workspaceId: string;
    readonly branchId?: string;
    readonly q?: string;
    readonly tags?: readonly string[];
    readonly category?: string;
    readonly since?: string | number;
}

export interface TemplateCreateInput {
    readonly key?: string; // if omitted, backend generates a unique one
    readonly name: string;
    readonly kind: string;
    readonly branchId?: string;
    readonly definition: Readonly<Record<string, unknown>>;
    readonly defaults?: Readonly<Record<string, unknown>>;
    readonly ui?: Readonly<Record<string, unknown>>;
    readonly validators?: readonly TemplateValidator[];
    readonly tags?: readonly string[];
    readonly category?: string;
    readonly published?: boolean;
}

export interface TemplateUpdatePatch {
    readonly name?: string;
    readonly kind?: string;
    readonly branchId?: string | null;
    readonly definition?: Readonly<Record<string, unknown>>;
    readonly defaults?: Readonly<Record<string, unknown>> | null;
    readonly ui?: Readonly<Record<string, unknown>> | null;
    readonly validators?: readonly TemplateValidator[] | null;
    readonly tags?: readonly string[] | null;
    readonly category?: string | null;
    readonly published?: boolean;
}

export interface TemplatesBackend {
    list(params: TemplatesListParams): Result<readonly FieldTemplate[]>;
    get(id: string): Result<FieldTemplate | null>;
    getByKey(
        workspaceId: string,
        key: string,
        branchId?: string,
    ): Result<FieldTemplate | null>;
    create(
        workspaceId: string,
        input: TemplateCreateInput,
    ): Result<FieldTemplate>;
    update(id: string, patch: TemplateUpdatePatch): Result<FieldTemplate>;
    clone(
        source: Readonly<{ id?: string; key?: string }>,
        opts?: Readonly<{
            newKey?: string;
            name?: string;
            branchId?: string;
            asDraft?: boolean;
        }>,
    ): Result<FieldTemplate>;
    publish(id: string): Result<FieldTemplate>;
    unpublish(id: string): Result<FieldTemplate>;
    delete(id: string): Result<void>;
    refresh(
        params: Omit<TemplatesListParams, "q" | "tags" | "category">,
    ): Result<readonly FieldTemplate[]>;
}

/* ---------------- live channel ---------------- */

export type WorkspaceEvent =
    | { type: "authors.updated"; since?: number | string }
    | { type: "permissions.updated" }
    | { type: "services.updated"; since?: number | string }
    | {
          type: "branch.participants.updated";
          branchId: string;
          since?: number | string;
      }
    | { type: "branch.created"; branch: Branch }
    | { type: "branch.deleted"; branchId: string }
    | { type: "branch.setMain"; branchId: string }
    | { type: "branch.merged"; sourceId: string; targetId: string }
    | { type: "template.created"; template: FieldTemplate }
    | { type: "template.updated"; template: FieldTemplate }
    | { type: "template.deleted"; templateId: string }
    | { type: "snapshot.autosaved"; branchId: string; draft: Draft }
    | { type: "snapshot.saved"; branchId: string; commit: Commit }
    | { type: "snapshot.published"; branchId: string; commit: Commit }
    | { type: "snapshot.discarded"; branchId: string };

export type LiveOptions =
    | { mode: "off" }
    | { mode: "poll"; intervalMs?: number }
    | { mode: "sse"; url: string; headers?: Readonly<Record<string, string>> }
    | { mode: "ws"; url: string; protocols?: readonly string[] };

/* ---------------- authors / permissions / branches ---------------- */

export interface AuthorsBackend {
    list(workspaceId: string): Result<readonly Author[]>;
    get(authorId: string): Result<Author | null>;
    refresh(workspaceId: string): Result<readonly Author[]>;
}

export interface PermissionsBackend {
    get(workspaceId: string, actor: Actor): Result<PermissionsMap>;
    refresh(workspaceId: string, actor: Actor): Result<PermissionsMap>;
}

export interface BranchesBackend {
    list(workspaceId: string): Result<readonly Branch[]>;
    create(
        workspaceId: string,
        name: string,
        opts?: Readonly<{ fromId?: string }>,
    ): Result<Branch>;
    setMain(workspaceId: string, branchId: string): Result<Branch>;
    merge(
        workspaceId: string,
        sourceId: string,
        targetId: string,
    ): Result<MergeResult>;
    delete(workspaceId: string, branchId: string): Result<void>;
    refresh(workspaceId: string): Result<readonly Branch[]>;
}

/* ---------------- workspace backend root ---------------- */

export interface WorkspaceInfo {
    readonly id: string;
    readonly name: string;
    readonly description?: string;
    readonly createdAt: string;
    readonly updatedAt: string;
    readonly meta?: Readonly<Record<string, unknown>>;
}

export interface WorkspaceBackend {
    readonly info: WorkspaceInfo;

    readonly authors: AuthorsBackend;
    readonly permissions: PermissionsBackend;
    readonly branches: BranchesBackend;

    /** branch-scoped access control / participants */
    readonly access: BranchAccessBackend;

    /** first-class services channel */
    readonly services: ServicesBackend;

    readonly templates: TemplatesBackend;
    readonly snapshots: SnapshotsBackend;
}
```

---
#### 12


` File: src/react/workspace/context/context.tsx`  [‚Üë Back to top](#index)

```tsx
import React, {
    createContext,
    useContext,
    useEffect,
    useMemo,
    useRef,
    type ReactNode,
} from "react";
import { CanvasAPI } from "../../canvas/api";
import { Builder, BuilderOptions, createBuilder } from "../../../core";
import type { CanvasOptions } from "../../../schema/canvas-types";
import type { CanvasBackendOptions } from "../../canvas/backend";
import type { ServiceProps } from "../../../schema";
import { useWorkspaceMaybe } from ".";

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ context ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

const Ctx = createContext<CanvasAPI | null>(null);

/** Managed props (back-compat): host provides the API instance. */
type CanvasProviderManagedProps = { api: CanvasAPI; children: ReactNode };

/** Workspace-aware props: host omits `api`, we attach to Workspace on demand. */
type CanvasProviderWorkspaceProps = {
    children: ReactNode;
    /** Optional Builder options (e.g., historyLimit, serviceMap if you already have one). */
    builderOpts?: BuilderOptions;
    /** Canvas view/backend options for CanvasAPI ctor. */
    canvasOpts?: CanvasOptions & CanvasBackendOptions;
    /** If false, we won‚Äôt attempt to read Workspace; will throw if no api is provided. */
    attachToWorkspace?: boolean; // default true
};

type CanvasProviderProps =
    | CanvasProviderManagedProps
    | CanvasProviderWorkspaceProps;

/**
 * CanvasProvider
 * - Managed mode (existing): <CanvasProvider api={api}>{...}</CanvasProvider>
 * - Workspace-aware mode (new): if no `api` and inside a Workspace, auto-create Builder+CanvasAPI and load snapshot props.
 */
export function CanvasProvider(props: CanvasProviderProps) {
    // Managed mode: unchanged behavior
    if ("api" in props) {
        return <Ctx.Provider value={props.api}>{props.children}</Ctx.Provider>;
    }

    // Workspace-aware mode
    const {
        children,
        builderOpts,
        canvasOpts,
        attachToWorkspace = true,
    } = props;

    const ws = useWorkspaceMaybe();

    if (!attachToWorkspace || !ws) {
        throw new Error(
            "CanvasProvider: no `api` provided and no Workspace context available. " +
                "Either pass an `api` prop or render within <WorkspaceProvider>.",
        );
    }

    // üîπ NEW: if snapshot props aren‚Äôt loaded yet, trigger a one-time load
    const triedInitialLoadRef = useRef<boolean>(false);
    useEffect(() => {
        const hasProps = Boolean(ws.snapshot.data?.props);
        if (!hasProps && !triedInitialLoadRef.current) {
            triedInitialLoadRef.current = true;
            void ws.snapshot.load().then((res) => {
                // dev-only noise; stay silent in prod
                if (
                    typeof window !== "undefined" &&
                    // @ts-expect-error allow host env guard
                    window.SITE?.env !== "production"
                ) {
                    if (!res.ok) {
                        // eslint-disable-next-line no-console
                        console.warn(
                            "[CanvasProvider] snapshot.load() failed:",
                            res.error?.code ?? "load_error",
                            res.error?.message ?? "(no message)",
                        );
                    }
                }
            });
        }
    }, [ws]);

    // Pull initial ServiceProps from current editor snapshot (if present)
    const initialProps: ServiceProps | undefined = ws.snapshot.data?.props as
        | ServiceProps
        | undefined;

    // If the Workspace exposes services as a map, we can forward it to builderOpts.
    // (We avoid any normalization here; arrays are ignored by design.)
    const resolvedBuilderOpts: BuilderOptions | undefined = useMemo(() => {
        const svc = ws.services.data as unknown;
        const hasMap =
            svc != null &&
            typeof svc === "object" &&
            !Array.isArray(svc as unknown[]);
        return hasMap
            ? {
                  ...(builderOpts ?? {}),
                  serviceMap: svc as BuilderOptions["serviceMap"],
              }
            : builderOpts;
    }, [builderOpts, ws.services.data]);

    const { api } = useCanvasOwned(
        initialProps,
        canvasOpts,
        resolvedBuilderOpts,
    );

    return <Ctx.Provider value={api}>{children}</Ctx.Provider>;
}

export function useCanvasAPI(): CanvasAPI {
    const api = useContext(Ctx);
    if (!api)
        throw new Error("useCanvasAPI must be used within <CanvasProvider>");
    return api;
}

/**
 * Create & memoize a CanvasAPI from a Builder.
 * - Disposes the previous API when builder changes.
 * - Accepts both view/state options and backend options.
 * - Warns (DEV only) if `opts` identity is changing every render.
 */
export function useCanvasFromBuilder(
    builder: Builder,
    opts?: CanvasOptions & CanvasBackendOptions,
): CanvasAPI {
    // Warn (DEV) if the raw opts reference is churning each render
    useDevWarnOnOptsChurn(opts);

    // Stabilize opts content to avoid churn-driven re-instantiation
    const lastOptsRef = useRef<
        (CanvasOptions & CanvasBackendOptions) | undefined
    >(undefined);
    const stableOpts =
        opts &&
        lastOptsRef.current &&
        shallowEqualOpts(lastOptsRef.current, opts)
            ? lastOptsRef.current
            : (lastOptsRef.current = opts);

    const api = useMemo(
        () => new CanvasAPI(builder, stableOpts),
        [builder, stableOpts],
    );

    useEffect(() => {
        return () => {
            // Clean up listeners / timers when API instance is replaced or unmounted
            api.dispose?.();
        };
    }, [api]);

    return api;
}

/**
 * Use an existing CanvasAPI instance without creating/disposing anything.
 * Useful when the host fully manages the API lifecycle (e.g., from a parent).
 */
export function useCanvasFromExisting(api: CanvasAPI): CanvasAPI {
    // No disposal here‚Äîthe host owns the instance
    return api;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

function shallowEqualOpts(
    a?: CanvasOptions & CanvasBackendOptions,
    b?: CanvasOptions & CanvasBackendOptions,
) {
    if (a === b) return true;
    if (!a || !b) return false;
    const aKeys = Object.keys(a) as (keyof (CanvasOptions &
        CanvasBackendOptions))[];
    const bKeys = Object.keys(b) as (keyof (CanvasOptions &
        CanvasBackendOptions))[];
    if (aKeys.length !== bKeys.length) return false;
    for (const k of aKeys) {
        if ((a as any)[k] !== (b as any)[k]) return false;
    }
    return true;
}

/** DEV-only: warn if opts identity changes on most renders (suggests wrapping in useMemo). */
function useDevWarnOnOptsChurn(opts?: CanvasOptions & CanvasBackendOptions) {
    const rawRef = useRef<typeof opts>(undefined);
    const churnCountRef = useRef(0);
    const lastWindowStartRef = useRef<number>(Date.now());
    const warnedRef = useRef(false);

    useEffect(() => {
        // @ts-ignore
        if (window.SITE?.env === "production") return;
        const now = Date.now();

        // Reset window every 2s
        if (now - lastWindowStartRef.current > 2000) {
            lastWindowStartRef.current = now;
            churnCountRef.current = 0;
        }

        if (rawRef.current !== opts) {
            churnCountRef.current += 1;
            rawRef.current = opts;
        }

        // If we see churn on most renders in the window, warn once.
        if (!warnedRef.current && churnCountRef.current >= 5) {
            warnedRef.current = true;
            // eslint-disable-next-line no-console
            console.warn(
                "[digital-service-ui-builder] useCanvasFromBuilder: `opts` is changing identity frequently. " +
                    "Wrap your options in useMemo to avoid unnecessary API re-instantiation.",
            );
        }
    });
}

type UseCanvasOwnedReturn = { api: CanvasAPI; builder: Builder };

/** Creates a Builder once, loads initial props, and owns the CanvasAPI lifecycle. */
export function useCanvasOwned(
    initialProps?: ServiceProps,
    canvasOpts?: CanvasOptions & CanvasBackendOptions,
    builderOpts?: BuilderOptions, // ‚Üê pass builder params here
): UseCanvasOwnedReturn {
    // 1) Create the builder ONCE with the provided builder options
    const builderRef = useRef<Builder>();
    const builderOptsRef = useRef<BuilderOptions | undefined>(builderOpts);
    const loadedOnceRef = useRef<boolean>(false);

    if (!builderRef.current) {
        builderRef.current = createBuilder(builderOptsRef.current); // ‚Üê forwarded
        if (initialProps) {
            builderRef.current.load(initialProps);
            loadedOnceRef.current = true;
        }
        // @ts-ignore
    } else if (window.SITE?.env !== "production") {
        // Warn if builderOpts identity changes after first mount (they won't be applied)
        if (builderOptsRef.current !== builderOpts) {
            // eslint-disable-next-line no-console
            console.warn(
                "[useCanvasOwned] builderOpts changed after init; new values are ignored. " +
                    "If you need to recreate the builder, remount the hook (e.g. change a React key).",
            );
            builderOptsRef.current = builderOpts;
        }
    }
    const builder = builderRef.current!;

    // If initial props arrive later (async Workspace load), load them once.
    useEffect(() => {
        if (!loadedOnceRef.current && initialProps) {
            builderRef.current!.load(initialProps);
            loadedOnceRef.current = true;
        }
    }, [initialProps]);

    // 2) Stabilize canvas options to avoid churn re-instantiation of CanvasAPI
    const lastCanvasOptsRef = useRef<typeof canvasOpts>();
    const stableCanvasOpts = useMemo(() => {
        if (!lastCanvasOptsRef.current) {
            lastCanvasOptsRef.current = canvasOpts;
            return canvasOpts;
        }
        const a = canvasOpts ?? {};
        const b = lastCanvasOptsRef.current ?? {};
        const same = Object.keys({ ...a, ...b }).every(
            (k) => (a as any)[k] === (b as any)[k],
        );
        if (same) return lastCanvasOptsRef.current;
        lastCanvasOptsRef.current = canvasOpts;
        return canvasOpts;
    }, [canvasOpts]);

    // 3) Create CanvasAPI and dispose on change/unmount
    const api = useMemo(
        () => new CanvasAPI(builder, stableCanvasOpts),
        [builder, stableCanvasOpts],
    );

    useEffect(
        () => () => {
            api.dispose?.();
        },
        [api],
    );

    return { api, builder };
}
```

---
#### 13


` File: src/react/workspace/context/ctxmenu.tsx`  [‚Üë Back to top](#index)

```tsx
import { ContextMenuRenderer } from "@/react/workspace/components/context-menu-renderer";
import React, {
    createContext,
    useCallback,
    useContext,
    useEffect,
    useLayoutEffect,
    useMemo,
    useRef,
    useState,
} from "react";
import { createPortal } from "react-dom";
import { CanvasAPI } from "@/react";

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Types ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

export type ContextScope =
    | "file"
    | "folder"
    | "library"
    | "empty"
    | (string & {});

export type ContextState = CtxWithAttach;

// Allow attaching UI-scoped helpers (e.g., Sidebar startAdd)
type CtxWithAttach = CanvasAPI;
export interface MenuItem {
    key?: React.Key;
    label?: string;
    icon?: React.ReactNode;
    hint?: string;
    divider?: boolean;
    danger?: boolean;
    disabled?: boolean | ((ctx: CtxWithAttach) => boolean);
    onSelect?: (args: {
        ctx: CtxWithAttach;
        nativeEvent: MouseEvent | KeyboardEvent;
    }) => void | Promise<void>;
    children?: MenuItem[];
}

interface InternalState {
    open: boolean;
    x: number;
    y: number;
    items: MenuItem[];
    ariaLabel?: string;
    ctx: CtxWithAttach;
}

export type MenuBuilder =
    | MenuItem[]
    | ((opts: {
          ctx: ContextState;
          nativeEvent?: MouseEvent;
      }) => MenuItem[] | Promise<MenuItem[]>);

export interface OpenOptions {
    /** A11y label for the menu. */
    ariaLabel?: string;
    /** Context state used by disabled predicates & callbacks. */
    ctx?: ContextState;
    /** If you already have precise coords, pass them. Otherwise we‚Äôll use the event‚Äôs clientX/Y. */
    coords?: { x: number; y: number };
    /** Native event (if any). */
    nativeEvent?: MouseEvent;
}

export interface ContextMenuApi {
    openAt: (
        evOrCoords: MouseEvent | { x: number; y: number },
        items: MenuBuilder,
        options?: OpenOptions,
    ) => void;
    close: () => void;
    /** Ergonomic helper for `onContextMenu={cm.bind(() => items, { ctx: ... })}` */
    bind: (
        builder: (ev: React.MouseEvent) => MenuBuilder | Promise<MenuBuilder>,
        options?: Omit<OpenOptions, "nativeEvent" | "coords">,
    ) => (ev: React.MouseEvent) => void;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Context ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

const Ctx = createContext<ContextMenuApi | null>(null);

export const useContextMenu = (): ContextMenuApi => {
    const api = useContext(Ctx);
    if (!api) {
        throw new Error(
            "useContextMenu() must be used under <ContextMenuProvider>.",
        );
    }
    return api;
};

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Provider ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

export const Ctxmenu: React.FC<{
    children: React.ReactNode;
    zIndex?: number;
}> = ({
    children,
    zIndex = 60, // sits above most app chrome; tweak if needed
}) => {
    const containerRef = useRef<HTMLDivElement | null>(null);

    const [state, setState] = useState<InternalState>({
        open: false,
        x: 0,
        y: 0,
        items: [],
        ariaLabel: "Context menu",
        //@ts-expect-error
        ctx: {},
    });

    const [measured, setMeasured] = useState<{ w: number; h: number }>({
        w: 0,
        h: 0,
    });

    // Close on outside click / ESC
    useEffect(() => {
        if (!state.open) return;

        const onDown = (e: MouseEvent) => {
            const el = containerRef.current;
            if (el && !el.contains(e.target as Node)) {
                setState((s) => ({ ...s, open: false }));
            }
        };
        const onKey = (e: KeyboardEvent) => {
            if (e.key === "Escape") {
                setState((s) => ({ ...s, open: false }));
            }
        };

        document.addEventListener("mousedown", onDown, true);
        document.addEventListener("keydown", onKey, true);
        return () => {
            document.removeEventListener("mousedown", onDown, true);
            document.removeEventListener("keydown", onKey, true);
        };
    }, [state.open]);

    // Clamp menu within viewport after render
    useLayoutEffect(() => {
        if (!state.open) return;
        const el = containerRef.current;
        if (!el) return;

        const rect = el.getBoundingClientRect();
        if (rect.width !== measured.w || rect.height !== measured.h) {
            setMeasured({ w: rect.width, h: rect.height });
        }

        const margin = 8;
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        let nx = state.x;
        let ny = state.y;

        if (nx + rect.width + margin > vw)
            nx = Math.max(margin, vw - rect.width - margin);
        if (ny + rect.height + margin > vh)
            ny = Math.max(margin, vh - rect.height - margin);

        if (nx !== state.x || ny !== state.y) {
            setState((s) => ({ ...s, x: nx, y: ny }));
        }
    }, [state.open, state.x, state.y, measured.w, measured.h]);

    const resolveItems = useCallback(
        async (items: MenuBuilder, opts: OpenOptions): Promise<MenuItem[]> => {
            let raw: MenuItem[] | Promise<MenuItem[]>;
            if (typeof items === "function") {
                raw = items({
                    //@ts-expect-error
                    ctx: opts.ctx ?? {},
                    nativeEvent: opts.nativeEvent,
                });
            } else {
                raw = items;
            }
            const resolved = await raw;
            return Array.isArray(resolved) ? resolved : [];
        },
        [],
    );

    const openAt = useCallback<ContextMenuApi["openAt"]>(
        async (evOrCoords, items, options) => {
            const nativeEvent =
                "x" in evOrCoords
                    ? options?.nativeEvent
                    : (evOrCoords as MouseEvent);
            const coords =
                "x" in evOrCoords
                    ? evOrCoords
                    : {
                          x: (evOrCoords as MouseEvent).clientX,
                          y: (evOrCoords as MouseEvent).clientY,
                      };

            if (
                !("x" in evOrCoords) &&
                (evOrCoords as MouseEvent).preventDefault
            ) {
                (evOrCoords as MouseEvent).preventDefault();
            }

            const resolved = await resolveItems(items, {
                ...(options ?? {}),
                nativeEvent,
            });
            setState({
                open: true,
                x: coords.x,
                y: coords.y,
                items: resolved,
                ariaLabel: options?.ariaLabel ?? "Context menu",
                //@ts-expect-error
                ctx: options?.ctx ?? {},
            });
        },
        [resolveItems],
    );

    const close = useCallback(
        () => setState((s) => ({ ...s, open: false })),
        [],
    );

    const bind = useCallback<ContextMenuApi["bind"]>(
        (builder, options) => {
            return (ev: React.MouseEvent) => {
                ev.preventDefault();
                const native: MouseEvent = ev.nativeEvent;
                const maybePromise = builder(ev);
                Promise.resolve(maybePromise).then((items) => {
                    openAt(
                        { x: native.clientX, y: native.clientY },
                        // If builder returned a function or array, pass through; openAt will resolve again safely.
                        typeof items === "function" || Array.isArray(items)
                            ? (items as MenuBuilder)
                            : [],
                        { ...(options ?? {}), nativeEvent: native },
                    );
                });
            };
        },
        [openAt],
    );

    const api = useMemo<ContextMenuApi>(
        () => ({ openAt, close, bind }),
        [openAt, close, bind],
    );

    return (
        <Ctx.Provider value={api}>
            {children}
            {state.open &&
                createPortal(
                    <div
                        ref={containerRef}
                        className="fixed z-[9999]"
                        style={{ left: state.x, top: state.y, zIndex }}
                        role="dialog"
                        aria-label={state.ariaLabel}
                    >
                        <ContextMenuRenderer
                            items={state.items}
                            ctx={state.ctx}
                            onClose={close}
                            onAction={(it, e) =>
                                it.onSelect?.({
                                    ctx: state.ctx,
                                    nativeEvent: e,
                                })
                            }
                        />
                    </div>,
                    document.body,
                )}
        </Ctx.Provider>
    );
};
```

---
#### 14


` File: src/react/workspace/context/index.tsx`  [‚Üë Back to top](#index)

```tsx
// src/react/workspace/context/index.tsx
// React provider/hook for Workspace data with Field Templates (replaces "assets").
// Includes authors, permissions, branches, templates, and snapshots (autosave drafts).
// noinspection JSDeprecatedSymbols

import * as React from "react";
import {
    Actor,
    Author,
    BackendError,
    Branch,
    Commit,
    Draft,
    FieldTemplate,
    LiveOptions,
    MergeResult,
    PermissionsMap,
    Result,
    ServiceSnapshot,
    SnapshotsLoadResult,
    TemplatesListParams,
    TemplateCreateInput,
    TemplateUpdatePatch,
    WorkspaceBackend,
    WorkspaceInfo,
} from "./backend";
import type { EditorSnapshot } from "../../../schema/editor";
import type {
    DgpServiceCapability,
    DgpServiceMap,
} from "../../../schema/provider";
import { useContext } from "react";

/* ---------------- small helpers ---------------- */

interface Loadable<T> {
    readonly data: T | null;
    readonly loading: boolean;
    readonly error?: BackendError;
    readonly updatedAt?: number;
}

export type SnapshotState = "clean" | "dirty" | "uncommitted" | "saving";

type RunOk = { ok: true };
type RunErr = { ok: false; errors: BackendError[] };
type RunResult = RunOk | RunErr;

// Stable default ‚Äî avoids a new object per render
const LIVE_OFF: LiveOptions = Object.freeze({ mode: "off" as const });

function toBackendError(e: unknown): BackendError {
    if (
        typeof e === "object" &&
        e &&
        "code" in (e as any) &&
        "message" in (e as any)
    ) {
        return e as BackendError;
    }
    return { code: "unknown_error", message: String(e ?? "Unknown error") };
}

async function runTasks(
    tasks: Array<() => Promise<unknown>>,
    tolerant: boolean,
): Promise<RunResult> {
    const errors: BackendError[] = [];
    for (const t of tasks) {
        try {
            await t();
        } catch (e) {
            if (!tolerant) throw e;
            errors.push(toBackendError(e));
        }
    }
    return errors.length ? { ok: false, errors } : { ok: true };
}

/* ---------------- provider props & slices ---------------- */

export interface WorkspaceProviderProps {
    readonly backend: WorkspaceBackend;
    readonly actor: Actor;
    readonly initial?: Partial<{
        authors: readonly Author[];
        permissions: PermissionsMap;
        branches: readonly Branch[];
        mainId: string;
        templates: readonly FieldTemplate[];
        snapshot: ServiceSnapshot;
        head?: Commit;
        draft?: Draft;
        currentBranchId?: string;
        services?: readonly DgpServiceCapability[] | DgpServiceMap;
    }>;
    readonly ensureMain?: boolean;
    readonly live?: LiveOptions;
    readonly autosaveMs?: number; // default 9000
    readonly autoAutosave?: boolean; // default true
    readonly children: React.ReactNode;
}

interface BranchesSlice {
    readonly data: readonly Branch[];
    readonly mainId?: string;
    readonly currentId?: string;
    readonly loading: boolean;
    readonly error?: BackendError;
    readonly updatedAt?: number;
}

interface SnapshotSlice {
    readonly schemaVersion?: string;
    readonly data?: EditorSnapshot;
    readonly head?: Commit;
    readonly draft?: Draft;
    readonly state: SnapshotState;
    readonly saving: boolean;
    readonly dirty: boolean;
    readonly lastSavedAt?: number;
    readonly lastDraftAt?: number;
}

/* ---------------- public API ---------------- */

interface WorkspaceAPI {
    readonly info: WorkspaceInfo;
    readonly actor: Actor;

    readonly authors: Loadable<readonly Author[]>;
    readonly permissions: Loadable<PermissionsMap>;
    readonly branches: BranchesSlice;
    readonly templates: Loadable<readonly FieldTemplate[]>;
    readonly services: Loadable<DgpServiceMap>;

    readonly refresh: {
        all(opts?: { strict?: boolean }): Promise<RunResult>;
        authors(): Promise<void>;
        permissions(): Promise<void>;
        branches(): Promise<void>;
        templates(
            params?: Partial<Pick<TemplatesListParams, "branchId" | "since">>,
        ): Promise<void>;
        services(): Promise<void>;
    };

    readonly setCurrentBranch: (id: string) => void;
    readonly createBranch: (
        name: string,
        opts?: Readonly<{ fromId?: string }>,
    ) => Result<Branch>;
    readonly setMain: (branchId: string) => Result<Branch>;
    readonly mergeBranch: (
        sourceId: string,
        targetId: string,
    ) => Result<MergeResult>;
    readonly deleteBranch: (branchId: string) => Result<void>;

    // Template ops
    readonly createTemplate: (
        input: TemplateCreateInput,
    ) => Result<FieldTemplate>;
    readonly updateTemplate: (
        id: string,
        patch: TemplateUpdatePatch,
    ) => Result<FieldTemplate>;
    readonly cloneTemplate: (
        source: Readonly<{ id?: string; key?: string }>,
        opts?: Readonly<{
            newKey?: string;
            name?: string;
            branchId?: string;
            asDraft?: boolean;
        }>,
    ) => Result<FieldTemplate>;
    readonly publishTemplate: (id: string) => Result<FieldTemplate>;
    readonly unpublishTemplate: (id: string) => Result<FieldTemplate>;
    readonly deleteTemplate: (id: string) => Result<void>;

    readonly invalidate: (
        keys?: Array<
            "authors" | "permissions" | "branches" | "templates" | "services"
        >,
    ) => void;

    readonly live: {
        readonly connected: boolean;
        readonly lastEventAt?: number;
        connect(): void;
        disconnect(): void;
    };

    readonly snapshot: {
        readonly state: SnapshotState;
        readonly saving: boolean;
        readonly dirty: boolean;
        readonly head?: Commit;
        readonly draft?: Draft;
        readonly schemaVersion?: string;
        readonly data?: EditorSnapshot;
        readonly lastSavedAt?: number;
        readonly lastDraftAt?: number;

        set(
            updater: (curr: EditorSnapshot | undefined) => EditorSnapshot,
        ): void;
        load(
            params?: Readonly<{ versionId?: string }>,
        ): Result<SnapshotsLoadResult>;
        refresh(): Promise<void>;
        autosave(): Result<Readonly<{ draft: Draft }>>;
        save(message?: string): Result<Readonly<{ commit: Commit }>>;
        publish(message?: string): Result<Readonly<{ commit: Commit }>>;
        discardDraft(): Result<void>;
    };
}

/* ---------------- context & hook ---------------- */

const WorkspaceContext = React.createContext<WorkspaceAPI | null>(null);

export function useWorkspace(): WorkspaceAPI {
    const ctx = React.useContext(WorkspaceContext);
    if (!ctx)
        throw new Error(
            "useWorkspace() must be used under <WorkspaceProvider/>",
        );
    return ctx as WorkspaceAPI;
}

export function useWorkspaceMaybe(): WorkspaceAPI | null {
    return useContext(WorkspaceContext);
}

/* ---------------- provider ---------------- */

export function WorkspaceProvider(props: WorkspaceProviderProps): JSX.Element {
    const {
        backend,
        actor,
        initial,
        ensureMain = true,
        live: liveProp,
        autosaveMs = 9000,
        autoAutosave = true,
        children,
    } = props;

    const workspaceId = backend.info.id;

    const live = liveProp ?? LIVE_OFF;

    const [authors, setAuthors] = React.useState<Loadable<readonly Author[]>>({
        data: initial?.authors ?? null,
        loading: false,
        updatedAt: initial?.authors ? Date.now() : undefined,
    });

    const [permissions, setPermissions] = React.useState<
        Loadable<PermissionsMap>
    >({
        data: initial?.permissions ?? null,
        loading: false,
        updatedAt: initial?.permissions ? Date.now() : undefined,
    });

    const [branches, setBranches] = React.useState<BranchesSlice>({
        data: initial?.branches ?? [],
        mainId: initial?.mainId,
        currentId: initial?.currentBranchId ?? initial?.mainId,
        loading: false,
        updatedAt: initial?.branches ? Date.now() : undefined,
    });

    const [templates, setTemplates] = React.useState<
        Loadable<readonly FieldTemplate[]>
    >({
        data: initial?.templates ?? null,
        loading: false,
        updatedAt: initial?.templates ? Date.now() : undefined,
    });

    function toServiceMap(
        input?: readonly DgpServiceCapability[] | DgpServiceMap | null,
    ): DgpServiceMap | null {
        if (!input) return null;
        if (Array.isArray(input)) {
            const map: DgpServiceMap = {} as any;
            for (const s of input) map[s.id] = s;
            return map;
        }
        return input as DgpServiceMap;
    }

    const initialServices = toServiceMap(
        initial?.services ?? backend.services ?? null,
    );
    const [services, setServices] = React.useState<Loadable<DgpServiceMap>>({
        data: initialServices,
        loading: false,
        updatedAt: initialServices ? Date.now() : undefined,
    });

    const [snapshot, setSnapshot] = React.useState<SnapshotSlice>({
        schemaVersion: initial?.snapshot?.schema_version,
        data: initial?.snapshot?.data as EditorSnapshot | undefined,
        head: initial?.head,
        draft: initial?.draft,
        state: initial?.draft ? "uncommitted" : "clean",
        saving: false,
        dirty: false,
    });

    const autosaveTimerRef = React.useRef<number | null>(null);
    const now = () => Date.now();

    function setError<T>(
        updater: React.Dispatch<React.SetStateAction<Loadable<T>>>,
        error: BackendError,
    ) {
        updater((s) => ({ ...s, loading: false, error }));
    }

    /* -------- ensure main branch -------- */
    React.useEffect(() => {
        if (!ensureMain) return;
        if (branches.data.length === 0) return;
        const existingMain = branches.data.find((b) => b.isMain)?.id;
        if (existingMain && branches.mainId !== existingMain) {
            setBranches((s) => ({
                ...s,
                mainId: existingMain,
                currentId: s.currentId ?? existingMain,
            }));
        } else if (!existingMain) {
            const first = branches.data[0]?.id;
            if (first && !branches.currentId) {
                setBranches((s) => ({ ...s, currentId: first }));
            }
        }
    }, [branches.data, branches.mainId, branches.currentId, ensureMain]);

    /* ---------------- refreshers ---------------- */

    const refreshAuthors = React.useCallback(async () => {
        setAuthors((s) => ({ ...s, loading: true }));
        const res = await backend.authors.refresh(workspaceId);
        if (res.ok)
            setAuthors({ data: res.value, loading: false, updatedAt: now() });
        else setError(setAuthors, res.error);
    }, [backend.authors, workspaceId]);

    const refreshPermissions = React.useCallback(async () => {
        setPermissions((s) => ({ ...s, loading: true }));
        const res = await backend.permissions.refresh(workspaceId, actor);
        if (res.ok)
            setPermissions({
                data: res.value,
                loading: false,
                updatedAt: now(),
            });
        else setError(setPermissions, res.error);
    }, [backend.permissions, workspaceId, actor]);

    const refreshBranches = React.useCallback(async () => {
        setBranches((s) => ({ ...s, loading: true }));
        const res = await backend.branches.refresh(workspaceId);
        if (res.ok) {
            const data = res.value;
            const main = data.find((b) => b.isMain)?.id;
            setBranches((s) => ({
                data,
                mainId: main ?? s.mainId,
                currentId: s.currentId ?? main ?? data[0]?.id,
                loading: false,
                updatedAt: now(),
            }));
        } else {
            setBranches((s) => ({ ...s, loading: false, error: res.error }));
        }
    }, [backend.branches, workspaceId]);

    const refreshTemplates = React.useCallback(
        async (
            params?: Partial<Pick<TemplatesListParams, "branchId" | "since">>,
        ) => {
            setTemplates((s) => ({ ...s, loading: true }));
            const res = await backend.templates.refresh({
                workspaceId,
                branchId: params?.branchId ?? branches.currentId,
                since: params?.since ?? templates.updatedAt,
            });
            if (res.ok)
                setTemplates({
                    data: res.value,
                    loading: false,
                    updatedAt: now(),
                });
            else setError(setTemplates, res.error);
        },
        [
            backend.templates,
            workspaceId,
            branches.currentId,
            templates.updatedAt,
        ],
    );

    const refreshServices = React.useCallback(async () => {
        setServices((s) => ({ ...s, loading: true }));
        const map = toServiceMap(backend.services ?? null);
        if (map) setServices({ data: map, loading: false, updatedAt: now() });
        else setServices((s) => ({ ...s, loading: false }));
    }, [backend.services]);

    const refreshAll = React.useCallback(
        async (opts?: { strict?: boolean }) =>
            runTasks(
                [
                    () => refreshAuthors(),
                    () => refreshPermissions(),
                    () => refreshBranches(),
                    () => refreshTemplates(),
                    () => refreshServices(),
                ],
                /* tolerant */ !(opts?.strict ?? false),
            ),
        [
            refreshAuthors,
            refreshPermissions,
            refreshBranches,
            refreshTemplates,
            refreshServices,
        ],
    );

    /* ---------------- snapshot ops ---------------- */

    const loadSnapshot = React.useCallback(
        async (
            params?: Readonly<{ versionId?: string }>,
        ): Result<SnapshotsLoadResult> => {
            const branchId = branches.currentId;
            if (!branchId)
                return {
                    ok: false,
                    error: {
                        code: "no_branch",
                        message: "No current branch to load snapshot from.",
                    },
                } as const;
            const res = await backend.snapshots.load({
                workspaceId,
                branchId,
                versionId: params?.versionId,
            });
            if (res.ok) {
                const { head, draft, snapshot: snap } = res.value;
                setSnapshot({
                    schemaVersion: snap.schema_version,
                    data: snap.data,
                    head,
                    draft,
                    state: draft ? "uncommitted" : "clean",
                    saving: false,
                    dirty: false,
                    lastSavedAt: undefined,
                    lastDraftAt: undefined,
                });
            }
            return res;
        },
        [backend.snapshots, workspaceId, branches.currentId],
    );

    const setSnapshotData = React.useCallback(
        (updater: (curr: EditorSnapshot | undefined) => EditorSnapshot) => {
            setSnapshot((s) => ({
                ...s,
                data: updater(s.data),
                state: s.draft ? "uncommitted" : "dirty",
                dirty: true,
            }));
        },
        [],
    );

    const doAutosave = React.useCallback(async () => {
        const branchId = branches.currentId;
        if (!branchId)
            return {
                ok: false,
                error: {
                    code: "no_branch",
                    message: "No current branch to autosave.",
                },
            } as const;
        if (!snapshot.data || !snapshot.schemaVersion)
            return {
                ok: false,
                error: { code: "no_snapshot", message: "Nothing to autosave." },
            } as const;

        const res = await backend.snapshots.autosave({
            workspaceId,
            branchId,
            snapshot: {
                schema_version: snapshot.schemaVersion,
                data: snapshot.data,
            },
            etag: snapshot.draft?.etag,
        });
        if (res.ok) {
            setSnapshot((s) => ({
                ...s,
                draft: res.value.draft,
                state: "uncommitted",
                dirty: false,
                lastDraftAt: now(),
            }));
        }
        return res;
    }, [
        backend.snapshots,
        workspaceId,
        branches.currentId,
        snapshot.data,
        snapshot.schemaVersion,
        snapshot.draft?.etag,
    ]);

    const doSave = React.useCallback(
        async (message?: string) => {
            const branchId = branches.currentId;
            if (!branchId)
                return {
                    ok: false,
                    error: {
                        code: "no_branch",
                        message: "No current branch to save.",
                    },
                } as const;
            if (!snapshot.data || !snapshot.schemaVersion)
                return {
                    ok: false,
                    error: { code: "no_snapshot", message: "Nothing to save." },
                } as const;

            setSnapshot((s) => ({ ...s, state: "saving", saving: true }));
            const res = await backend.snapshots.save({
                workspaceId,
                branchId,
                snapshot: {
                    schema_version: snapshot.schemaVersion,
                    data: snapshot.data,
                },
                message,
                draftId: snapshot.draft?.id,
                etag: snapshot.head?.etag,
            });
            if (res.ok) {
                const commit = res.value.commit;
                setSnapshot((s) => ({
                    ...s,
                    head: commit,
                    draft: undefined,
                    state: "clean",
                    saving: false,
                    dirty: false,
                    lastSavedAt: now(),
                }));
            } else {
                setSnapshot((s) => ({
                    ...s,
                    state: s.draft ? "uncommitted" : "dirty",
                    saving: false,
                }));
            }
            return res;
        },
        [
            backend.snapshots,
            workspaceId,
            branches.currentId,
            snapshot.data,
            snapshot.schemaVersion,
            snapshot.draft?.id,
            snapshot.head?.etag,
        ],
    );

    const doPublish = React.useCallback(
        async (message?: string) => {
            const draftId = snapshot.draft?.id;
            if (!draftId) return doSave(message);
            const res = await backend.snapshots.publish({
                workspaceId,
                draftId,
                message,
            });
            if (res.ok) {
                const commit = res.value.commit;
                setSnapshot((s) => ({
                    ...s,
                    head: commit,
                    draft: undefined,
                    state: "clean",
                    saving: false,
                    dirty: false,
                    lastSavedAt: now(),
                }));
            }
            return res;
        },
        [backend.snapshots, workspaceId, snapshot.draft?.id, doSave],
    );

    const discardDraft = React.useCallback(async () => {
        const draftId = snapshot.draft?.id;
        if (!draftId) return { ok: true, value: undefined } as const;
        const res = await backend.snapshots.discard({ workspaceId, draftId });
        if (res.ok)
            setSnapshot((s) => ({
                ...s,
                draft: undefined,
                state: s.dirty ? "dirty" : "clean",
            }));
        return res;
    }, [backend.snapshots, workspaceId, snapshot.draft?.id, snapshot.dirty]);

    const refreshSnapshotPointers = React.useCallback(async () => {
        const branchId = branches.currentId;
        if (!branchId) return;
        const res = await backend.snapshots.refresh({
            workspaceId,
            branchId,
            since: snapshot.lastSavedAt ?? snapshot.lastDraftAt,
        });
        if (res.ok) {
            setSnapshot((s) => ({
                ...s,
                head: res.value.head ?? s.head,
                draft: res.value.draft,
                state: res.value.draft
                    ? "uncommitted"
                    : s.dirty
                      ? "dirty"
                      : "clean",
            }));
        }
    }, [
        backend.snapshots,
        workspaceId,
        branches.currentId,
        snapshot.lastSavedAt,
        snapshot.lastDraftAt,
    ]);

    // Keep latest refresh functions in refs so the effect doesn't depend on their identities
    const refreshBranchesRef = React.useRef(refreshBranches);
    const refreshTemplatesRef = React.useRef(refreshTemplates);
    const refreshSnapshotPointersRef = React.useRef(refreshSnapshotPointers);

    React.useEffect(() => {
        refreshBranchesRef.current = refreshBranches;
    }, [refreshBranches]);
    React.useEffect(() => {
        refreshTemplatesRef.current = refreshTemplates;
    }, [refreshTemplates]);
    React.useEffect(() => {
        refreshSnapshotPointersRef.current = refreshSnapshotPointers;
    }, [refreshSnapshotPointers]);

    // Stable primitives for the effect
    const pollsMs: number =
        live.mode === "poll" ? (live.intervalMs ?? 15000) : 0;
    const liveKey: string = `${live.mode}:${pollsMs}`;
    const workspaceKey: string = workspaceId; // if you prefer, include branch too

    // Consider anything loaded as "data present"
    const hasAnyData: boolean = Boolean(
        (authors.data && authors.data.length) ||
            (branches.data && branches.data.length) ||
            (templates.data && templates.data.length) ||
            snapshot.data?.props,
    );

    /* ---------------- autosave effect ---------------- */
    React.useEffect(() => {
        if (!autoAutosave || !snapshot.dirty) return;
        if (autosaveTimerRef.current) {
            window.clearTimeout(autosaveTimerRef.current);
            autosaveTimerRef.current = null;
        }
        autosaveTimerRef.current = window.setTimeout(() => {
            void doAutosave();
            autosaveTimerRef.current = null;
        }, autosaveMs) as unknown as number;

        return () => {
            if (autosaveTimerRef.current) {
                window.clearTimeout(autosaveTimerRef.current);
                autosaveTimerRef.current = null;
            }
        };
    }, [snapshot.dirty, autosaveMs, autoAutosave, doAutosave]);

    /* ---------------- live (poll baseline) ---------------- */
    const [liveState, setLiveState] = React.useState<{
        connected: boolean;
        lastEventAt?: number;
    }>({ connected: false });

    React.useEffect(() => {
        // OFF ‚Üí one-shot bootstrap if nothing is loaded yet
        if (live.mode === "off") {
            if (!hasAnyData) {
                void (async () => {
                    await runTasks(
                        [
                            () => refreshBranchesRef.current(),
                            () => refreshTemplatesRef.current(),
                            () => refreshSnapshotPointersRef.current(),
                        ],
                        true,
                    );
                })();
            }
            return; // no interval when off
        }

        // POLL ‚Üí set up a stable interval; use refs for refresh functions
        if (live.mode === "poll") {
            setLiveState((s) => ({ ...s, connected: true }));

            const tick = async () => {
                await runTasks(
                    [
                        () => refreshBranchesRef.current(),
                        () => refreshTemplatesRef.current(),
                        () => refreshSnapshotPointersRef.current(),
                    ],
                    true,
                );
                setLiveState({ connected: true, lastEventAt: Date.now() });
            };

            const id = window.setInterval(tick, pollsMs) as unknown as number;
            void tick();

            return () => {
                window.clearInterval(id);
                setLiveState({ connected: false });
            };
        }

        // Future: SSE/WS branch here
    }, [
        // Only stable deps here ‚Äî do NOT include the refresh functions themselves
        workspaceKey,
        liveKey,
        hasAnyData,
    ]);

    /* ---------------- branch ops ---------------- */

    const setCurrentBranch = React.useCallback(
        (id: string) => {
            setBranches((s) => ({ ...s, currentId: id }));
            void loadSnapshot();
        },
        [loadSnapshot],
    );

    const createBranch = React.useCallback<WorkspaceAPI["createBranch"]>(
        async (name, opts) => {
            const res = await backend.branches.create(workspaceId, name, opts);
            if (res.ok) {
                await refreshBranches();
                setCurrentBranch(res.value.id);
            }
            return res;
        },
        [backend.branches, workspaceId, refreshBranches, setCurrentBranch],
    );

    const setMain = React.useCallback<WorkspaceAPI["setMain"]>(
        async (branchId) => {
            const res = await backend.branches.setMain(workspaceId, branchId);
            if (res.ok) await refreshBranches();
            return res;
        },
        [backend.branches, workspaceId, refreshBranches],
    );

    const mergeBranch = React.useCallback<WorkspaceAPI["mergeBranch"]>(
        async (sourceId, targetId) => {
            const res = await backend.branches.merge(
                workspaceId,
                sourceId,
                targetId,
            );
            if (res.ok)
                await runTasks(
                    [() => refreshBranches(), () => refreshSnapshotPointers()],
                    true,
                );
            return res;
        },
        [
            backend.branches,
            workspaceId,
            refreshBranches,
            refreshSnapshotPointers,
        ],
    );

    const deleteBranch = React.useCallback<WorkspaceAPI["deleteBranch"]>(
        async (branchId) => {
            const res = await backend.branches.delete(workspaceId, branchId);
            if (res.ok) {
                await refreshBranches();
                if (branches.currentId === branchId) {
                    const fallback = branches.data.find(
                        (b) => b.id !== branchId,
                    )?.id;
                    if (fallback) setCurrentBranch(fallback);
                }
            }
            return res;
        },
        [
            backend.branches,
            workspaceId,
            refreshBranches,
            branches.currentId,
            branches.data,
            setCurrentBranch,
        ],
    );

    /* ---------------- template ops ---------------- */

    const createTemplate = React.useCallback<WorkspaceAPI["createTemplate"]>(
        async (input) => {
            const res = await backend.templates.create(workspaceId, {
                ...input,
                branchId: input.branchId ?? branches.currentId,
            });
            if (res.ok)
                await refreshTemplates({
                    branchId: res.value.branchId ?? branches.currentId,
                });
            return res;
        },
        [backend.templates, workspaceId, branches.currentId, refreshTemplates],
    );

    const updateTemplate = React.useCallback<WorkspaceAPI["updateTemplate"]>(
        async (id, patch) => {
            const res = await backend.templates.update(id, patch);
            if (res.ok)
                await refreshTemplates({
                    branchId: res.value.branchId ?? branches.currentId,
                });
            return res;
        },
        [backend.templates, branches.currentId, refreshTemplates],
    );

    const cloneTemplate = React.useCallback<WorkspaceAPI["cloneTemplate"]>(
        async (source, opts) => {
            const res = await backend.templates.clone(
                source,
                opts ?? { branchId: branches.currentId ?? undefined },
            );
            if (res.ok)
                await refreshTemplates({
                    branchId: res.value.branchId ?? branches.currentId,
                });
            return res;
        },
        [backend.templates, branches.currentId, refreshTemplates],
    );

    const publishTemplate = React.useCallback<WorkspaceAPI["publishTemplate"]>(
        async (id) => {
            const res = await backend.templates.publish(id);
            if (res.ok)
                await refreshTemplates({
                    branchId: res.value.branchId ?? branches.currentId,
                });
            return res;
        },
        [backend.templates, branches.currentId, refreshTemplates],
    );

    const unpublishTemplate = React.useCallback<
        WorkspaceAPI["unpublishTemplate"]
    >(
        async (id) => {
            const res = await backend.templates.unpublish(id);
            if (res.ok)
                await refreshTemplates({
                    branchId: res.value.branchId ?? branches.currentId,
                });
            return res;
        },
        [backend.templates, branches.currentId, refreshTemplates],
    );

    const deleteTemplate = React.useCallback<WorkspaceAPI["deleteTemplate"]>(
        async (id) => {
            const res = await backend.templates.delete(id);
            if (res.ok)
                await refreshTemplates({ branchId: branches.currentId });
            return res;
        },
        [backend.templates, branches.currentId, refreshTemplates],
    );

    /* ---------------- cache invalidation ---------------- */

    const invalidate = React.useCallback<WorkspaceAPI["invalidate"]>((keys) => {
        const setAll = !keys || keys.length === 0;
        if (setAll || keys.includes("authors"))
            setAuthors((s) => ({ ...s, updatedAt: undefined }));
        if (setAll || keys.includes("permissions"))
            setPermissions((s) => ({ ...s, updatedAt: undefined }));
        if (setAll || keys.includes("branches"))
            setBranches((s) => ({ ...s, updatedAt: undefined }));
        if (setAll || keys.includes("templates"))
            setTemplates((s) => ({ ...s, updatedAt: undefined }));
        if (setAll || keys.includes("services"))
            setServices((s) => ({ ...s, updatedAt: undefined }));
    }, []);

    /* ---------------- initial load ---------------- */
    React.useEffect(() => {
        if (initial?.snapshot) return;
        void loadSnapshot();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [branches.currentId]);

    /* ---------------- memo API ---------------- */

    const api: WorkspaceAPI = React.useMemo(
        () => ({
            info: backend.info,
            actor,
            authors,
            permissions,
            branches,
            templates,
            services,
            refresh: {
                all: refreshAll,
                authors: refreshAuthors,
                permissions: refreshPermissions,
                branches: refreshBranches,
                templates: refreshTemplates,
                services: refreshServices,
            },
            setCurrentBranch,
            createBranch,
            setMain,
            mergeBranch,
            deleteBranch,
            createTemplate,
            updateTemplate,
            cloneTemplate,
            publishTemplate,
            unpublishTemplate,
            deleteTemplate,
            invalidate,
            live: {
                connected: liveState.connected,
                lastEventAt: liveState.lastEventAt,
                connect: () => {
                    /* re-render provider with live prop for SSE/WS */
                },
                disconnect: () => {
                    /* re-render with live={{mode:"off"}} */
                },
            },
            snapshot: {
                state: snapshot.state,
                saving: snapshot.saving,
                dirty: snapshot.dirty,
                head: snapshot.head,
                draft: snapshot.draft,
                schemaVersion: snapshot.schemaVersion,
                data: snapshot.data,
                lastSavedAt: snapshot.lastSavedAt,
                lastDraftAt: snapshot.lastDraftAt,
                set: setSnapshotData,
                load: loadSnapshot,
                refresh: refreshSnapshotPointers,
                autosave: doAutosave,
                save: doSave,
                publish: doPublish,
                discardDraft: discardDraft,
            },
        }),
        [
            workspaceId,
            actor,
            authors,
            permissions,
            branches,
            templates,
            services,
            refreshAll,
            refreshAuthors,
            refreshPermissions,
            refreshBranches,
            refreshTemplates,
            refreshServices,
            setCurrentBranch,
            createBranch,
            setMain,
            mergeBranch,
            deleteBranch,
            createTemplate,
            updateTemplate,
            cloneTemplate,
            publishTemplate,
            unpublishTemplate,
            deleteTemplate,
            invalidate,
            liveState.connected,
            liveState.lastEventAt,
            snapshot.state,
            snapshot.saving,
            snapshot.dirty,
            snapshot.head,
            snapshot.draft,
            snapshot.schemaVersion,
            snapshot.data,
            snapshot.lastSavedAt,
            snapshot.lastDraftAt,
            setSnapshotData,
            loadSnapshot,
            refreshSnapshotPointers,
            doAutosave,
            doSave,
            doPublish,
            discardDraft,
        ],
    );

    return (
        <WorkspaceContext.Provider value={api}>
            {children}
        </WorkspaceContext.Provider>
    );
}
```

---
#### 15


` File: src/react/workspace/context/memory-backend.ts`  [‚Üë Back to top](#index)

```ts
//@ts-nocheck
// src/react/workspace/memory-backend.ts
// In-memory WorkspaceBackend with Field Templates (plus a deprecated assets shim).
// noinspection JSConstantReassignment,JSDeprecatedSymbols

import type {
    Actor,
    Author,
    BackendError,
    Branch,
    BranchesBackend,
    Commit,
    Draft,
    FieldTemplate,
    MergeResult,
    PermissionsMap,
    Result,
    ServiceSnapshot,
    SnapshotsBackend,
    SnapshotsLoadResult,
    TemplateCreateInput,
    TemplateUpdatePatch,
    TemplatesBackend,
    TemplatesListParams,
    WorkspaceBackend,
} from "./backend";
import type { EditorSnapshot } from "../../../schema/editor";
import type { DgpServiceCapability, DgpServiceMap } from "../../../schema/provider";

/* ---------------- utilities ---------------- */

type Id = string;
const nowIso = () => new Date().toISOString();
const ok = <T>(value: T): { ok: true; value: T } => ({ ok: true, value });
const err = (
    code: string,
    message: string,
    hint?: string,
): { ok: false; error: BackendError } => ({
    ok: false,
    error: { code, message, hint },
});

function clone<T>(v: T): T {
    if (Array.isArray(v)) return v.slice() as unknown as T;
    if (typeof v === "object" && v !== null) return { ...(v as object) } as T;
    return v;
}
const genId = (p: string, i: number): Id => `${p}-${i}`;

/* ---------------- seed & store ---------------- */

export interface MemorySeed {
    workspaceId: string;
    authors?: Author[];
    permissionsForActor?: (ctx: {
        workspaceId: string;
        actor: Actor;
    }) => PermissionsMap;
    branchNames?: string[]; // default ["main"]
    initialSnapshot?: ServiceSnapshot;
    initialHeadMessage?: string;
    initialDraft?: boolean;
    services?: readonly DgpServiceCapability[] | DgpServiceMap;

    /** Pre-seed field templates */
    templates?: ReadonlyArray<
        Pick<
            FieldTemplate,
            | "key"
            | "name"
            | "kind"
            | "definition"
            | "defaults"
            | "ui"
            | "validators"
            | "tags"
            | "category"
            | "published"
        > & { branchId?: string }
    >;
}

interface Store {
    readonly workspaceId: string;
    authors: Author[];
    permissionsForActor: (actor: Actor) => PermissionsMap;

    branches: Branch[];
    mainId: string;

    templates: FieldTemplate[];

    snapshot: ServiceSnapshot;
    head?: Commit;
    draft?: Draft;

    counters: { id: number; version: number; template: number };
}

/* ---------------- factory ---------------- */

export function createMemoryWorkspaceBackend(seed: MemorySeed): WorkspaceBackend {
    const wsId = seed.workspaceId;
    let idCounter = 1;
    let versionCounter = 1;
    let templateCounter = 1;

    // branches
    const names = seed.branchNames?.length ? seed.branchNames : ["main"];
    const branches: Branch[] = names.map(
        (name): Branch => ({
            id: genId("branch", idCounter++),
            name,
            isMain: false,
            createdAt: nowIso(),
            updatedAt: nowIso(),
        }),
    );
    const mainIdx = Math.max(
        0,
        branches.findIndex((b) => b.name.toLowerCase() === "main"),
    );
    branches.forEach((b, i) => (b.isMain = i === (mainIdx >= 0 ? mainIdx : 0)));
    const mainId = branches.find((b) => b.isMain)!.id;

    // authors / permissions
    const authors = seed.authors ?? [];
    const perms = seed.permissionsForActor
        ? (actor: Actor) =>
              seed.permissionsForActor!({ workspaceId: wsId, actor })
        : (_actor: Actor) => ({ "*": true });

    // snapshot pointers
    const snapshot: ServiceSnapshot = seed.initialSnapshot ?? {
        schema_version: "1.0",
        data: {} as EditorSnapshot,
    };
    const head: Commit | undefined = seed.initialHeadMessage
        ? {
              id: genId("commit", versionCounter++),
              branchId: mainId,
              message: seed.initialHeadMessage,
              versionId: genId("version", versionCounter++),
              etag: `etag-${Date.now()}`,
              createdAt: nowIso(),
          }
        : undefined;
    const draft: Draft | undefined = seed.initialDraft
        ? {
              id: genId("draft", versionCounter++),
              branchId: mainId,
              status: "uncommitted",
              etag: `draft-${Date.now()}`,
              createdAt: nowIso(),
              updatedAt: nowIso(),
          }
        : undefined;

    // templates
    const templates: FieldTemplate[] = (seed.templates ?? []).map(
        (t): FieldTemplate => ({
            id: genId("tpl", templateCounter++),
            key: t.key,
            name: t.name,
            kind: t.kind,
            branchId: t.branchId,
            definition: clone(t.definition ?? {}),
            defaults: t.defaults ? clone(t.defaults) : undefined,
            ui: t.ui ? clone(t.ui) : undefined,
            validators: t.validators ? clone(t.validators) : undefined,
            tags: t.tags ? clone(t.tags) : undefined,
            category: t.category,
            published: t.published ?? false,
            version: 1,
            createdAt: nowIso(),
            updatedAt: nowIso(),
        }),
    );

    const store: Store = {
        workspaceId: wsId,
        authors,
        permissionsForActor: perms,
        branches,
        mainId,
        templates,
        snapshot,
        head,
        draft,
        counters: {
            id: idCounter,
            version: versionCounter,
            template: templateCounter,
        },
    };

    /* ---------------- authors backend ---------------- */

    const authorsBackend = {
        async list(workspaceId: string): Result<readonly Author[]> {
            if (workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            return ok(clone(store.authors));
        },
        async get(authorId: string): Result<Author | null> {
            const a = store.authors.find((x) => x.id === authorId) ?? null;
            return ok(a ? clone(a) : null);
        },
        async refresh(workspaceId: string): Result<readonly Author[]> {
            return this.list(workspaceId);
        },
    };

    /* ---------------- permissions backend ---------------- */

    const permissionsBackend = {
        async get(workspaceId: string, actor: Actor): Result<PermissionsMap> {
            if (workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            return ok(clone(store.permissionsForActor(actor)));
        },
        async refresh(
            workspaceId: string,
            actor: Actor,
        ): Result<PermissionsMap> {
            return this.get(workspaceId, actor);
        },
    };

    /* ---------------- branches backend ---------------- */

    const branchesBackend: BranchesBackend = {
        async list(workspaceId: string): Result<readonly Branch[]> {
            if (workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            return ok(clone(store.branches));
        },
        async create(
            workspaceId: string,
            name: string,
            opts?: Readonly<{ fromId?: string }>,
        ): Result<Branch> {
            if (workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            const now = nowIso();
            const fromId = opts?.fromId;
            const headVersionId = fromId
                ? store.branches.find((b) => b.id === fromId)?.headVersionId
                : undefined;
            const b: Branch = {
                id: genId("branch", ++store.counters.id),
                name,
                isMain: false,
                headVersionId,
                createdAt: now,
                updatedAt: now,
            };
            store.branches.push(b);
            return ok(clone(b));
        },
        async setMain(workspaceId: string, branchId: string): Result<Branch> {
            if (workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            const target = store.branches.find((b) => b.id === branchId);
            if (!target) return err("not_found", "Branch not found");
            store.branches.forEach((b) => (b.isMain = b.id === branchId));
            store.mainId = branchId;
            target.updatedAt = nowIso();
            return ok(clone(target));
        },
        async merge(
            workspaceId: string,
            sourceId: string,
            targetId: string,
        ): Result<MergeResult> {
            if (workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            const src = store.branches.find((b) => b.id === sourceId);
            const tgt = store.branches.find((b) => b.id === targetId);
            if (!src || !tgt)
                return err("not_found", "Source or target branch not found");
            const merge: MergeResult = {
                sourceId,
                targetId,
                conflicts: 0,
                message: "Fast-forward (memory)",
            };
            tgt.headVersionId = genId("version", ++store.counters.version);
            tgt.updatedAt = nowIso();
            return ok(merge);
        },
        async delete(workspaceId: string, branchId: string): Result<void> {
            if (workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            const idx = store.branches.findIndex((b) => b.id === branchId);
            if (idx < 0) return err("not_found", "Branch not found");
            if (store.branches[idx].isMain)
                return err("forbidden", "Cannot delete main branch");
            store.branches.splice(idx, 1);
            return ok(undefined);
        },
        async refresh(workspaceId: string): Result<readonly Branch[]> {
            return this.list(workspaceId);
        },
    };

    /* ---------------- templates backend ---------------- */

    const templatesBackend: TemplatesBackend = {
        async list(
            params: TemplatesListParams,
        ): Result<readonly FieldTemplate[]> {
            if (params.workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            let items = store.templates.slice();
            if (params.branchId)
                items = items.filter((t) => t.branchId === params.branchId);
            if (params.q) {
                const q = params.q.toLowerCase();
                items = items.filter(
                    (t) =>
                        t.name.toLowerCase().includes(q) ||
                        t.key.toLowerCase().includes(q) ||
                        (t.tags ?? []).some((tag) =>
                            tag.toLowerCase().includes(q),
                        ),
                );
            }
            if (params.tags?.length) {
                items = items.filter((t) => {
                    const set = new Set(
                        (t.tags ?? []).map((x) => x.toLowerCase()),
                    );
                    return params.tags!.every((tg) =>
                        set.has(tg.toLowerCase()),
                    );
                });
            }
            if (params.category) {
                items = items.filter(
                    (t) =>
                        (t.category ?? "").toLowerCase() ===
                        params.category!.toLowerCase(),
                );
            }
            return ok(clone(items));
        },

        async get(id: string): Result<FieldTemplate | null> {
            const t = store.templates.find((x) => x.id === id) ?? null;
            return ok(t ? clone(t) : null);
        },

        async getByKey(
            workspaceId: string,
            key: string,
            branchId?: string,
        ): Result<FieldTemplate | null> {
            if (workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            const t =
                store.templates.find(
                    (x) =>
                        x.key === key &&
                        (branchId ? x.branchId === branchId : true),
                ) ?? null;
            return ok(t ? clone(t) : null);
        },

        async create(
            workspaceId: string,
            input: TemplateCreateInput,
        ): Result<FieldTemplate> {
            if (workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            const key = input.key ?? suggestKey(input.name);
            if (
                store.templates.some(
                    (t) =>
                        t.key === key &&
                        (input.branchId
                            ? t.branchId === input.branchId
                            : !t.branchId),
                )
            ) {
                return err("conflict", "Template key already exists");
            }
            const t: FieldTemplate = {
                id: genId("tpl", ++store.counters.template),
                key,
                name: input.name,
                kind: input.kind,
                branchId: input.branchId,
                definition: clone(input.definition ?? {}),
                defaults: input.defaults ? clone(input.defaults) : undefined,
                ui: input.ui ? clone(input.ui) : undefined,
                validators: input.validators
                    ? clone(input.validators)
                    : undefined,
                tags: input.tags ? clone(input.tags) : undefined,
                category: input.category,
                published: input.published ?? false,
                version: 1,
                createdAt: nowIso(),
                updatedAt: nowIso(),
            };
            store.templates.push(t);
            return ok(clone(t));
        },

        async update(
            id: string,
            patch: TemplateUpdatePatch,
        ): Result<FieldTemplate> {
            const t = store.templates.find((x) => x.id === id);
            if (!t) return err("not_found", "Template not found");
            if (patch.name !== undefined) t.name = patch.name;
            if (patch.kind !== undefined) t.kind = patch.kind;
            if (patch.branchId !== undefined)
                t.branchId = patch.branchId ?? undefined;
            if (patch.definition !== undefined)
                t.definition = clone(patch.definition);
            if (patch.defaults !== undefined)
                t.defaults = patch.defaults ? clone(patch.defaults) : undefined;
            if (patch.ui !== undefined)
                t.ui = patch.ui ? clone(patch.ui) : undefined;
            if (patch.validators !== undefined)
                t.validators = patch.validators
                    ? clone(patch.validators)
                    : undefined;
            if (patch.tags !== undefined)
                t.tags = patch.tags ? clone(patch.tags) : undefined;
            if (patch.category !== undefined)
                t.category = patch.category ?? undefined;
            if (patch.published !== undefined) t.published = patch.published;
            t.version += 1;
            t.updatedAt = nowIso();
            return ok(clone(t));
        },

        async clone(
            source: Readonly<{ id?: string; key?: string }>,
            opts?: Readonly<{
                newKey?: string;
                name?: string;
                branchId?: string;
                asDraft?: boolean;
            }>,
        ): Result<FieldTemplate> {
            const orig =
                (source.id &&
                    store.templates.find((x) => x.id === source.id)) ||
                (source.key &&
                    store.templates.find((x) => x.key === source.key)) ||
                null;
            if (!orig) return err("not_found", "Source template not found");
            const key = opts?.newKey ?? uniqueKey(orig.key);
            const t: FieldTemplate = {
                ...clone(orig),
                id: genId("tpl", ++store.counters.template),
                key,
                name: opts?.name ?? `${orig.name} Copy`,
                branchId: opts?.branchId ?? orig.branchId,
                published: opts?.asDraft ? false : orig.published,
                version: 1,
                createdAt: nowIso(),
                updatedAt: nowIso(),
            };
            store.templates.push(t);
            return ok(clone(t));
        },

        async publish(id: string): Result<FieldTemplate> {
            const t = store.templates.find((x) => x.id === id);
            if (!t) return err("not_found", "Template not found");
            t.published = true;
            t.version += 1;
            t.updatedAt = nowIso();
            return ok(clone(t));
        },

        async unpublish(id: string): Result<FieldTemplate> {
            const t = store.templates.find((x) => x.id === id);
            if (!t) return err("not_found", "Template not found");
            t.published = false;
            t.version += 1;
            t.updatedAt = nowIso();
            return ok(clone(t));
        },

        async delete(id: string): Result<void> {
            const i = store.templates.findIndex((x) => x.id === id);
            if (i < 0) return err("not_found", "Template not found");
            store.templates.splice(i, 1);
            return ok(undefined);
        },

        async refresh(
            params: Omit<TemplatesListParams, "q" | "tags" | "category">,
        ): Result<readonly FieldTemplate[]> {
            return this.list(params as TemplatesListParams);
        },
    };

    function suggestKey(name: string): string {
        const base = name
            .trim()
            .toLowerCase()
            .replace(/\s+/g, "-")
            .replace(/[^a-z0-9\-]/g, "");
        return uniqueKey(base || "template");
    }
    function uniqueKey(base: string): string {
        let k = base;
        let i = 1;
        while (store.templates.some((t) => t.key === k)) {
            k = `${base}-${++i}`;
        }
        return k;
    }

    /* ---------------- snapshots backend ---------------- */

    const snapshotsBackend: SnapshotsBackend = {
        async load(params): Result<SnapshotsLoadResult> {
            if (params.workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            return ok({
                head: store.head ? clone(store.head) : undefined,
                draft: store.draft ? clone(store.draft) : undefined,
                snapshot: clone(store.snapshot),
            });
        },
        async autosave(params): Result<{ draft: Draft }> {
            if (params.workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            store.snapshot = clone(params.snapshot);
            const d: Draft = {
                id: store.draft?.id ?? genId("draft", ++store.counters.version),
                branchId: params.branchId,
                status: "uncommitted",
                etag: `draft-${Date.now()}`,
                createdAt: store.draft?.createdAt ?? nowIso(),
                updatedAt: nowIso(),
            };
            store.draft = d;
            return ok({ draft: clone(d) });
        },
        async save(params): Result<{ commit: Commit }> {
            if (params.workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            store.snapshot = clone(params.snapshot);
            const commit: Commit = {
                id: genId("commit", ++store.counters.version),
                branchId: params.branchId,
                message: params.message ?? "Save (memory)",
                versionId: genId("version", ++store.counters.version),
                etag: `etag-${Date.now()}`,
                createdAt: nowIso(),
            };
            store.head = commit;
            store.draft = undefined;
            const tgt = store.branches.find((b) => b.id === params.branchId);
            if (tgt) {
                tgt.headVersionId = commit.versionId;
                tgt.updatedAt = nowIso();
            }
            return ok({ commit: clone(commit) });
        },
        async publish(params): Result<{ commit: Commit }> {
            if (params.workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            if (!store.draft || store.draft.id !== params.draftId)
                return err("not_found", "Draft not found");
            const commit: Commit = {
                id: genId("commit", ++store.counters.version),
                branchId: store.draft.branchId,
                message: params.message ?? "Publish (memory)",
                versionId: genId("version", ++store.counters.version),
                etag: `etag-${Date.now()}`,
                createdAt: nowIso(),
            };
            store.head = commit;
            store.draft = undefined;
            const tgt = store.branches.find((b) => b.id === commit.branchId);
            if (tgt) {
                tgt.headVersionId = commit.versionId;
                tgt.updatedAt = nowIso();
            }
            return ok({ commit: clone(commit) });
        },
        async discard(params): Result<void> {
            if (params.workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            if (!store.draft || store.draft.id !== params.draftId)
                return err("not_found", "Draft not found");
            store.draft = undefined;
            return ok(undefined);
        },
        async refresh(params): Result<{ head?: Commit; draft?: Draft }> {
            if (params.workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            return ok({
                head: store.head ? clone(store.head) : undefined,
                draft: store.draft ? clone(store.draft) : undefined,
            });
        },
    };

    /* ---------------- compose backend ---------------- */

    const backend: WorkspaceBackend = {
        info: {
            id: wsId,
            name: "Workspace 101",
            createdAt: nowIso(),
            updatedAt: nowIso(),
        },
        authors: authorsBackend,
        permissions: permissionsBackend,
        branches: branchesBackend,
        templates: templatesBackend,
        snapshots: snapshotsBackend,
        services: seed.services,
    };

    return backend;
}
```

---
#### 16


` File: src/react/workspace/context/provider/context.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/provider/context.ts
import * as React from "react";
import type { WorkspaceAPI } from "./types";

export const WorkspaceContext = React.createContext<WorkspaceAPI | null>(null);

export function useWorkspace(): WorkspaceAPI {
    const ctx = React.useContext(WorkspaceContext);
    if (!ctx) {
        throw new Error(
            "useWorkspace() must be used under <WorkspaceProvider/>",
        );
    }
    return ctx;
}

export function useWorkspaceMaybe(): WorkspaceAPI | null {
    return React.useContext(WorkspaceContext);
}
```

---
#### 17


` File: src/react/workspace/context/provider/helpers.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/provider/helpers.ts
import type { BackendError, LiveOptions } from "../backend";
import type { DgpServiceCapability, DgpServiceMap } from "@/schema/provider";
import type { RunResult } from "./types";

// Stable default ‚Äî avoids a new object per render
export const LIVE_OFF: LiveOptions = Object.freeze({ mode: "off" as const });

export function toBackendError(e: unknown): BackendError {
    if (
        typeof e === "object" &&
        e &&
        "code" in (e as any) &&
        "message" in (e as any)
    ) {
        return e as BackendError;
    }
    return { code: "unknown_error", message: String(e ?? "Unknown error") };
}

export async function runTasks(
    tasks: Array<() => Promise<unknown>>,
    tolerant: boolean,
): Promise<RunResult> {
    const errors: BackendError[] = [];
    for (const t of tasks) {
        try {
            await t();
        } catch (e) {
            if (!tolerant) throw e;
            errors.push(toBackendError(e));
        }
    }
    return errors.length ? { ok: false, errors } : { ok: true };
}

export function toServiceMap(
    input?: readonly DgpServiceCapability[] | DgpServiceMap | null,
): DgpServiceMap | null {
    if (!input) return null;

    if (Array.isArray(input)) {
        const map: DgpServiceMap = {} as any;
        for (const s of input) map[s.id] = s;
        return map;
    }

    return input as DgpServiceMap;
}
```

---
#### 18


` File: src/react/workspace/context/provider/provider.tsx`  [‚Üë Back to top](#index)

```tsx
// src/react/workspace/context/provider/provider.tsx
import * as React from "react";
import type {
    BackendError,
    BranchParticipant,
    FieldTemplate,
    PermissionsMap,
    Result,
    SnapshotsLoadResult,
    TemplatesListParams,
} from "../backend";
import type { EditorSnapshot } from "@/schema/editor";
import type { DgpServiceMap } from "@/schema/provider";

import { WorkspaceContext } from "./context";
import type {
    BranchCacheEntry,
    BranchesSlice,
    Loadable,
    SnapshotSlice,
    WorkspaceAPI,
    WorkspaceProviderProps,
} from "./types";
import { LIVE_OFF, runTasks, toServiceMap } from "./helpers";

/* ---------------- small helpers ---------------- */

function setLoadableError<T>(
    updater: React.Dispatch<React.SetStateAction<Loadable<T>>>,
    error: BackendError,
) {
    updater((s) => ({ ...s, loading: false, error }));
}

/* ---------------- provider ---------------- */

export function WorkspaceProvider(props: WorkspaceProviderProps): JSX.Element {
    const {
        backend,
        actor,
        initial,
        ensureMain = true,
        live: liveProp,
        autosaveMs = 9000,
        autoAutosave = true,
        children,
    } = props;

    const workspaceId = backend.info.id;
    const live = liveProp ?? LIVE_OFF;
    const now = () => Date.now();

    // --- branch cache (B) ---
    const branchCacheRef = React.useRef<Record<string, BranchCacheEntry>>({});

    const [authors, setAuthors] = React.useState<Loadable<readonly any[]>>({
        data: initial?.authors ?? null,
        loading: false,
        updatedAt: initial?.authors ? now() : undefined,
    });

    const [permissions, setPermissions] = React.useState<
        Loadable<PermissionsMap>
    >({
        data: initial?.permissions ?? null,
        loading: false,
        updatedAt: initial?.permissions ? now() : undefined,
    });

    const [branches, setBranches] = React.useState<BranchesSlice>({
        data: initial?.branches ?? [],
        mainId: initial?.mainId,
        currentId: initial?.currentBranchId ?? initial?.mainId,
        loading: false,
        updatedAt: initial?.branches ? now() : undefined,
    });

    // branch-scoped loadables
    const [templates, setTemplates] = React.useState<
        Loadable<readonly FieldTemplate[]>
    >({
        data: initial?.templates ?? null,
        loading: false,
        updatedAt: initial?.templates ? now() : undefined,
    });

    const [participants, setParticipants] = React.useState<
        Loadable<readonly BranchParticipant[]>
    >({
        data: initial?.participants ?? null,
        loading: false,
        updatedAt: initial?.participants ? now() : undefined,
    });

    const [services, setServices] = React.useState<Loadable<DgpServiceMap>>({
        data: initial?.services ?? null,
        loading: false,
        updatedAt: initial?.services ? now() : undefined,
    });

    const [snapshot, setSnapshot] = React.useState<SnapshotSlice>({
        schemaVersion: initial?.snapshot?.schema_version,
        data: initial?.snapshot?.data as EditorSnapshot | undefined,
        head: initial?.head,
        draft: initial?.draft,
        state: initial?.draft ? "uncommitted" : "clean",
        saving: false,
        dirty: false,
    });

    const autosaveTimerRef = React.useRef<number | null>(null);

    /* -------- ensure main branch -------- */
    React.useEffect(() => {
        if (!ensureMain) return;
        if (branches.data.length === 0) return;

        const existingMain = branches.data.find((b) => b.isMain)?.id;

        if (existingMain && branches.mainId !== existingMain) {
            setBranches((s) => ({
                ...s,
                mainId: existingMain,
                currentId: s.currentId ?? existingMain,
            }));
            return;
        }

        if (!existingMain) {
            const first = branches.data[0]?.id;
            if (first && !branches.currentId) {
                setBranches((s) => ({ ...s, currentId: first }));
            }
        }
    }, [branches.data, branches.mainId, branches.currentId, ensureMain]);

    /* ---------------- refreshers (workspace) ---------------- */

    const refreshAuthors = React.useCallback(async () => {
        setAuthors((s) => ({ ...s, loading: true }));
        const res = await backend.authors.refresh(workspaceId);
        if (res.ok)
            setAuthors({ data: res.value, loading: false, updatedAt: now() });
        else setLoadableError(setAuthors as any, res.error);
    }, [backend.authors, workspaceId]);

    const refreshPermissions = React.useCallback(async () => {
        setPermissions((s) => ({ ...s, loading: true }));
        const res = await backend.permissions.refresh(workspaceId, actor);
        if (res.ok) {
            setPermissions({
                data: res.value,
                loading: false,
                updatedAt: now(),
            });
        } else {
            setLoadableError(setPermissions, res.error);
        }
    }, [backend.permissions, workspaceId, actor]);

    const refreshBranches = React.useCallback(async () => {
        setBranches((s) => ({ ...s, loading: true }));
        const res = await backend.branches.refresh(workspaceId);

        if (!res.ok) {
            setBranches((s) => ({ ...s, loading: false, error: res.error }));
            return;
        }

        const data = res.value;
        const main = data.find((b) => b.isMain)?.id;

        setBranches((s) => {
            const currentStillExists =
                s.currentId && data.some((b) => b.id === s.currentId);
            const nextCurrent = currentStillExists
                ? s.currentId
                : (main ?? data[0]?.id);
            return {
                data,
                mainId: main ?? s.mainId,
                currentId: nextCurrent,
                loading: false,
                updatedAt: now(),
            };
        });
    }, [backend.branches, workspaceId]);

    const refreshServices = React.useCallback(async () => {
        setServices((s) => ({ ...s, loading: true }));
        const res = await backend.services.refresh(workspaceId, {
            since: services.updatedAt,
        });
        if (!res.ok) {
            setLoadableError(setServices, res.error);
            return;
        }
        const map = toServiceMap(res.value);
        setServices({
            data: map ?? ({} as any),
            loading: false,
            updatedAt: now(),
        });
    }, [backend.services, workspaceId, services.updatedAt]);

    /* ---------------- refreshers (branch context) ---------------- */

    const refreshTemplates = React.useCallback(
        async (
            params?: Partial<Pick<TemplatesListParams, "branchId" | "since">>,
        ) => {
            const branchId = params?.branchId ?? branches.currentId;
            if (!branchId) return;

            setTemplates((s) => ({ ...s, loading: true }));

            const res = await backend.templates.refresh({
                workspaceId,
                branchId,
                since: params?.since ?? templates.updatedAt,
            });

            if (res.ok) {
                setTemplates({
                    data: res.value,
                    loading: false,
                    updatedAt: now(),
                });
            } else {
                setLoadableError(setTemplates, res.error);
            }
        },
        [
            backend.templates,
            workspaceId,
            branches.currentId,
            templates.updatedAt,
        ],
    );

    const refreshParticipants = React.useCallback(
        async (
            params?: Partial<{ branchId: string; since?: number | string }>,
        ) => {
            const branchId = params?.branchId ?? branches.currentId;
            if (!branchId) return;

            setParticipants((s) => ({ ...s, loading: true }));

            const res = await backend.access.refreshParticipants(
                workspaceId,
                branchId,
                {
                    since: params?.since ?? participants.updatedAt,
                },
            );

            if (res.ok) {
                setParticipants({
                    data: res.value,
                    loading: false,
                    updatedAt: now(),
                });
            } else {
                setLoadableError(setParticipants, res.error);
            }
        },
        [
            backend.access,
            workspaceId,
            branches.currentId,
            participants.updatedAt,
        ],
    );

    const refreshSnapshotPointersForBranch = React.useCallback(
        async (branchId: string) => {
            const res = await backend.snapshots.refresh({
                workspaceId,
                branchId,
                actorId: actor.id,
                since: snapshot.lastSavedAt ?? snapshot.lastDraftAt,
            });

            if (!res.ok) return;

            setSnapshot((s) => ({
                ...s,
                head: res.value.head ?? s.head,
                draft: res.value.draft,
                state: res.value.draft
                    ? "uncommitted"
                    : s.dirty
                      ? "dirty"
                      : "clean",
            }));
        },
        [
            backend.snapshots,
            workspaceId,
            actor.id,
            snapshot.lastSavedAt,
            snapshot.lastDraftAt,
        ],
    );

    const refreshSnapshotPointers = React.useCallback(async () => {
        const branchId = branches.currentId;
        if (!branchId) return;
        await refreshSnapshotPointersForBranch(branchId);
    }, [branches.currentId, refreshSnapshotPointersForBranch]);

    const refreshBranchContext = React.useCallback(async () => {
        const branchId = branches.currentId;
        if (!branchId) return;

        await runTasks(
            [
                () => refreshParticipants({ branchId }),
                () => refreshTemplates({ branchId }),
                () => refreshSnapshotPointersForBranch(branchId),
            ],
            true,
        );
    }, [
        branches.currentId,
        refreshParticipants,
        refreshTemplates,
        refreshSnapshotPointersForBranch,
    ]);

    const refreshAll = React.useCallback(
        async (opts?: { strict?: boolean }) =>
            runTasks(
                [
                    () => refreshAuthors(),
                    () => refreshPermissions(),
                    () => refreshBranches(),
                    () => refreshServices(),
                    () => refreshBranchContext(),
                ],
                !(opts?.strict ?? false),
            ),
        [
            refreshAuthors,
            refreshPermissions,
            refreshBranches,
            refreshServices,
            refreshBranchContext,
        ],
    );

    /* ---------------- snapshot ops (must include actorId) ---------------- */

    const loadSnapshotForBranch = React.useCallback(
        async (
            branchId: string,
            params?: Readonly<{ versionId?: string }>,
        ): Result<SnapshotsLoadResult> => {
            const res = await backend.snapshots.load({
                workspaceId,
                branchId,
                actorId: actor.id,
                versionId: params?.versionId,
            });

            if (res.ok) {
                const { head, draft, snapshot: snap } = res.value;
                setSnapshot({
                    schemaVersion: snap.schema_version,
                    data: snap.data,
                    head,
                    draft,
                    state: draft ? "uncommitted" : "clean",
                    saving: false,
                    dirty: false,
                    lastSavedAt: undefined,
                    lastDraftAt: undefined,
                });
            }

            return res;
        },
        [backend.snapshots, workspaceId, actor.id],
    );

    const loadSnapshot = React.useCallback(
        async (
            params?: Readonly<{ versionId?: string }>,
        ): Result<SnapshotsLoadResult> => {
            const branchId = branches.currentId;
            if (!branchId) {
                return {
                    ok: false,
                    error: {
                        code: "no_branch",
                        message: "No current branch to load snapshot from.",
                    },
                } as const;
            }
            return loadSnapshotForBranch(branchId, params);
        },
        [branches.currentId, loadSnapshotForBranch],
    );

    const setSnapshotData = React.useCallback(
        (updater: (curr: EditorSnapshot | undefined) => EditorSnapshot) => {
            setSnapshot((s) => ({
                ...s,
                data: updater(s.data),
                state: s.draft ? "uncommitted" : "dirty",
                dirty: true,
            }));
        },
        [],
    );

    const doAutosave = React.useCallback(async () => {
        const branchId = branches.currentId;
        if (!branchId) {
            return {
                ok: false,
                error: {
                    code: "no_branch",
                    message: "No current branch to autosave.",
                },
            } as const;
        }
        if (!snapshot.data || !snapshot.schemaVersion) {
            return {
                ok: false,
                error: { code: "no_snapshot", message: "Nothing to autosave." },
            } as const;
        }

        const res = await backend.snapshots.autosave({
            workspaceId,
            branchId,
            actorId: actor.id,
            snapshot: {
                schema_version: snapshot.schemaVersion,
                data: snapshot.data,
            },
            etag: snapshot.draft?.etag,
        });

        if (res.ok) {
            setSnapshot((s) => ({
                ...s,
                draft: res.value.draft,
                state: "uncommitted",
                dirty: false,
                lastDraftAt: now(),
            }));
        }

        return res;
    }, [
        backend.snapshots,
        workspaceId,
        actor.id,
        branches.currentId,
        snapshot.data,
        snapshot.schemaVersion,
        snapshot.draft?.etag,
    ]);

    const doSave = React.useCallback(
        async (message?: string) => {
            const branchId = branches.currentId;
            if (!branchId) {
                return {
                    ok: false,
                    error: {
                        code: "no_branch",
                        message: "No current branch to save.",
                    },
                } as const;
            }
            if (!snapshot.data || !snapshot.schemaVersion) {
                return {
                    ok: false,
                    error: { code: "no_snapshot", message: "Nothing to save." },
                } as const;
            }

            setSnapshot((s) => ({ ...s, state: "saving", saving: true }));

            const res = await backend.snapshots.save({
                workspaceId,
                branchId,
                actorId: actor.id,
                snapshot: {
                    schema_version: snapshot.schemaVersion,
                    data: snapshot.data,
                },
                message,
                draftId: snapshot.draft?.id,
                etag: snapshot.head?.etag,
            });

            if (res.ok) {
                const commit = res.value.commit;
                setSnapshot((s) => ({
                    ...s,
                    head: commit,
                    draft: undefined,
                    state: "clean",
                    saving: false,
                    dirty: false,
                    lastSavedAt: now(),
                }));
            } else {
                setSnapshot((s) => ({
                    ...s,
                    state: s.draft ? "uncommitted" : "dirty",
                    saving: false,
                }));
            }

            return res;
        },
        [
            backend.snapshots,
            workspaceId,
            actor.id,
            branches.currentId,
            snapshot.data,
            snapshot.schemaVersion,
            snapshot.draft?.id,
            snapshot.head?.etag,
        ],
    );

    const doPublish = React.useCallback(
        async (message?: string) => {
            const draftId = snapshot.draft?.id;
            if (!draftId) return doSave(message);

            const res = await backend.snapshots.publish({
                workspaceId,
                actorId: actor.id,
                draftId,
                message,
            });

            if (res.ok) {
                const commit = res.value.commit;
                setSnapshot((s) => ({
                    ...s,
                    head: commit,
                    draft: undefined,
                    state: "clean",
                    saving: false,
                    dirty: false,
                    lastSavedAt: now(),
                }));
            }

            return res;
        },
        [backend.snapshots, workspaceId, actor.id, snapshot.draft?.id, doSave],
    );

    const discardDraft = React.useCallback(async () => {
        const draftId = snapshot.draft?.id;
        if (!draftId) return { ok: true, value: undefined } as const;

        const res = await backend.snapshots.discard({
            workspaceId,
            actorId: actor.id,
            draftId,
        });

        if (res.ok) {
            setSnapshot((s) => ({
                ...s,
                draft: undefined,
                state: s.dirty ? "dirty" : "clean",
            }));
        }

        return res;
    }, [backend.snapshots, workspaceId, actor.id, snapshot.draft?.id]);

    /* ---------------- autosave effect ---------------- */

    React.useEffect(() => {
        if (!autoAutosave || !snapshot.dirty) return;

        if (autosaveTimerRef.current) {
            window.clearTimeout(autosaveTimerRef.current);
            autosaveTimerRef.current = null;
        }

        autosaveTimerRef.current = window.setTimeout(() => {
            void doAutosave();
            autosaveTimerRef.current = null;
        }, autosaveMs) as unknown as number;

        return () => {
            if (autosaveTimerRef.current) {
                window.clearTimeout(autosaveTimerRef.current);
                autosaveTimerRef.current = null;
            }
        };
    }, [snapshot.dirty, autosaveMs, autoAutosave, doAutosave]);

    /* ---------------- branch switching (cache-first) ---------------- */

    const setCurrentBranch = React.useCallback(
        (id: string) => {
            const prevId = branches.currentId;

            // cache previous branch scope
            if (prevId && prevId !== id) {
                branchCacheRef.current[prevId] = {
                    templates,
                    participants,
                    snapshot,
                };
            }

            // apply cached next branch scope (if any) BEFORE changing
            const cached = branchCacheRef.current[id];
            if (cached) {
                setTemplates(cached.templates);
                setParticipants(cached.participants);
                setSnapshot(cached.snapshot);
            } else {
                setTemplates((s) => ({ ...s, data: null, error: undefined }));
                setParticipants((s) => ({
                    ...s,
                    data: null,
                    error: undefined,
                }));
                setSnapshot((s) => ({
                    ...s,
                    head: undefined,
                    draft: undefined,
                    state: "clean",
                    saving: false,
                    dirty: false,
                    lastSavedAt: undefined,
                    lastDraftAt: undefined,
                }));
            }

            setBranches((s) => ({ ...s, currentId: id }));

            // Only load if we DON'T have cached snapshot data
            const hasCachedSnapshot = Boolean(
                cached?.snapshot?.data && cached?.snapshot?.schemaVersion,
            );
            if (!hasCachedSnapshot && !initial?.snapshot) {
                void loadSnapshotForBranch(id);
            } else {
                // lightweight pointer refresh is allowed later via refresh.branchContext()
            }
        },
        [
            branches.currentId,
            templates,
            participants,
            snapshot,
            initial?.snapshot,
            loadSnapshotForBranch,
        ],
    );

    /* ---------------- live (poll baseline) ---------------- */

    const [liveState, setLiveState] = React.useState<{
        connected: boolean;
        lastEventAt?: number;
    }>({
        connected: false,
    });

    const pollsMs: number =
        live.mode === "poll" ? (live.intervalMs ?? 15000) : 0;
    const liveKey: string = `${live.mode}:${pollsMs}`;
    const workspaceKey: string = workspaceId;

    const hasAnyData: boolean = Boolean(
        (authors.data && (authors.data as any[]).length) ||
            (branches.data && branches.data.length) ||
            (templates.data && templates.data.length) ||
            (participants.data && participants.data.length) ||
            snapshot.data?.props,
    );

    React.useEffect(() => {
        if (live.mode === "off") {
            if (!hasAnyData) {
                void (async () => {
                    await refreshAll({ strict: false });
                })();
            }
            return;
        }

        if (live.mode === "poll") {
            setLiveState((s) => ({ ...s, connected: true }));

            const tick = async () => {
                // workspace + current branch context
                await runTasks(
                    [
                        () => refreshAuthors(),
                        () => refreshPermissions(),
                        () => refreshBranches(),
                        () => refreshServices(),
                        () => refreshBranchContext(),
                    ],
                    true,
                );
                setLiveState({ connected: true, lastEventAt: Date.now() });
            };

            const id = window.setInterval(tick, pollsMs) as unknown as number;
            void tick();

            return () => {
                window.clearInterval(id);
                setLiveState({ connected: false });
            };
        }

        // Future: SSE/WS branch here
    }, [
        workspaceKey,
        liveKey,
        hasAnyData,
        refreshAll,
        refreshAuthors,
        refreshPermissions,
        refreshBranches,
        refreshServices,
        refreshBranchContext,
    ]);

    /* ---------------- branch ops ---------------- */

    const createBranch = React.useCallback<WorkspaceAPI["createBranch"]>(
        async (name, opts) => {
            const res = await backend.branches.create(workspaceId, name, opts);
            if (res.ok) {
                await refreshBranches();
                setCurrentBranch(res.value.id);
            }
            return res;
        },
        [backend.branches, workspaceId, refreshBranches, setCurrentBranch],
    );

    const setMain = React.useCallback<WorkspaceAPI["setMain"]>(
        async (branchId) => {
            const res = await backend.branches.setMain(workspaceId, branchId);
            if (res.ok) await refreshBranches();
            return res;
        },
        [backend.branches, workspaceId, refreshBranches],
    );

    const mergeBranch = React.useCallback<WorkspaceAPI["mergeBranch"]>(
        async (sourceId, targetId) => {
            const res = await backend.branches.merge(
                workspaceId,
                sourceId,
                targetId,
            );
            if (res.ok) {
                await runTasks(
                    [() => refreshBranches(), () => refreshBranchContext()],
                    true,
                );
            }
            return res;
        },
        [backend.branches, workspaceId, refreshBranches, refreshBranchContext],
    );

    const deleteBranch = React.useCallback<WorkspaceAPI["deleteBranch"]>(
        async (branchId) => {
            const res = await backend.branches.delete(workspaceId, branchId);
            if (res.ok) {
                await refreshBranches();

                if (branches.currentId === branchId) {
                    const fallback = branches.data.find(
                        (b) => b.id !== branchId,
                    )?.id;
                    if (fallback) setCurrentBranch(fallback);
                }
            }
            return res;
        },
        [
            backend.branches,
            workspaceId,
            refreshBranches,
            branches.currentId,
            branches.data,
            setCurrentBranch,
        ],
    );

    /* ---------------- template ops ---------------- */

    const createTemplate = React.useCallback<WorkspaceAPI["createTemplate"]>(
        async (input) => {
            const res = await backend.templates.create(workspaceId, {
                ...input,
                branchId: input.branchId ?? branches.currentId,
            });

            if (res.ok) {
                await refreshTemplates({
                    branchId: res.value.branchId ?? branches.currentId,
                });
            }

            return res;
        },
        [backend.templates, workspaceId, branches.currentId, refreshTemplates],
    );

    const updateTemplate = React.useCallback<WorkspaceAPI["updateTemplate"]>(
        async (id, patch) => {
            const res = await backend.templates.update(id, patch);
            if (res.ok) {
                await refreshTemplates({
                    branchId: res.value.branchId ?? branches.currentId,
                });
            }
            return res;
        },
        [backend.templates, branches.currentId, refreshTemplates],
    );

    const cloneTemplate = React.useCallback<WorkspaceAPI["cloneTemplate"]>(
        async (source, opts) => {
            const res = await backend.templates.clone(
                source,
                opts ?? { branchId: branches.currentId ?? undefined },
            );
            if (res.ok) {
                await refreshTemplates({
                    branchId: res.value.branchId ?? branches.currentId,
                });
            }
            return res;
        },
        [backend.templates, branches.currentId, refreshTemplates],
    );

    const publishTemplate = React.useCallback<WorkspaceAPI["publishTemplate"]>(
        async (id) => {
            const res = await backend.templates.publish(id);
            if (res.ok) {
                await refreshTemplates({
                    branchId: res.value.branchId ?? branches.currentId,
                });
            }
            return res;
        },
        [backend.templates, branches.currentId, refreshTemplates],
    );

    const unpublishTemplate = React.useCallback<
        WorkspaceAPI["unpublishTemplate"]
    >(
        async (id) => {
            const res = await backend.templates.unpublish(id);
            if (res.ok) {
                await refreshTemplates({
                    branchId: res.value.branchId ?? branches.currentId,
                });
            }
            return res;
        },
        [backend.templates, branches.currentId, refreshTemplates],
    );

    const deleteTemplate = React.useCallback<WorkspaceAPI["deleteTemplate"]>(
        async (id) => {
            const res = await backend.templates.delete(id);
            if (res.ok) {
                await refreshTemplates({ branchId: branches.currentId });
            }
            return res;
        },
        [backend.templates, branches.currentId, refreshTemplates],
    );

    /* ---------------- cache invalidation ---------------- */

    const invalidate = React.useCallback<WorkspaceAPI["invalidate"]>((keys) => {
        const setAll = !keys || keys.length === 0;

        if (setAll || keys.includes("authors"))
            setAuthors((s) => ({ ...s, updatedAt: undefined }));
        if (setAll || keys.includes("permissions"))
            setPermissions((s) => ({ ...s, updatedAt: undefined }));
        if (setAll || keys.includes("branches"))
            setBranches((s) => ({ ...s, updatedAt: undefined }));
        if (setAll || keys.includes("services"))
            setServices((s) => ({ ...s, updatedAt: undefined }));

        if (setAll || keys.includes("templates"))
            setTemplates((s) => ({ ...s, updatedAt: undefined }));
        if (setAll || keys.includes("participants"))
            setParticipants((s) => ({ ...s, updatedAt: undefined }));

        // clear branch cache if branch-scoped keys invalidated
        if (
            setAll ||
            keys.includes("templates") ||
            keys.includes("participants")
        ) {
            branchCacheRef.current = {};
        }
    }, []);

    /* ---------------- memo API ---------------- */

    const api: WorkspaceAPI = React.useMemo(
        () => ({
            info: backend.info,
            actor,

            authors: authors as any,
            permissions,
            branches,

            templates,
            participants,
            services,

            refresh: {
                all: refreshAll,

                authors: refreshAuthors,
                permissions: refreshPermissions,
                branches: refreshBranches,
                services: refreshServices,

                branchContext: refreshBranchContext,
                templates: refreshTemplates,
                participants: refreshParticipants,
                snapshotPointers: refreshSnapshotPointers,
            },

            setCurrentBranch,
            createBranch,
            setMain,
            mergeBranch,
            deleteBranch,

            createTemplate,
            updateTemplate,
            cloneTemplate,
            publishTemplate,
            unpublishTemplate,
            deleteTemplate,

            invalidate,

            live: {
                connected: liveState.connected,
                lastEventAt: liveState.lastEventAt,
                connect: () => {
                    /* for SSE/WS: re-render provider with live prop */
                },
                disconnect: () => {
                    /* re-render provider with live={{mode:"off"}} */
                },
            },

            snapshot: {
                state: snapshot.state,
                saving: snapshot.saving,
                dirty: snapshot.dirty,
                head: snapshot.head,
                draft: snapshot.draft,
                schemaVersion: snapshot.schemaVersion,
                data: snapshot.data,
                lastSavedAt: snapshot.lastSavedAt,
                lastDraftAt: snapshot.lastDraftAt,

                set: setSnapshotData,
                load: loadSnapshot,
                refresh: refreshSnapshotPointers,
                autosave: doAutosave,
                save: doSave,
                publish: doPublish,
                discardDraft: discardDraft,
            },
        }),
        [
            backend.info,
            actor,
            authors,
            permissions,
            branches,
            templates,
            participants,
            services,

            refreshAll,
            refreshAuthors,
            refreshPermissions,
            refreshBranches,
            refreshServices,
            refreshBranchContext,
            refreshTemplates,
            refreshParticipants,
            refreshSnapshotPointers,

            setCurrentBranch,
            createBranch,
            setMain,
            mergeBranch,
            deleteBranch,

            createTemplate,
            updateTemplate,
            cloneTemplate,
            publishTemplate,
            unpublishTemplate,
            deleteTemplate,

            invalidate,

            liveState.connected,
            liveState.lastEventAt,

            snapshot.state,
            snapshot.saving,
            snapshot.dirty,
            snapshot.head,
            snapshot.draft,
            snapshot.schemaVersion,
            snapshot.data,
            snapshot.lastSavedAt,
            snapshot.lastDraftAt,

            setSnapshotData,
            loadSnapshot,
            doAutosave,
            doSave,
            doPublish,
            discardDraft,
        ],
    );

    return (
        <WorkspaceContext.Provider value={api}>
            {children}
        </WorkspaceContext.Provider>
    );
}
```

---
#### 19


` File: src/react/workspace/context/provider/types.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/provider/types.ts
import type {
    Actor,
    Author,
    BackendError,
    Branch,
    BranchParticipant,
    Commit,
    Draft,
    FieldTemplate,
    LiveOptions,
    MergeResult,
    PermissionsMap,
    Result,
    ServiceSnapshot,
    SnapshotsLoadResult,
    TemplateCreateInput,
    TemplateUpdatePatch,
    TemplatesListParams,
    WorkspaceBackend,
    WorkspaceInfo,
} from "../backend";
import type { EditorSnapshot } from "@/schema/editor";
import type { DgpServiceMap } from "@/schema/provider";

export interface Loadable<T> {
    readonly data: T | null;
    readonly loading: boolean;
    readonly error?: BackendError;
    readonly updatedAt?: number;
}

export type SnapshotState = "clean" | "dirty" | "uncommitted" | "saving";

export type RunOk = { ok: true };
export type RunErr = { ok: false; errors: BackendError[] };
export type RunResult = RunOk | RunErr;

export interface WorkspaceProviderProps {
    readonly backend: WorkspaceBackend;
    readonly actor: Actor;

    readonly initial?: Partial<{
        authors: readonly Author[];
        permissions: PermissionsMap;
        branches: readonly Branch[];
        mainId: string;

        // branch-scoped caches
        templates: readonly FieldTemplate[];
        participants: readonly BranchParticipant[];

        snapshot: ServiceSnapshot;
        head?: Commit;
        draft?: Draft;

        currentBranchId?: string;

        // services can be injected as already-normalized map
        services: DgpServiceMap;
    }>;

    readonly ensureMain?: boolean;
    readonly live?: LiveOptions;
    readonly autosaveMs?: number; // default 9000
    readonly autoAutosave?: boolean; // default true
    readonly children: React.ReactNode;
}

export interface BranchesSlice {
    readonly data: readonly Branch[];
    readonly mainId?: string;
    readonly currentId?: string;
    readonly loading: boolean;
    readonly error?: BackendError;
    readonly updatedAt?: number;
}

export interface SnapshotSlice {
    readonly schemaVersion?: string;
    readonly data?: EditorSnapshot;
    readonly head?: Commit;
    readonly draft?: Draft;

    readonly state: SnapshotState;
    readonly saving: boolean;
    readonly dirty: boolean;

    readonly lastSavedAt?: number;
    readonly lastDraftAt?: number;
}

export interface BranchCacheEntry {
    readonly templates: Loadable<readonly FieldTemplate[]>;
    readonly participants: Loadable<readonly BranchParticipant[]>;
    readonly snapshot: SnapshotSlice;
}

export interface WorkspaceAPI {
    readonly info: WorkspaceInfo;
    readonly actor: Actor;

    readonly authors: Loadable<readonly Author[]>;
    readonly permissions: Loadable<PermissionsMap>;
    readonly branches: BranchesSlice;

    /** branch-scoped */
    readonly templates: Loadable<readonly FieldTemplate[]>;
    readonly participants: Loadable<readonly BranchParticipant[]>;

    /** workspace-scoped map (already normalized) */
    readonly services: Loadable<DgpServiceMap>;

    readonly refresh: {
        /** Refresh everything (workspace + current-branch context) */
        all(opts?: { strict?: boolean }): Promise<RunResult>;

        authors(): Promise<void>;
        permissions(): Promise<void>;
        branches(): Promise<void>;
        services(): Promise<void>;

        /** Current branch-scoped refreshers */
        branchContext(): Promise<void>;
        templates(
            params?: Partial<Pick<TemplatesListParams, "branchId" | "since">>,
        ): Promise<void>;
        participants(
            params?: Partial<{ branchId: string; since?: number | string }>,
        ): Promise<void>;

        snapshotPointers(): Promise<void>;
    };

    readonly setCurrentBranch: (id: string) => void;

    readonly createBranch: (
        name: string,
        opts?: Readonly<{ fromId?: string }>,
    ) => Result<Branch>;
    readonly setMain: (branchId: string) => Result<Branch>;
    readonly mergeBranch: (
        sourceId: string,
        targetId: string,
    ) => Result<MergeResult>;
    readonly deleteBranch: (branchId: string) => Result<void>;

    // Template ops
    readonly createTemplate: (
        input: TemplateCreateInput,
    ) => Result<FieldTemplate>;
    readonly updateTemplate: (
        id: string,
        patch: TemplateUpdatePatch,
    ) => Result<FieldTemplate>;
    readonly cloneTemplate: (
        source: Readonly<{ id?: string; key?: string }>,
        opts?: Readonly<{
            newKey?: string;
            name?: string;
            branchId?: string;
            asDraft?: boolean;
        }>,
    ) => Result<FieldTemplate>;
    readonly publishTemplate: (id: string) => Result<FieldTemplate>;
    readonly unpublishTemplate: (id: string) => Result<FieldTemplate>;
    readonly deleteTemplate: (id: string) => Result<void>;

    readonly invalidate: (
        keys?: Array<
            | "authors"
            | "permissions"
            | "branches"
            | "services"
            | "templates"
            | "participants"
        >,
    ) => void;

    readonly live: {
        readonly connected: boolean;
        readonly lastEventAt?: number;
        connect(): void;
        disconnect(): void;
    };

    readonly snapshot: {
        readonly state: SnapshotState;
        readonly saving: boolean;
        readonly dirty: boolean;
        readonly head?: Commit;
        readonly draft?: Draft;
        readonly schemaVersion?: string;
        readonly data?: EditorSnapshot;
        readonly lastSavedAt?: number;
        readonly lastDraftAt?: number;

        set(
            updater: (curr: EditorSnapshot | undefined) => EditorSnapshot,
        ): void;

        load(
            params?: Readonly<{ versionId?: string }>,
        ): Result<SnapshotsLoadResult>;
        refresh(): Promise<void>;

        autosave(): Result<Readonly<{ draft: Draft }>>;
        save(message?: string): Result<Readonly<{ commit: Commit }>>;
        publish(message?: string): Result<Readonly<{ commit: Commit }>>;
        discardDraft(): Result<void>;
    };
}
```

---
#### 20


` File: src/react/workspace/index.ts`  [‚Üë Back to top](#index)

```ts
export { Workspace } from "./app";
export * from "./context/backend";
export * from "./context/memory-backend";
export { useWorkspace } from "./context/provider";
```


---
*Generated with [Prodex](https://github.com/emxhive/prodex) ‚Äî Codebase decoded.*
<!-- PRODEx v1.4.11 | 2026-01-20T14:32:20.260Z -->