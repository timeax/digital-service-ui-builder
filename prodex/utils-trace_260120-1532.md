*Generated by [Prodex](https://github.com/emxhive/prodex#readme)*
> Note for LLMs: `Lx-Ly` ranges refer to lines in this Prodex trace file, not the original source files. Index metadata is provided via the HTML comment markers in this section.

# Index
<!-- PRODEX_INDEX_RANGE: L8-L15 -->
<!-- PRODEX_FILE_COUNT: 8 -->
<!-- PRODEX_INDEX_LIST_START -->
- [src/utils/__tests__/build-order-snapshot.quantity.spec.ts](#1)  L19-L389
- [src/utils/__tests__/build-order-snapshot.spec.ts](#2)  L390-L593
- [src/utils/autoLayout.ts](#3)  L594-L1035
- [src/utils/build-order-snapshot.ts](#4)  L1036-L1899
- [src/utils/index.ts](#5)  L1900-L1919
- [src/utils/prune-fallbacks.ts](#6)  L1920-L2066
- [src/utils/retry-queue.ts](#7)  L2067-L2233
- [src/utils/util.ts](#8)  L2234-L2308
<!-- PRODEX_INDEX_LIST_END -->

---
---
#### 1


` File: src/utils/__tests__/build-order-snapshot.quantity.spec.ts`  [↑ Back to top](#index)

```ts
import {describe, it, expect} from 'vitest';
import {buildOrderSnapshot} from '../build-order-snapshot';

import {type Builder, createBuilder} from '../../core';
import type {ServiceProps, Field, Tag} from '../../schema';
import type {DgpServiceMap} from '../../schema/provider';

function mkPropsWithQuantityRule(rule: unknown): ServiceProps {
    const field: Field = {
        id: 'f_qty',
        type: 'text',
        bind_id: 'root',
        name: 'qty_input',
        label: 'Qty',
        meta: {quantity: rule as any},
        pricing_role: 'base',
    };
    return {
        filters: [{id: 'root', label: 'Root'}],
        fields: [field],
        schema_version: '1.0',
    };
}

function mkSelection(value: any) {
    return {
        activeTagId: 'root',
        formValuesByFieldId: {f_qty: value},
        optionSelectionsByFieldId: {},
    };
}

describe('buildOrderSnapshot – malformed quantity rules fallback', () => {
    it('falls back to host default when valueBy is unknown', () => {
        const hostDefault = 7;
        const props = mkPropsWithQuantityRule({valueBy: 'wat'}); // invalid
        const builder = createBuilder();
        builder.load(props);

        const snapshot = buildOrderSnapshot(
            props,
            builder,
            mkSelection(42),
            {}, // service map not needed for this test
            {mode: 'prod', hostDefaultQuantity: hostDefault}
        );

        expect(snapshot.quantity).toBe(hostDefault);
        expect(snapshot.quantitySource.kind).toBe('default');
        expect((snapshot.quantitySource as any).defaultedFromHost).toBe(true);
    });

    it('falls back to host default when valueBy="eval" but code is missing', () => {
        const hostDefault = 5;
        const props = mkPropsWithQuantityRule({valueBy: 'eval'}); // no code
        const builder = createBuilder();
        builder.load(props);

        const snapshot = buildOrderSnapshot(
            props,
            builder,
            mkSelection(123),
            {},
            {mode: 'prod', hostDefaultQuantity: hostDefault}
        );

        expect(snapshot.quantity).toBe(hostDefault);
        expect(snapshot.quantitySource.kind).toBe('default');
        expect((snapshot.quantitySource as any).defaultedFromHost).toBe(true);
    });

    it('falls back to host default when valueBy="eval" but code is not a string', () => {
        const hostDefault = 11;
        const props = mkPropsWithQuantityRule({valueBy: 'eval', code: 1337}); // bad type
        const builder = createBuilder();
        builder.load(props);

        const snapshot = buildOrderSnapshot(
            props,
            builder,
            mkSelection('9'),
            {},
            {mode: 'prod', hostDefaultQuantity: hostDefault}
        );

        expect(snapshot.quantity).toBe(hostDefault);
        expect(snapshot.quantitySource.kind).toBe('default');
        expect((snapshot.quantitySource as any).defaultedFromHost).toBe(true);
    });
});

/* ───────────────── helpers ───────────────── */

function makeBuilderVisibleFields(order: string[]): Builder {
    // Only visibleFields() is used by the snapshot builder here.
    return {
        visibleFields: (_tagId: string, _selected?: string[]) => order.slice(),
    } as unknown as Builder;
}

function tag(id: string, label: string, service_id?: number): Tag {
    return {
        id,
        label,
        ...(service_id !== undefined ? {service_id} : {}),
    } as Tag;
}

function fieldWithQuantity(
    id: string,
    bind_id: string | string[],
    quantity: { valueBy: 'value' | 'length' | 'eval'; code?: string },
    extra?: Partial<Field>
): Field {
    return {
        id,
        type: (extra?.type as string) ?? 'text',
        label: id,
        bind_id,
        ...(extra ?? {}),
        meta: {
            ...(extra?.meta ?? {}),
            quantity,
        },
    } as unknown as Field;
}

function plainField(id: string, bind_id: string | string[], extra?: Partial<Field>): Field {
    return {
        id,
        type: (extra?.type as string) ?? 'text',
        label: id,
        bind_id,
        ...(extra ?? {}),
    } as unknown as Field;
}

function propsOf(tags: Tag[], fields: Field[]): ServiceProps {
    return {filters: tags, fields, schema_version: '1.0'};
}

/* ───────────────── fixtures ───────────────── */

const svcMap: DgpServiceMap = {}; // services aren’t relevant for these tests

const ROOT = tag('t:root', 'Root');

/* ───────────────── tests ───────────────── */

describe('buildOrderSnapshot — quantity evaluation', () => {
    it('value rule: uses the numeric value (coerces string to number)', () => {
        const fQ = fieldWithQuantity('fQ', 't:root', {valueBy: 'value'});
        const props = propsOf([ROOT], [fQ]);
        const builder = makeBuilderVisibleFields(['fQ']);

        const selection = {
            activeTagId: 't:root',
            formValuesByFieldId: {fQ: '5'}, // string "5" → 5
            optionSelectionsByFieldId: {},
        };

        const snap = buildOrderSnapshot(props, builder, selection, svcMap, {
            mode: 'prod',
            hostDefaultQuantity: 1,
        });

        expect(snap.quantity).toBe(5);
        expect(snap.quantitySource.kind).toBe('field');
        expect(snap.quantitySource).toMatchObject({id: 'fQ', rule: {valueBy: 'value'}});
    });

    it('length rule: uses string length', () => {
        const fQ = fieldWithQuantity('fLen', 't:root', {valueBy: 'length'});
        const props = propsOf([ROOT], [fQ]);
        const builder = makeBuilderVisibleFields(['fLen']);

        const selection = {
            activeTagId: 't:root',
            formValuesByFieldId: {fLen: 'hello!'}, // length 6
            optionSelectionsByFieldId: {},
        };

        const snap = buildOrderSnapshot(props, builder, selection, svcMap, {
            mode: 'prod',
            hostDefaultQuantity: 1,
        });

        expect(snap.quantity).toBe(6);
        expect(snap.quantitySource.kind).toBe('field');
        expect(snap.quantitySource).toMatchObject({id: 'fLen', rule: {valueBy: 'length'}});
    });

    it('length rule: uses array length if the value is an array', () => {
        const fQ = fieldWithQuantity('fLenArr', 't:root', {valueBy: 'length'});
        const props = propsOf([ROOT], [fQ]);
        const builder = makeBuilderVisibleFields(['fLenArr']);

        const selection = {
            activeTagId: 't:root',
            formValuesByFieldId: {fLenArr: [1, 2, 3, 4]}, // length 4
            optionSelectionsByFieldId: {},
        };

        const snap = buildOrderSnapshot(props, builder, selection, svcMap, {
            mode: 'prod',
            hostDefaultQuantity: 1,
        });

        expect(snap.quantity).toBe(4);
        expect(snap.quantitySource.kind).toBe('field');
    });

    it('eval rule: evaluates provided code against value/values', () => {
        const fQ = fieldWithQuantity('fEval', 't:root', {
            valueBy: 'eval',
            code: 'return Number(value) * 2;', // e.g. "3" → 6
        });
        const props = propsOf([ROOT], [fQ]);
        const builder = makeBuilderVisibleFields(['fEval']);

        const selection = {
            activeTagId: 't:root',
            formValuesByFieldId: {fEval: '3'},
            optionSelectionsByFieldId: {},
        };

        const snap = buildOrderSnapshot(props, builder, selection, svcMap, {
            mode: 'prod',
            hostDefaultQuantity: 1,
        });

        expect(snap.quantity).toBe(6);
        expect(snap.quantitySource.kind).toBe('field');
        expect(snap.quantitySource).toMatchObject({id: 'fEval', rule: {valueBy: 'eval'}});
    });

    it('first visible field with a quantity rule takes precedence', () => {
        const f1 = fieldWithQuantity('f1', 't:root', {valueBy: 'value'});
        const f2 = fieldWithQuantity('f2', 't:root', {valueBy: 'value'});
        const props = propsOf([ROOT], [f1, f2]);

        // Order: f1 then f2
        const builder = makeBuilderVisibleFields(['f1', 'f2']);

        const selection = {
            activeTagId: 't:root',
            formValuesByFieldId: {f1: '7', f2: '100'}, // f1 wins
            optionSelectionsByFieldId: {},
        };

        const snap = buildOrderSnapshot(props, builder, selection, svcMap, {
            mode: 'prod',
            hostDefaultQuantity: 1,
        });

        expect(snap.quantity).toBe(7);
        expect(snap.quantitySource).toMatchObject({kind: 'field', id: 'f1'});
    });

    it('falls back to host default when quantity rule yields NaN/invalid', () => {
        const fQ = fieldWithQuantity('fBad', 't:root', {valueBy: 'value'});
        const props = propsOf([ROOT], [fQ]);
        const builder = makeBuilderVisibleFields(['fBad']);

        const selection = {
            activeTagId: 't:root',
            formValuesByFieldId: {fBad: 'not-a-number'}, // → NaN
            optionSelectionsByFieldId: {},
        };

        const snap = buildOrderSnapshot(props, builder, selection, svcMap, {
            mode: 'prod',
            hostDefaultQuantity: 9,
        });

        expect(snap.quantity).toBe(9);
        expect(snap.quantitySource.kind).toBe('default');
        expect(snap.quantitySource).toMatchObject({defaultedFromHost: true});
    });

    it('falls back to host default when quantity rule result is ≤ 0', () => {
        const fQ = fieldWithQuantity('fZero', 't:root', {valueBy: 'value'});
        const props = propsOf([ROOT], [fQ]);
        const builder = makeBuilderVisibleFields(['fZero']);

        const selectionZero = {
            activeTagId: 't:root',
            formValuesByFieldId: {fZero: 0},
            optionSelectionsByFieldId: {},
        };

        const snapZero = buildOrderSnapshot(props, builder, selectionZero, svcMap, {
            mode: 'prod',
            hostDefaultQuantity: 3,
        });
        expect(snapZero.quantity).toBe(3);
        expect(snapZero.quantitySource.kind).toBe('default');

        const selectionNeg = {
            activeTagId: 't:root',
            formValuesByFieldId: {fZero: -5},
            optionSelectionsByFieldId: {},
        };
        const snapNeg = buildOrderSnapshot(props, builder, selectionNeg, svcMap, {
            mode: 'prod',
            hostDefaultQuantity: 4,
        });
        expect(snapNeg.quantity).toBe(4);
        expect(snapNeg.quantitySource.kind).toBe('default');
    });

    it('falls back to host default when no quantity rule exists on any visible field', () => {
        const fA = plainField('fA', 't:root');
        const fB = plainField('fB', 't:root');
        const props = propsOf([ROOT], [fA, fB]);
        const builder = makeBuilderVisibleFields(['fA', 'fB']);

        const selection = {
            activeTagId: 't:root',
            formValuesByFieldId: {fA: '123', fB: '456'}, // irrelevant—no rules
            optionSelectionsByFieldId: {},
        };

        const snap = buildOrderSnapshot(props, builder, selection, svcMap, {
            mode: 'prod',
            hostDefaultQuantity: 2,
        });

        expect(snap.quantity).toBe(2);
        expect(snap.quantitySource.kind).toBe('default');
    });

    it('eval rule: if code throws or returns non-numeric → host default', () => {
        const fThrow = fieldWithQuantity('fThrow', 't:root', {
            valueBy: 'eval',
            code: 'throw new Error("boom");',
        });
        const fNan = fieldWithQuantity('fNan', 't:root', {
            valueBy: 'eval',
            code: 'return "nope";',
        });

        const props = propsOf([ROOT], [fThrow, fNan]);

        // Only first visible with a rule will be tested; make it the throwing one
        const builder = makeBuilderVisibleFields(['fThrow', 'fNan']);

        const selection = {
            activeTagId: 't:root',
            formValuesByFieldId: {fThrow: 10, fNan: 10},
            optionSelectionsByFieldId: {},
        };

        const snap = buildOrderSnapshot(props, builder, selection, svcMap, {
            mode: 'prod',
            hostDefaultQuantity: 8,
        });

        expect(snap.quantity).toBe(8);
        expect(snap.quantitySource.kind).toBe('default');
    });
});
```

---
#### 2


` File: src/utils/__tests__/build-order-snapshot.spec.ts`  [↑ Back to top](#index)

```ts
import {describe, it, expect} from 'vitest';

import {buildOrderSnapshot} from '../build-order-snapshot';
import type {BuildOrderSelection} from '../build-order-snapshot';

import type {Builder} from '../../core';
import type {ServiceProps, Field, FieldOption, Tag} from '../../schema';
import type {DgpServiceMap} from '../../schema/provider';

/* ───────────────── helpers ───────────────── */

function makeBuilderVisibleFields(visible: string[]): Builder {
    // We only need visibleFields() for these tests
    const b = {
        visibleFields: (tagId: string, _selected?: string[]) => visible.slice(),
    } as unknown as Builder;
    return b;
}

function tag(id: string, label: string, service_id?: number): Tag {
    return {
        id,
        label,
        ...(service_id !== undefined ? {service_id} : {}),
    } as Tag;
}

function field(
    id: string,
    bind_id: string | string[],
    options?: FieldOption[],
): Field {
    return {
        id,
        type: 'select',
        bind_id,
        label: id,
        options: options ?? [],
    } as Field;
}

function opt(id: string, label: string, service_id?: number, pricing_role: 'base' | 'utility' = 'base'): FieldOption {
    const o: FieldOption = {id, label, ...(service_id !== undefined ? {service_id} : {}), pricing_role};
    return o;
}

function baseProps(tags: Tag[], fields: Field[]): ServiceProps {
    return {
        filters: tags,
        fields,
        schema_version: '1.0',
        // no fallbacks here; we’re testing service composition only
    };
}

/* ───────────────── fixtures ───────────────── */

const svcMap: DgpServiceMap = {
    1: {id: 1, rate: 100},
    10: {id: 10, rate: 90},
    11: {id: 11, rate: 80},
    99: {id: 99, rate: 70},
};

/* ───────────────── tests ───────────────── */

describe('buildOrderSnapshot — service composition', () => {
    it('uses tag service as default when no option with service_id is selected', () => {
        const tags = [tag('t:root', 'Root', 1)];
        const fA = field('fA', 't:root', [opt('o:A1', 'A1'), opt('o:A2', 'A2')]); // no service ids
        const props = baseProps(tags, [fA]);

        const builder = makeBuilderVisibleFields(['fA']);
        const selection: BuildOrderSelection = {
            activeTagId: 't:root',
            formValuesByFieldId: {},
            optionSelectionsByFieldId: {fA: ['o:A1']}, // selected but no service_id on option
        };

        const snap = buildOrderSnapshot(props, builder, selection, svcMap, {mode: 'prod'});

        expect(snap.services).toEqual([1]);
        expect(snap.serviceMap).toEqual({'t:root': [1]});
    });

    it('first selected option with service_id overrides tag default as primary; others append (selection order)', () => {
        const tags = [tag('t:root', 'Root', 1)];
        const fA = field('fA', 't:root', [
            opt('o:A1', 'A1', 10), // has service → should become primary, overrides tag default
            opt('o:A2', 'A2', 11), // appended after
        ]);
        const props = baseProps(tags, [fA]);

        const builder = makeBuilderVisibleFields(['fA']);

        const selection: BuildOrderSelection = {
            activeTagId: 't:root',
            formValuesByFieldId: {},
            optionSelectionsByFieldId: {fA: ['o:A1', 'o:A2']},
            optionTraversalOrder: [
                {fieldId: 'fA', optionId: 'o:A1'},
                {fieldId: 'fA', optionId: 'o:A2'},
            ],
        };

        const snap = buildOrderSnapshot(props, builder, selection, svcMap, {mode: 'prod'});

        // primary is 10 (o:A1), then 11 (o:A2)
        expect(snap.services).toEqual([10, 11]);
        // serviceMap records true origins; tag default is NOT kept because it was overridden
        expect(snap.serviceMap).toEqual({
            'o:A1': [10],
            'o:A2': [11],
        });
        // ensure tag->service mapping is absent when overridden
        expect(Object.keys(snap.serviceMap)).not.toContain('t:root');
    });

    it('ignores options from non-visible fields', () => {
        const tags = [tag('t:root', 'Root', 1), tag('t:other', 'Other')];
        const fA = field('fA', 't:root', [opt('o:A1', 'A1', 10)]);
        const fB = field('fB', 't:other', [opt('o:B1', 'B1', 99)]); // not visible for t:root
        const props = baseProps(tags, [fA, fB]);

        const builder = makeBuilderVisibleFields(['fA']); // ONLY fA visible in this context

        const selection: BuildOrderSelection = {
            activeTagId: 't:root',
            formValuesByFieldId: {},
            optionSelectionsByFieldId: {
                fA: ['o:A1'],
                fB: ['o:B1'], // should be ignored (field not visible for active tag)
            },
        };

        const snap = buildOrderSnapshot(props, builder, selection, svcMap, {mode: 'prod'});

        expect(snap.services).toEqual([10]); // o:B1(99) ignored
        expect(snap.serviceMap).toEqual({'o:A1': [10]});
        expect(Object.keys(snap.serviceMap)).not.toContain('o:B1');
    });

    it('dedupes services list when multiple selected options map to the same service_id', () => {
        const tags = [tag('t:root', 'Root')];
        const fA = field('fA', 't:root', [
            opt('o:A1', 'A1', 10),
            opt('o:A2', 'A2', 10), // same service id as A1
        ]);
        const props = baseProps(tags, [fA]);

        const builder = makeBuilderVisibleFields(['fA']);
        const selection: BuildOrderSelection = {
            activeTagId: 't:root',
            formValuesByFieldId: {},
            optionSelectionsByFieldId: {fA: ['o:A1', 'o:A2']},
        };

        const snap = buildOrderSnapshot(props, builder, selection, svcMap, {mode: 'prod'});

        // Services list is deduped (single 10), but serviceMap keeps both origins
        expect(snap.services).toEqual([10]);
        expect(snap.serviceMap).toEqual({
            'o:A1': [10],
            'o:A2': [10],
        });
    });

    it('ignores misconfigured utilities that carry a service_id (defensive guard)', () => {
        const tags = [tag('t:root', 'Root', 1)];
        const fA = field('fA', 't:root', [
            opt('o:U1', 'U1', 10, 'utility'), // should be ignored (utility with service_id)
            opt('o:B1', 'B1', 11, 'base'),    // valid service
        ]);
        const props = baseProps(tags, [fA]);

        const builder = makeBuilderVisibleFields(['fA']);
        const selection: BuildOrderSelection = {
            activeTagId: 't:root',
            formValuesByFieldId: {},
            optionSelectionsByFieldId: {fA: ['o:U1', 'o:B1']},
            optionTraversalOrder: [
                {fieldId: 'fA', optionId: 'o:U1'},
                {fieldId: 'fA', optionId: 'o:B1'},
            ],
        };

        const snap = buildOrderSnapshot(props, builder, selection, svcMap, {mode: 'prod'});

        // Only the base-role option contributes a service; tag default is overridden
        expect(snap.services).toEqual([11]);
        expect(snap.serviceMap).toEqual({'o:B1': [11]});
        expect(Object.keys(snap.serviceMap)).not.toContain('o:U1');
        expect(Object.keys(snap.serviceMap)).not.toContain('t:root');
    });
});
```

---
#### 3


` File: src/utils/autoLayout.ts`  [↑ Back to top](#index)

```ts
/* src/utils/autoLayout.ts
 * ELK.js-powered auto-layout (layered → RIGHT, orthogonal edges)
 * - Preserves already-placed nodes (treat (0,0) as "unplaced" by default)
 * - Places only unpositioned nodes
 * - Exposes optional orthogonal edge routes (waypoints)
 */

import Elk, { ElkExtendedEdge, ElkNode, LayoutOptions } from "elkjs";

import type {
    GraphSnapshot,
    GraphNode,
    GraphEdge,
    EdgeKind,
} from "../schema/graph";

import type { NodePos, NodePositions } from "../schema/canvas-types";

/* ───────────────────────────── Options & Types ───────────────────────────── */

export type Direction = "RIGHT" | "LEFT" | "DOWN" | "UP";
export type EdgeRouting = "ORTHOGONAL" | "POLYLINE" | "SPLINES" | "UNDEFINED";

export interface AutoLayoutOptions {
    readonly treatZeroZeroAsUnplaced: boolean; // default true
    readonly direction: Direction; // default RIGHT
    readonly edgeRouting: EdgeRouting; // default ORTHOGONAL
    readonly nodeNodeSpacing: number; // default 56
    readonly nodeEdgeSpacing: number; // default 24
    readonly edgeEdgeSpacing: number; // default 16
    readonly componentSpacing: number; // default 64
    readonly padding: {
        readonly top: number;
        readonly right: number;
        readonly bottom: number;
        readonly left: number;
    }; // 48/64/48/64
    readonly commentOffset: { readonly dx: number; readonly dy: number }; // 24/16
}

export interface Size {
    readonly width: number;
    readonly height: number;
}
export type SizeEstimator = (node: GraphNode) => Size;

export interface EdgeRoutePoint {
    readonly x: number;
    readonly y: number;
}
export interface EdgeRoute {
    readonly id: string;
    readonly points: ReadonlyArray<EdgeRoutePoint>;
}

export interface RouteOptions {
    /** Filter which edges to route. Default: route all edges. */
    readonly routeFilter?: (edge: GraphEdge) => boolean;
}

/* ───────────────────────────── Defaults ───────────────────────────── */

const DEFAULT_OPTS: AutoLayoutOptions = {
    treatZeroZeroAsUnplaced: true,
    direction: "RIGHT",
    edgeRouting: "ORTHOGONAL",
    nodeNodeSpacing: 56,
    nodeEdgeSpacing: 24,
    edgeEdgeSpacing: 16,
    componentSpacing: 64,
    padding: { top: 48, right: 64, bottom: 48, left: 64 },
    commentOffset: { dx: 24, dy: 16 },
};

const DEFAULT_SIZE_OF: SizeEstimator = (n: GraphNode): Size => {
    const labelLen: number = Math.min(40, (n.label ?? "").length);
    const baseByKind: Record<GraphNode["kind"], Size> = {
        tag: { width: 220, height: 56 },
        field: { width: 260, height: 48 },
        comment: { width: 220, height: 96 },
        option: { width: 160, height: 40 },
    };
    const base: Size = baseByKind[n.kind] ?? { width: 200, height: 48 };
    const growth: number = 6 * labelLen + (n.kind === "field" ? 40 : 0);
    const optionHint: number =
        n.kind === "field" && /\b(choices|options|select|list)\b/i.test(n.label)
            ? 80
            : 0;

    return {
        width: base.width + growth + optionHint,
        height: base.height,
    };
};

/* ───────────────────────────── Public API ───────────────────────────── */

/**
 * Compute positions for all nodes, preserving already-placed ones (fixed)
 * and placing only previously-unplaced nodes via ELK.
 */
export async function computeAutoLayout(
    graph: GraphSnapshot,
    prev?: NodePositions,
    opts?: Partial<AutoLayoutOptions>,
    sizeOf?: SizeEstimator,
): Promise<NodePositions> {
    const { positions } = await computeAutoLayoutWithRoutes(
        graph,
        prev,
        opts,
        sizeOf,
    );
    return positions;
}

/**
 * Same as computeAutoLayout, but also extracts orthogonal edge routes (waypoints).
 */
export async function computeAutoLayoutWithRoutes(
    graph: GraphSnapshot,
    prev?: NodePositions,
    opts?: Partial<AutoLayoutOptions>,
    sizeOf?: SizeEstimator,
    routeOpts?: RouteOptions,
): Promise<{ positions: NodePositions; routes: EdgeRoute[] }> {
    const elk = new Elk();
    const options: AutoLayoutOptions = { ...DEFAULT_OPTS, ...(opts ?? {}) };
    const measure: SizeEstimator = sizeOf ?? DEFAULT_SIZE_OF;

    const prevPos: NodePositions = prev ?? {};
    const treat00: boolean = options.treatZeroZeroAsUnplaced;

    const isFixed = (id: string): boolean => {
        const p: NodePos | undefined = prevPos[id];
        if (!p) return false;
        return treat00 ? !(p.x === 0 && p.y === 0) : true;
    };

    // Build ELK nodes
    const elkChildren: ElkNode[] = graph.nodes.map((n: GraphNode): ElkNode => {
        const sz: Size = measure(n);
        const fixed: boolean = isFixed(n.id);
        const prevP: NodePos | undefined = prevPos[n.id];

        // Anchor seeding for comments: if comment → anchor(target) and target is fixed, seed near it
        const anchorTargetId: string | null = findAnchorTargetId(graph, n.id);
        const anchorPos: NodePos | undefined =
            anchorTargetId && isFixed(anchorTargetId)
                ? prevPos[anchorTargetId]
                : undefined;

        // Decide initial x/y
        const xSeed: number | undefined = fixed
            ? prevP?.x
            : anchorPos
              ? anchorPos.x + options.commentOffset.dx
              : undefined;
        const ySeed: number | undefined = fixed
            ? prevP?.y
            : anchorPos
              ? anchorPos.y + options.commentOffset.dy
              : undefined;

        const layoutOptions: Record<string, any> = {};
        if (fixed) {
            // Keep previously placed nodes untouched by layout
            layoutOptions["org.eclipse.elk.noLayout"] = true;
        }
        // If we seeded a comment near an anchor, freeze it for stability on this pass
        if (!fixed && n.kind === "comment" && anchorPos) {
            layoutOptions["org.eclipse.elk.noLayout"] = true;
        }

        return {
            id: n.id,
            width: Math.max(10, Math.round(sz.width)),
            height: Math.max(10, Math.round(sz.height)),
            x: xSeed,
            y: ySeed,
            layoutOptions,
        };
    });

    // Build ELK edges (all of them; routing will avoid noLayout nodes)
    const elkEdges: ElkExtendedEdge[] = graph.edges.map(
        (e: GraphEdge, i: number): ElkExtendedEdge => ({
            id: buildEdgeId(e, i),
            sources: [e.from],
            targets: [e.to],
        }),
    );

    // Root ELK graph
    const elkRoot: ElkNode = {
        id: "root",
        layoutOptions: rootLayoutOptions(options),
        children: elkChildren,
        edges: elkEdges,
    };

    const laidOut: ElkNode = await elk.layout(elkRoot, {
        layoutOptions: elkRoot.layoutOptions,
    });

    // Read positions from ELK
    const positions: NodePositions = {};
    for (const child of laidOut.children ?? []) {
        if (
            child.id &&
            typeof child.x === "number" &&
            typeof child.y === "number"
        ) {
            positions[child.id] = { x: child.x, y: child.y };
        }
    }

    // Merge: fixed nodes keep prev; unplaced take ELK coords (fallback to prev or 0,0)
    for (const n of graph.nodes) {
        const wasFixed: boolean = isFixed(n.id);
        const pPrev: NodePos | undefined = prevPos[n.id];
        const pElk: NodePos | undefined = positions[n.id];
        if (wasFixed) {
            positions[n.id] = pPrev ?? pElk ?? { x: 0, y: 0 };
        } else {
            positions[n.id] = pElk ?? pPrev ?? { x: 0, y: 0 };
        }
    }

    // Extract edge routes (waypoints)
    const routes: EdgeRoute[] = extractEdgeRoutes(laidOut, graph, routeOpts);

    return { positions, routes };
}

/** Merge two positions maps (optionally only for previously-unplaced nodes). */
export function mergePositions(
    prev: NodePositions | undefined,
    next: NodePositions,
    args?: {
        readonly onlyUnplaced?: boolean;
        readonly treatZeroZeroAsUnplaced?: boolean;
    },
): NodePositions {
    const onlyUnplaced: boolean = args?.onlyUnplaced ?? true;
    const treat00: boolean = args?.treatZeroZeroAsUnplaced ?? true;

    const out: NodePositions = { ...(prev ?? {}) };

    if (!onlyUnplaced) {
        for (const id of Object.keys(next)) out[id] = next[id];
        return out;
    }

    // Only overwrite when previous was missing/unplaced
    for (const id of Object.keys(next)) {
        const had: NodePos | undefined = prev?.[id];
        const wasUnplaced: boolean =
            !had || (treat00 ? had.x === 0 && had.y === 0 : false);
        if (wasUnplaced) out[id] = next[id];
    }
    return out;
}

/** IDs whose position changed from prev→next (helpful for fitView-on-new-nodes). */
export function placedIdsFrom(
    prev: NodePositions | undefined,
    next: NodePositions,
): string[] {
    const out: string[] = [];
    for (const id of Object.keys(next)) {
        const a: NodePos | undefined = prev?.[id];
        const b: NodePos = next[id];
        if (!a || a.x !== b.x || a.y !== b.y) out.push(id);
    }
    return out;
}

/* ───────────────────────────── Internals ───────────────────────────── */

function rootLayoutOptions(opts: AutoLayoutOptions): LayoutOptions {
    const lo: LayoutOptions = {
        "elk.algorithm": "layered",
        "elk.direction": opts.direction,
        // orthogonal routing gives right-angled bends
        "elk.edgeRouting": opts.edgeRouting,

        // Spacing / padding
        "elk.spacing.nodeNode": String(opts.nodeNodeSpacing),
        "elk.spacing.nodeNodeBetweenLayers": String(opts.nodeNodeSpacing),
        "elk.spacing.nodeEdge": String(opts.nodeEdgeSpacing),
        "elk.spacing.edgeEdge": String(opts.edgeEdgeSpacing),
        "elk.spacing.componentComponent": String(opts.componentSpacing),

        "elk.padding.top": String(opts.padding.top),
        "elk.padding.right": String(opts.padding.right),
        "elk.padding.bottom": String(opts.padding.bottom),
        "elk.padding.left": String(opts.padding.left),

        // Stability: keep model order where possible to reduce jitter
        "org.eclipse.elk.layered.considerModelOrder.strategy":
            "NODES_AND_EDGES",
    };
    return lo;
}

/** Find the *target* of an anchor edge whose source is `nodeId` (first found). */
function findAnchorTargetId(
    graph: GraphSnapshot,
    nodeId: string,
): string | null {
    const e: GraphEdge | undefined = graph.edges.find(
        (ed: GraphEdge) => ed.kind === "anchor" && ed.from === nodeId,
    );
    return e ? e.to : null;
}

function buildEdgeId(e: GraphEdge, i: number): string {
    // Deterministic id; include index to avoid accidental duplicates
    return `${e.from}→${e.to}:${e.kind}#${i}`;
}

/** Extracts orthogonal waypoints from ELK's layout result. */
function extractEdgeRoutes(
    root: ElkNode,
    graph: GraphSnapshot,
    routeOpts?: RouteOptions,
): EdgeRoute[] {
    const routes: EdgeRoute[] = [];
    const seen: Set<string> = new Set<string>();
    const allow: (edge: GraphEdge) => boolean =
        routeOpts?.routeFilter ?? (() => true);

    // Map from elk edge id back to GraphEdge (by index match)
    const elkIdForIndex: (idx: number) => string = (idx: number): string =>
        buildEdgeId(graph.edges[idx], idx);

    // Prefer edges on the root (elk usually places them there), but recurse defensively
    const stack: ElkNode[] = [root];
    while (stack.length) {
        const node: ElkNode = stack.pop() as ElkNode;

        if (node.edges) {
            node.edges.forEach((edge: any, idx: number) => {
                const elkEdgeId: string =
                    typeof edge.id === "string" ? edge.id : elkIdForIndex(idx);
                if (seen.has(elkEdgeId)) return;

                // Find corresponding GraphEdge (best-effort by id or by source/target match)
                const gEdge: GraphEdge | undefined = matchGraphEdge(
                    graph,
                    edge,
                );
                if (gEdge && !allow(gEdge)) return;

                const sections: any[] = Array.isArray(edge.sections)
                    ? edge.sections
                    : [];
                if (!sections.length) return;

                let segIndex = 0;
                for (const section of sections) {
                    const pts: EdgeRoutePoint[] = [];
                    if (section.startPoint)
                        pts.push({
                            x: section.startPoint.x,
                            y: section.startPoint.y,
                        });
                    if (Array.isArray(section.bendPoints)) {
                        for (const bp of section.bendPoints)
                            pts.push({ x: bp.x, y: bp.y });
                    }
                    if (section.endPoint)
                        pts.push({
                            x: section.endPoint.x,
                            y: section.endPoint.y,
                        });

                    if (pts.length >= 2) {
                        const rid: string =
                            segIndex === 0
                                ? elkEdgeId
                                : `${elkEdgeId}:${segIndex}`;
                        routes.push({ id: rid, points: pts });
                        seen.add(rid);
                        segIndex++;
                    }
                }
            });
        }

        if (node.children) {
            for (const c of node.children) stack.push(c);
        }
    }

    return routes;
}

/** Try to map an ELK edge back to a GraphEdge by (source,target,kind) where possible. */
function matchGraphEdge(
    graph: GraphSnapshot,
    elkEdge: any,
): GraphEdge | undefined {
    const from: string | undefined = Array.isArray(elkEdge.sources)
        ? elkEdge.sources[0]
        : undefined;
    const to: string | undefined = Array.isArray(elkEdge.targets)
        ? elkEdge.targets[0]
        : undefined;

    // Quick match by endpoints
    if (from && to) {
        const candidate: GraphEdge | undefined = graph.edges.find(
            (ge) => ge.from === from && ge.to === to,
        );
        if (candidate) return candidate;
    }
    // Fallback: if id embeds kind "…:kind#i", try to recover it
    if (typeof elkEdge.id === "string") {
        const m = elkEdge.id.match(
            /:(child|bind|include|exclude|error|anchor)#\d+$/,
        );
        if (m) {
            const k = m[1] as EdgeKind;
            const byKind = graph.edges.find(
                (ge) => ge.kind === k && ge.from === from && ge.to === to,
            );
            if (byKind) return byKind;
        }
    }
    return undefined;
}
```

---
#### 4


` File: src/utils/build-order-snapshot.ts`  [↑ Back to top](#index)

```ts
// src/utils/build-order-snapshot.ts

import type {
    OrderSnapshot,
    Scalar,
    UtilityLineItem,
    UtilityMode,
    QuantityRule,
    FallbackDiagnostics,
    ServiceFallbacks,
} from "../schema/order";
import type { ServiceProps, Field, FieldOption, Tag } from "../schema";
import type { Builder } from "../core";
import type { DgpServiceMap } from "../schema/provider";
import { isMultiField } from "./index";
import type { PruneResult } from "./prune-fallbacks";
import { pruneInvalidNodeFallbacks } from "./prune-fallbacks";
import type { FallbackSettings } from "../schema/validation";
import { constraintFitOk, rateOk } from "./util";

/* ───────────────────────── Public types ───────────────────────── */

export type BuildOrderSnapshotSettings = {
    mode?: "prod" | "dev";
    hostDefaultQuantity?: number;
    /** Full fallback policy */
    fallback?: FallbackSettings;
    workspaceId?: string;
    builderCommit?: string;
};

export type BuildOrderSelection = {
    /** Single active context (one tag) coming from Selection */
    activeTagId: string;
    /** Non-option inputs, keyed by fieldId (will be remapped to field.name in the payload) */
    formValuesByFieldId: Record<string, Scalar | Scalar[]>;
    /** Option selections, keyed by fieldId → optionId[] */
    optionSelectionsByFieldId: Record<string, string[]>;
    /**
     * Selection visit order for options (optional, improves "first option wins primary" determinism).
     * If omitted, iteration order falls back to Object.entries(optionSelectionsByFieldId).
     */
    optionTraversalOrder?: Array<{ fieldId: string; optionId: string }>;
};

/* ───────────────────────── Entry point ───────────────────────── */

export function buildOrderSnapshot(
    props: ServiceProps,
    builder: Builder,
    selection: BuildOrderSelection,
    services: DgpServiceMap,
    settings: BuildOrderSnapshotSettings = {},
): OrderSnapshot {
    const mode: "prod" | "dev" = settings.mode ?? "prod";
    const hostDefaultQty: number = Number.isFinite(
        settings.hostDefaultQuantity ?? 1,
    )
        ? (settings.hostDefaultQuantity as number)
        : 1;

    // Default fallback policy (strict in prod; diagnostics in dev)
    const fbSettings: FallbackSettings = {
        requireConstraintFit: true,
        ratePolicy: { kind: "lte_primary" },
        selectionStrategy: "priority",
        mode: mode === "dev" ? "dev" : "strict",
        ...(settings.fallback ?? {}),
    };

    const builtAt: string = new Date().toISOString();
    const tagId: string = selection.activeTagId;

    // 1) Resolve visible fields for the single context
    const selectedOptionKeys: string[] = toSelectedOptionKeys(
        selection.optionSelectionsByFieldId,
    );
    const visibleFieldIds: string[] = builder.visibleFields(
        tagId,
        selectedOptionKeys,
    );

    // Indexes
    const tagById: Map<string, Tag> = new Map(
        (props.filters ?? []).map((t) => [t.id, t]),
    );
    const fieldById: Map<string, Field> = new Map(
        (props.fields ?? []).map((f) => [f.id, f]),
    );
    const tagConstraints:
        | Partial<Record<"refill" | "cancel" | "dripfeed", boolean>>
        | undefined = tagById.get(tagId)?.constraints ?? undefined;

    // 2) Selection.fields (id, type, selectedOptions?)
    const selectionFields = visibleFieldIds
        .map((fid) => fieldById.get(fid))
        .filter((f): f is Field => !!f)
        .map((f) => {
            const optIds: string[] | undefined = isOptionBased(f)
                ? (selection.optionSelectionsByFieldId[f.id] ?? [])
                : undefined;
            return {
                id: f.id,
                type: String(f.type),
                ...(optIds && optIds.length ? { selectedOptions: optIds } : {}),
            };
        });

    // 3) Inputs (form by field.name, selections by fieldId)
    const { formValues, selections } = buildInputs(
        visibleFieldIds,
        fieldById,
        selection,
    );

    // 4) Quantity
    const qtyRes = resolveQuantity(
        visibleFieldIds,
        fieldById,
        selection,
        hostDefaultQty,
    );
    const quantity: number = qtyRes.quantity;
    const quantitySource = qtyRes.source;

    // 5) Services and serviceMap (UPDATED behavior: tag default is default; any option with service_id is included; first becomes primary)
    const { serviceMap, servicesList } = resolveServices(
        tagId,
        visibleFieldIds,
        selection,
        tagById,
        fieldById,
    );

    // 6) Fallbacks — client-side conservative prune (keeps only relevant-to-selection)
    const prunedFallbacks = pruneFallbacksConservative(
        props.fallbacks as unknown as ServiceFallbacks | undefined,
        { tagId, constraints: tagConstraints, serviceMap, servicesList },
        services,
        fbSettings,
    );

    // 7) Utilities — line items derived from utility fields/options
    const utilities = collectUtilityLineItems(
        visibleFieldIds,
        fieldById,
        selection,
        quantity,
    );

    // 8) Dev warnings (fallback diagnostics + form/utility hints)
    const warnings: OrderSnapshot["warnings"] | undefined =
        mode === "dev"
            ? buildDevWarnings(
                  props,
                  services,
                  tagId,
                  serviceMap,
                  prunedFallbacks.original,
                  prunedFallbacks.pruned,
                  fieldById,
                  visibleFieldIds,
                  selection,
              )
            : undefined;

    // 9) Meta.context (single-tag effective constraints + nodeContexts)
    const snapshotPolicy = toSnapshotPolicy(fbSettings);
    const meta = {
        schema_version: props.schema_version,
        workspaceId: settings.workspaceId,
        builder: settings.builderCommit
            ? { commit: settings.builderCommit }
            : undefined,
        context: {
            tag: tagId,
            constraints: (tagConstraints ?? {}) as Record<
                "refill" | "cancel" | "dripfeed",
                boolean | undefined
            >,
            nodeContexts: buildNodeContexts(
                tagId,
                visibleFieldIds,
                fieldById,
                selection,
            ),
            policy: snapshotPolicy,
        },
    };

    const snapshot: OrderSnapshot = {
        version: "1",
        mode,
        builtAt,
        selection: {
            tag: tagId,
            fields: selectionFields,
        },
        inputs: {
            form: formValues,
            selections,
        },
        quantity,
        quantitySource,
        services: servicesList,
        serviceMap,
        ...(prunedFallbacks.pruned
            ? { fallbacks: prunedFallbacks.pruned }
            : {}),
        ...(utilities.length ? { utilities } : {}),
        ...(warnings ? { warnings } : {}),
        meta,
    };

    return snapshot;
}

/* ───────────────────────── Helpers ───────────────────────── */

function isOptionBased(f: Field): boolean {
    const hasOptions: boolean =
        Array.isArray(f.options) && f.options.length > 0;
    return hasOptions || isMultiField(f);
}

function toSelectedOptionKeys(byField: Record<string, string[]>): string[] {
    const keys: string[] = [];
    for (const [fieldId, optionIds] of Object.entries(byField ?? {})) {
        for (const optId of optionIds ?? []) {
            keys.push(`${fieldId}::${optId}`);
        }
    }
    return keys;
}

function buildInputs(
    visibleFieldIds: string[],
    fieldById: Map<string, Field>,
    selection: BuildOrderSelection,
): {
    formValues: Record<string, Scalar | Scalar[]>;
    selections: Record<string, string[]>;
} {
    const formValues: Record<string, Scalar | Scalar[]> = {};
    const selections: Record<string, string[]> = {};

    for (const fid of visibleFieldIds) {
        const f: Field | undefined = fieldById.get(fid);
        if (!f) continue;

        const selOptIds: string[] | undefined =
            selection.optionSelectionsByFieldId[fid];
        if (selOptIds && selOptIds.length) {
            selections[fid] = [...selOptIds];
        }

        // Only non-option fields contribute to form values; key by field.name
        if (!isOptionBased(f)) {
            const name: string | undefined = f.name;
            const val: Scalar | Scalar[] | undefined =
                selection.formValuesByFieldId[fid];
            if (!name || val === undefined) continue;
            formValues[name] = val;
        }
    }

    return { formValues, selections };
}

/* ───────────────── Quantity ───────────────── */

function resolveQuantity(
    visibleFieldIds: string[],
    fieldById: Map<string, Field>,
    selection: BuildOrderSelection,
    hostDefault: number,
): { quantity: number; source: OrderSnapshot["quantitySource"] } {
    // Precedence:
    // 1) First visible field with a quantity rule -> evaluate
    // 2) (Future) tag/option defaults (not implemented yet)
    // 3) Host default
    for (const fid of visibleFieldIds) {
        const f: Field | undefined = fieldById.get(fid);
        if (!f) continue;
        const rule: QuantityRule | undefined = readQuantityRule(
            (f.meta as any)?.quantity,
        );
        if (!rule) continue;

        const raw: Scalar | Scalar[] | undefined =
            selection.formValuesByFieldId[fid];
        const evaluated = evaluateQuantityRule(rule, raw);
        if (Number.isFinite(evaluated) && (evaluated as number) > 0) {
            return {
                quantity: evaluated as number,
                source: { kind: "field", id: f.id, rule },
            };
        }
    }

    return {
        quantity: hostDefault,
        source: { kind: "default", defaultedFromHost: true },
    };
}

function readQuantityRule(v: unknown): QuantityRule | undefined {
    if (!v || typeof v !== "object") return undefined;
    const src = v as QuantityRule;
    if (
        src.valueBy !== "value" &&
        src.valueBy !== "length" &&
        src.valueBy !== "eval"
    )
        return undefined;
    const out: QuantityRule = { valueBy: src.valueBy };
    if (src.code && typeof src.code === "string") out.code = src.code;
    return out;
}

function evaluateQuantityRule(
    rule: QuantityRule,
    raw: Scalar | Scalar[] | undefined,
): number {
    switch (rule.valueBy) {
        case "value": {
            const n = Number(Array.isArray(raw) ? (raw as Scalar[])[0] : raw);
            return Number.isFinite(n) ? n : NaN;
        }
        case "length": {
            if (Array.isArray(raw)) return raw.length;
            if (typeof raw === "string") return raw.length;
            return NaN;
        }
        case "eval": {
            try {
                if (!rule.code || typeof rule.code !== "string") return NaN;
                // eslint-disable-next-line no-new-func
                const fn = new Function(
                    "value",
                    "values",
                    `return (function(){ ${rule.code}\n})()`,
                );
                const single = Array.isArray(raw) ? (raw as Scalar[])[0] : raw;
                const values = Array.isArray(raw)
                    ? (raw as Scalar[])
                    : raw !== undefined
                      ? [raw]
                      : [];
                const out = fn(single, values);
                const n = Number(out);
                return Number.isFinite(n) ? n : NaN;
            } catch {
                return NaN;
            }
        }
        default:
            return NaN;
    }
}

/* ───────────────── Services (UPDATED) ───────────────── */

function resolveServices(
    tagId: string,
    visibleFieldIds: string[],
    selection: BuildOrderSelection,
    tagById: Map<string, Tag>,
    fieldById: Map<string, Field>,
): {
    serviceMap: Record<string, Array<string | number>>;
    servicesList: Array<string | number>;
} {
    const serviceMap: Record<string, Array<string | number>> = {};
    const ordered: Array<string | number> = [];

    // 1) Tentative primary from tag default (if any) — default only.
    const tag = tagById.get(tagId);
    let primary: string | number | undefined;
    let primaryOrigin: "tag" | "option" | undefined;

    if (tag?.service_id !== undefined) {
        primary = tag.service_id;
        primaryOrigin = "tag";
        // We'll only record it in lists if it survives override.
    }

    // 2) Walk option selections in a deterministic order
    const optionVisit = buildOptionVisitOrder(selection, fieldById);

    for (const { fieldId, optionId } of optionVisit) {
        // only consider options whose field is visible in this group
        if (!visibleFieldIds.includes(fieldId)) continue;

        const f = fieldById.get(fieldId);
        if (!f || !Array.isArray(f.options)) continue;

        const opt = f.options.find((o) => o.id === optionId);
        if (!opt) continue;

        const role = (opt.pricing_role ?? "base") as
            | "base"
            | "utility"
            | string;
        const sid = opt.service_id;

        // Defensive: ignore if a (misconfigured) utility has service_id.
        if (role === "utility") continue;

        if (sid !== undefined) {
            // First option with service_id overrides tag default primary.
            if (primary === undefined || primaryOrigin === "tag") {
                primary = sid;
                primaryOrigin = "option";
                // Since primary owns index 0, push it first
                ordered.length = 0; // clear any tentative tag default
                ordered.push(primary);
            } else {
                // Additional option services append
                ordered.push(sid);
            }
            // Map origin node → sid
            pushService(serviceMap, optionId, sid);
        }
    }

    // 3) If no option established a primary, use tag default (if present)
    if (primaryOrigin !== "option" && primary !== undefined) {
        ordered.unshift(primary);
        pushService(serviceMap, tagId, primary);
    } else {
        // If overridden, we do NOT record tagId→default in serviceMap
    }

    const servicesList = dedupeByString(ordered);
    return { serviceMap, servicesList };
}

function buildOptionVisitOrder(
    selection: BuildOrderSelection,
    fieldById: Map<string, Field>,
): Array<{ fieldId: string; optionId: string }> {
    if (
        selection.optionTraversalOrder &&
        selection.optionTraversalOrder.length
    ) {
        return selection.optionTraversalOrder.slice();
    }
    // fallback: expand optionSelectionsByFieldId in insertion-ish order
    const out: Array<{ fieldId: string; optionId: string }> = [];
    for (const [fid, optIds] of Object.entries(
        selection.optionSelectionsByFieldId ?? {},
    )) {
        const f = fieldById.get(fid);
        if (!f) continue;
        for (const oid of optIds ?? [])
            out.push({ fieldId: fid, optionId: oid });
    }
    return out;
}

function pushService(
    map: Record<string, Array<string | number>>,
    nodeId: string,
    sid: string | number,
): void {
    if (!map[nodeId]) map[nodeId] = [];
    map[nodeId].push(sid);
}

function dedupeByString<T extends string | number>(arr: T[]): T[] {
    const s = new Set<string>();
    const out: T[] = [];
    for (const v of arr) {
        const key = String(v);
        if (s.has(key)) continue;
        s.add(key);
        out.push(v);
    }
    return out;
}

/* ───────────── Fallback pruning (client-conservative) ───────────── */

type PruneEnv = {
    tagId: string;
    constraints?: Partial<Record<"refill" | "cancel" | "dripfeed", boolean>>;
    serviceMap: Record<string, Array<string | number>>;
    servicesList: Array<string | number>;
};

function pruneFallbacksConservative(
    fallbacks: ServiceFallbacks | undefined,
    env: PruneEnv,
    svcMap: DgpServiceMap,
    policy: FallbackSettings,
): { pruned?: ServiceFallbacks; original?: ServiceFallbacks } {
    if (!fallbacks) return { pruned: undefined, original: undefined };

    // Prefer shared helper (keeps behavior consistent with tests)
    try {
        const { props: prunedProps }: PruneResult = pruneInvalidNodeFallbacks(
            {
                filters: [],
                fields: [],
                schema_version: "1.0",
                fallbacks,
            } as unknown as ServiceProps,
            svcMap,
            policy,
        );
        return {
            pruned: prunedProps.fallbacks as unknown as
                | ServiceFallbacks
                | undefined,
            original: fallbacks,
        };
    } catch {
        // Minimal inline conservative prune (selection-aware)
        const out: ServiceFallbacks = {};
        const requireFit: boolean = policy.requireConstraintFit ?? true;

        // Nodes: keep only for nodes present in env.serviceMap; apply rate & (optional) constraints against tag
        if ((fallbacks as any).nodes) {
            const keptNodes: Record<string, Array<string | number>> = {};
            for (const [nodeId, candidates] of Object.entries(
                (fallbacks as any).nodes as Record<
                    string,
                    Array<string | number>
                >,
            )) {
                if (!env.serviceMap[nodeId]) continue;
                const primary = (env.serviceMap[nodeId] ?? [])[0];
                const kept: Array<string | number> = [];
                for (const cand of candidates ?? []) {
                    if (!rateOk(svcMap, cand, primary, policy)) continue;
                    if (
                        requireFit &&
                        env.constraints &&
                        !constraintFitOk(svcMap, cand, env.constraints)
                    )
                        continue;
                    kept.push(cand);
                }
                if (kept.length) keptNodes[nodeId] = kept;
            }
            if (Object.keys(keptNodes).length) (out as any).nodes = keptNodes;
        }

        // Global: keep only primaries that are present in selection; apply rate & (optional) constraints
        if ((fallbacks as any).global) {
            const keptGlobal: Record<
                string | number,
                Array<string | number>
            > = {};
            const present = new Set(env.servicesList.map((sid) => String(sid)));
            for (const [primary, cands] of Object.entries(
                (fallbacks as any).global as Record<
                    string | number,
                    Array<string | number>
                >,
            )) {
                if (!present.has(String(primary))) continue;
                const primId: string | number = isFiniteNumber(primary)
                    ? Number(primary)
                    : (primary as any);
                const kept: Array<string | number> = [];
                for (const cand of cands ?? []) {
                    if (!rateOk(svcMap, cand, primId, policy)) continue;
                    if (
                        requireFit &&
                        env.constraints &&
                        !constraintFitOk(svcMap, cand, env.constraints)
                    )
                        continue;
                    kept.push(cand);
                }
                if (kept.length) keptGlobal[primId] = kept;
            }
            if (Object.keys(keptGlobal).length)
                (out as any).global = keptGlobal;
        }

        return {
            pruned: Object.keys(out).length ? out : undefined,
            original: fallbacks,
        };
    }
}

function isFiniteNumber(v: unknown): v is number {
    return typeof v === "number" && Number.isFinite(v);
}

/* ───────────────── Utilities collection ───────────────── */

type UtilityMarker = {
    mode: UtilityMode;
    rate: number;
    valueBy?: "value" | "length" | "eval";
    code?: string;
};

function collectUtilityLineItems(
    visibleFieldIds: string[],
    fieldById: Map<string, Field>,
    selection: BuildOrderSelection,
    quantity: number,
): UtilityLineItem[] {
    const items: UtilityLineItem[] = [];

    for (const fid of visibleFieldIds) {
        const f = fieldById.get(fid);
        if (!f) continue;

        const isUtilityField = (f.pricing_role ?? "base") === "utility";
        const marker = readUtilityMarker((f.meta as any)?.utility);

        // Field-based utility
        if (isUtilityField && marker) {
            const val: Scalar | Scalar[] | undefined =
                selection.formValuesByFieldId[f.id];
            const item = buildUtilityItemFromMarker(
                f.id,
                marker,
                quantity,
                val,
            );
            if (item) items.push(item);
        }

        // Option-based utility (only if selected)
        if (Array.isArray(f.options) && f.options.length) {
            const selectedOptIds =
                selection.optionSelectionsByFieldId[f.id] ?? [];
            if (selectedOptIds.length) {
                const optById = new Map<string, FieldOption>(
                    f.options.map((o) => [o.id, o]),
                );
                for (const oid of selectedOptIds) {
                    const opt = optById.get(oid);
                    if (!opt) continue;
                    if ((opt.pricing_role ?? "base") !== "utility") continue;
                    const om = readUtilityMarker((opt.meta as any)?.utility);
                    if (!om) continue;
                    // For per_value on options, we use the parent field's value as the base value
                    const parentVal: Scalar | Scalar[] | undefined =
                        selection.formValuesByFieldId[f.id];
                    const item = buildUtilityItemFromMarker(
                        opt.id,
                        om,
                        quantity,
                        parentVal,
                    );
                    if (item) items.push(item);
                }
            }
        }
    }

    return items;
}

function readUtilityMarker(v: unknown): UtilityMarker | undefined {
    if (!v || typeof v !== "object") return undefined;
    const src = v as UtilityMarker;
    if (!src.mode || typeof src.rate !== "number" || !Number.isFinite(src.rate))
        return undefined;
    if (
        src.mode !== "flat" &&
        src.mode !== "per_quantity" &&
        src.mode !== "per_value" &&
        src.mode !== "percent"
    )
        return undefined;
    const out: UtilityMarker = { mode: src.mode, rate: src.rate };
    if (
        src.valueBy === "value" ||
        src.valueBy === "length" ||
        src.valueBy === "eval"
    )
        out.valueBy = src.valueBy;
    if (src.code && typeof src.code === "string") out.code = src.code;
    return out;
}

function buildUtilityItemFromMarker(
    nodeId: string,
    marker: UtilityMarker,
    quantity: number,
    value: Scalar | Scalar[] | undefined,
): UtilityLineItem | undefined {
    const base: UtilityLineItem = {
        nodeId,
        mode: marker.mode,
        rate: marker.rate,
        inputs: { quantity },
    };
    if (marker.mode === "per_value") {
        base.inputs.valueBy = marker.valueBy ?? "value";
        if (marker.valueBy === "length") {
            base.inputs.value = Array.isArray(value)
                ? value.length
                : typeof value === "string"
                  ? value.length
                  : 0;
        } else if (marker.valueBy === "eval") {
            base.inputs.evalCodeUsed = true; // signal that client used eval
        } else {
            base.inputs.value = Array.isArray(value)
                ? (value[0] ?? null)
                : (value ?? null);
        }
    }
    return base;
}

/* ───────────────── meta.context helpers ──────────────── */

function buildNodeContexts(
    tagId: string,
    visibleFieldIds: string[],
    fieldById: Map<string, Field>,
    selection: BuildOrderSelection,
): Record<string, string | null> {
    const ctx: Record<string, string | null> = {};
    ctx[tagId] = tagId; // tag maps to itself

    for (const fid of visibleFieldIds) {
        const f = fieldById.get(fid);
        if (!f) continue;

        const binds = normalizeBindIds(f.bind_id);
        const applicable = binds.has(tagId);

        const selectedOptIds = selection.optionSelectionsByFieldId[fid] ?? [];
        for (const oid of selectedOptIds) {
            ctx[oid] = applicable ? tagId : null;
        }
    }

    return ctx;
}

function normalizeBindIds(bind: string | string[] | undefined): Set<string> {
    const out = new Set<string>();
    if (!bind) return out;
    if (Array.isArray(bind)) {
        for (const b of bind) if (b) out.add(String(b));
    } else {
        out.add(String(bind));
    }
    return out;
}

/* ───────────────── Dev warnings ───────────────── */

function buildDevWarnings(
    props: ServiceProps,
    svcMap: DgpServiceMap,
    _tagId: string,
    _snapshotServiceMap: Record<string, Array<string | number>>,
    originalFallbacks: ServiceFallbacks | undefined,
    _prunedFallbacks: ServiceFallbacks | undefined,
    fieldById: Map<string, Field>,
    visibleFieldIds: string[],
    selection: BuildOrderSelection,
): OrderSnapshot["warnings"] | undefined {
    const out: OrderSnapshot["warnings"] = {};

    // Fallback diagnostics (non-fatal). Call only if a global helper is present at runtime.
    const maybeCollectFailed:
        | ((
              p: ServiceProps,
              sm: DgpServiceMap,
              s: { mode: "dev" },
          ) => FallbackDiagnostics[])
        | undefined = (globalThis as any).collectFailedFallbacks;

    try {
        if (maybeCollectFailed && originalFallbacks) {
            const diags = maybeCollectFailed(
                {
                    ...props,
                    fallbacks: originalFallbacks,
                } as ServiceProps,
                svcMap,
                { mode: "dev" },
            );
            if (diags && diags.length) {
                out.fallbacks = diags;
            }
        }
    } catch {
        // ignore diagnostics failures in dev
    }

    // Utility/Form warnings: missing field.name while value present (only for non-option fields)
    const utilityWarnings: Array<{ nodeId: string; reason: string }> = [];
    for (const fid of visibleFieldIds) {
        const f = fieldById.get(fid);
        if (!f) continue;
        const hasVal = selection.formValuesByFieldId[fid] !== undefined;
        if (hasVal && !f.name && !isOptionBased(f)) {
            utilityWarnings.push({
                nodeId: fid,
                reason: "missing_field_name_for_form_value",
            });
        }
    }
    if (utilityWarnings.length) {
        (out as any).utility = utilityWarnings;
    }

    if (!(out as any).fallbacks && !(out as any).utility) return undefined;
    return out;
}

/* ───────────────── Mapping: internal settings → SnapshotContext.policy ───────────────── */

function toSnapshotPolicy(settings: FallbackSettings): {
    ratePolicy: { kind: "lte_primary" | "none"; thresholdPct?: number };
    requireConstraintFit: boolean;
} {
    const requireConstraintFit = settings.requireConstraintFit ?? true;
    const rp = settings.ratePolicy ?? { kind: "lte_primary" as const };

    // Map our richer rate policies to the wire-level policy your server expects
    switch (rp.kind) {
        case "lte_primary":
            return {
                ratePolicy: { kind: "lte_primary" },
                requireConstraintFit,
            };
        case "within_pct":
            return {
                ratePolicy: {
                    kind: "lte_primary",
                    thresholdPct: Math.max(0, rp.pct ?? 0),
                },
                requireConstraintFit,
            };
        case "at_least_pct_lower":
            // No direct encoding at wire-level; fall back to strict lte (server can still enforce stronger rule)
            return {
                ratePolicy: { kind: "lte_primary" },
                requireConstraintFit,
            };
        default:
            return {
                ratePolicy: { kind: "lte_primary" },
                requireConstraintFit,
            };
    }
}
```

---
#### 5


` File: src/utils/index.ts`  [↑ Back to top](#index)

```ts
import {Field} from "../schema";

/**
 * Heuristic: multi-select if type hints ('multiselect'|'checkbox') or meta.multi === true.
 * Hosts can rely on meta.multi if using custom type strings.
 */
export function isMultiField(f: Field): boolean {
    const t = (f.type || '').toLowerCase();
    const metaMulti = !!f.meta?.multi;
    return t === 'multiselect' || t === 'checkbox' || metaMulti;
}
```

---
#### 6


` File: src/utils/prune-fallbacks.ts`  [↑ Back to top](#index)

```ts
// src/utils/prune-fallbacks.ts
import type { ServiceProps, ServiceIdRef } from '../schema';
import type { DgpServiceMap } from '../schema/provider';
import type { FallbackSettings } from '../schema/validation';
import { collectFailedFallbacks } from '../core';

export type PrunedFallback = {
    nodeId: string;
    candidate: ServiceIdRef;
    reasons: string[];        // aggregated reasons that caused full-context failure
    contexts?: string[];      // tag contexts considered (for option nodes)
};

export type PruneResult = {
    props: ServiceProps;
    removed: PrunedFallback[];
};

/**
 * Remove node-scoped fallback candidates that fail in ALL relevant contexts.
 * - Tag node: single context (the tag itself)
 * - Option node: contexts = parent field's bind_id tags
 * - Global fallbacks are NEVER pruned here (soft by design)
 */
export function pruneInvalidNodeFallbacks(
    props: ServiceProps,
    services: DgpServiceMap,
    settings?: FallbackSettings
): PruneResult {
    const fb = props.fallbacks;
    if (!fb?.nodes || Object.keys(fb.nodes).length === 0) {
        return { props, removed: [] };
    }

    // 1) Build node → contexts (tag ids) and primary lookup
    const nodeContexts = new Map<string, string[]>();
    const nodePrimary = new Map<string, ServiceIdRef | undefined>();

    for (const nodeId of Object.keys(fb.nodes)) {
        const tag = props.filters.find(t => t.id === nodeId);
        if (tag) {
            nodeContexts.set(nodeId, [tag.id]);
            nodePrimary.set(nodeId, tag.service_id as any);
            continue;
        }
        // option node: locate parent field
        const field = props.fields.find(f => Array.isArray(f.options) && f.options.some(o => o.id === nodeId));
        if (field) {
            const contexts = toBindArray(field.bind_id);
            nodeContexts.set(nodeId, contexts);
            const opt = field.options!.find(o => o.id === nodeId)!;
            nodePrimary.set(nodeId, opt.service_id as any);
            continue;
        }
        // unknown node id → treat as no contexts & no primary
        nodeContexts.set(nodeId, []);
        nodePrimary.set(nodeId, undefined);
    }

    // 2) Gather diagnostics (per context). We use dev mode collection to get granular reasons.
    const diags = collectFailedFallbacks(props, services, { ...settings, mode: 'dev' });

    // 3) Decide which (nodeId, candidate) pairs fail in ALL contexts
    const failuresByPair = new Map<string, { reasons: Set<string>; contexts: Set<string> }>();
    const totalContextsByNode = new Map<string, number>();

    for (const [nodeId, ctxs] of nodeContexts.entries()) {
        totalContextsByNode.set(nodeId, Math.max(1, ctxs.length)); // at least 1 for tag/no-context cases
    }

    for (const d of diags) {
        if (d.scope !== 'node') continue;
        const key = `${d.nodeId}::${String(d.candidate)}`;
        let rec = failuresByPair.get(key);
        if (!rec) {
            rec = { reasons: new Set<string>(), contexts: new Set<string>() };
            failuresByPair.set(key, rec);
        }
        rec.reasons.add(d.reason);
        if (d.tagContext) rec.contexts.add(d.tagContext);
        // For node-level reasons not tied to a context, mark all contexts as failed by leaving contexts set empty;
        // we'll interpret empty-but-has-reasons as global failure later when totals == 1.
    }

    // 4) Build a pruned copy of fallbacks.nodes
    const prunedNodes: Record<string, ServiceIdRef[]> = {};
    const removed: PrunedFallback[] = [];

    for (const [nodeId, list] of Object.entries(fb.nodes)) {
        const contexts = nodeContexts.get(nodeId) ?? [];
        const totalContexts = Math.max(1, contexts.length);
        const keep: ServiceIdRef[] = [];

        for (const cand of list) {
            const key = `${nodeId}::${String(cand)}`;
            const rec = failuresByPair.get(key);

            // Not present in failures → keep
            if (!rec) {
                keep.push(cand);
                continue;
            }

            const failedContextsCount = rec.contexts.size > 0 ? rec.contexts.size : totalContexts;
            const failsAll = failedContextsCount >= totalContexts;

            if (failsAll) {
                removed.push({
                    nodeId,
                    candidate: cand,
                    reasons: Array.from(rec.reasons),
                    contexts: contexts.length ? contexts.slice() : undefined,
                });
            } else {
                keep.push(cand); // passes in at least one context
            }
        }

        if (keep.length) prunedNodes[nodeId] = keep;
    }

    const outProps: ServiceProps = {
        ...props,
        fallbacks: {
            ...(props.fallbacks?.global ? { global: props.fallbacks!.global } : {}),
            ...(Object.keys(prunedNodes).length ? { nodes: prunedNodes } : {}),
        }
    };

    return { props: outProps, removed };
}

/* ───────────────────────── helpers ───────────────────────── */

function toBindArray(bind: string | string[] | undefined): string[] {
    if (!bind) return [];
    return Array.isArray(bind) ? bind.slice() : [bind];
}
```

---
#### 7


` File: src/utils/retry-queue.ts`  [↑ Back to top](#index)

```ts
// noinspection JSIgnoredPromiseFromCall

export type RetryStatus = 'scheduled' | 'retrying' | 'succeeded' | 'failed' | 'cancelled';

export type RetryOptions = {
    enabled?: boolean;          // default true
    maxAttempts?: number;       // default 5
    baseDelayMs?: number;       // default 800
    maxDelayMs?: number;        // default 20_000
    jitter?: boolean;           // default true
    /** Run the first attempt immediately (no initial delay) */
    immediateFirst?: boolean;
};

export type RetryJob = {
    /** Stable id for de-duplication (e.g., "comments:create_thread:loc_abc") */
    id: string;
    /** Called on each attempt; return true to signal success, false/throw to retry */
    perform: (attempt: number) => Promise<boolean>;
    onStatus?: (status: RetryStatus, meta?: { attempt: number; nextDelayMs?: number; error?: unknown }) => void;
};

export class RetryQueue {
    private readonly opts: Required<RetryOptions>;
    private jobs = new Map<string, { job: RetryJob; attempt: number; timer?: any; cancelled?: boolean }>();
    private paused = false;

    constructor(opts: RetryOptions = {}) {
        this.opts = {
            enabled: opts.enabled ?? true,
            maxAttempts: opts.maxAttempts ?? 5,
            baseDelayMs: opts.baseDelayMs ?? 800,
            maxDelayMs: opts.maxDelayMs ?? 20_000,
            jitter: opts.jitter ?? true,
            immediateFirst: opts.immediateFirst ?? false,
        };
    }

    pause() {
        this.paused = true;
    }

    resume() {
        this.paused = false;
        this.flush();
    }

    /** Enqueue or no-op if a job with same id already exists */
    enqueue(job: RetryJob): boolean {
        if (!this.opts.enabled) return false;
        if (this.jobs.has(job.id)) return false;
        this.jobs.set(job.id, {job, attempt: 0});
        job.onStatus?.('scheduled', {attempt: 0});
        this.kick(job.id);
        return true;
    }

    /** Force retry now (resets backoff); returns false if not found */
    triggerNow(id: string): boolean {
        const rec = this.jobs.get(id);
        if (!rec) return false;
        if (rec.timer) clearTimeout(rec.timer);
        rec.timer = undefined;
        this.kick(id, true);
        return true;
    }

    cancel(id: string): boolean {
        const rec = this.jobs.get(id);
        if (!rec) return false;
        if (rec.timer) clearTimeout(rec.timer);
        rec.cancelled = true;
        rec.job.onStatus?.('cancelled', {attempt: rec.attempt});
        this.jobs.delete(id);
        return true;
    }

    pendingIds(): string[] {
        return Array.from(this.jobs.keys());
    }

    size(): number {
        return this.jobs.size;
    }

    isQueued(id: string): boolean {
        return this.jobs.has(id);
    }

    drain(): void {
        for (const [id, rec] of this.jobs.entries()) {
            if (rec.timer) clearTimeout(rec.timer);
            rec.cancelled = true;
            rec.job.onStatus?.('cancelled', {attempt: rec.attempt});
            this.jobs.delete(id);
        }
    }

    private flush() {
        for (const id of this.jobs.keys()) this.kick(id);
    }

    private delayFor(attempt: number): number {
        const {baseDelayMs, maxDelayMs, jitter} = this.opts;
        const exp = Math.min(maxDelayMs, baseDelayMs * Math.pow(2, Math.max(0, attempt - 1)));
        if (!jitter) return exp;
        const r = Math.random() * 0.4 + 0.8; // 0.8x .. 1.2x
        return Math.min(maxDelayMs, Math.floor(exp * r));
    }

    private async kick(id: string, immediate = false) {
        const rec = this.jobs.get(id);
        if (!rec || rec.cancelled) return;

        if (this.paused && !immediate) return;

        const attempt = rec.attempt + 1;
        const run = async () => {
            if (rec.cancelled) return;
            rec.job.onStatus?.('retrying', {attempt});
            try {
                const ok = await rec.job.perform(attempt);
                if (ok) {
                    rec.job.onStatus?.('succeeded', {attempt});
                    this.jobs.delete(id);
                    return;
                }
            } catch (err) {
                // fallthrough to schedule next
                rec.job.onStatus?.('failed', {attempt, error: err});
            }

            if (attempt >= this.opts.maxAttempts) {
                rec.job.onStatus?.('failed', {attempt});
                this.jobs.delete(id);
                return;
            }

            rec.attempt = attempt;
            const delay = this.delayFor(attempt);
            rec.job.onStatus?.('scheduled', {attempt, nextDelayMs: delay});
            rec.timer = setTimeout(() => this.kick(id), delay);
        };

        if (immediate) await run();
        else {
            // First attempt: respect immediateFirst option; otherwise, schedule immediately
            const delay = this.opts.immediateFirst && attempt === 1 ? 0 : this.delayFor(attempt);

            if (delay) {
                rec.job.onStatus?.('scheduled', {attempt: 0, nextDelayMs: delay});
                rec.timer = setTimeout(run, delay);
            } else {
                void run();
            }
        }
    }
}
```

---
#### 8


` File: src/utils/util.ts`  [↑ Back to top](#index)

```ts
import type { DgpServiceMap, DgpServiceCapability } from "../schema/provider";
import type { FallbackSettings } from "../schema/validation";

/**
 * Safely convert unknown to a finite number. Returns NaN if not finite.
 */
export function toFiniteNumber(v: unknown): number {
    const n = Number(v);
    return Number.isFinite(n) ? n : NaN;
}

/**
 * Check if a candidate service satisfies the active tag constraints.
 * Only flags explicitly set to true are treated as required.
 */
export function constraintFitOk(
    svcMap: DgpServiceMap,
    candidate: string | number,
    constraints: Partial<Record<"refill" | "cancel" | "dripfeed", boolean>>,
): boolean {
    const cap: DgpServiceCapability | undefined = svcMap[Number(candidate)];
    if (!cap) return false;

    if (constraints.dripfeed === true && !cap.dripfeed) return false;
    if (constraints.refill === true && !cap.refill) return false;
    return !(constraints.cancel === true && !cap.cancel);

}

/**
 * Evaluate candidate rate against primary according to the fallback rate policy.
 * If either service is missing or rates are not finite, returns false.
 */
export function rateOk(
    svcMap: DgpServiceMap,
    candidate: string | number,
    primary: string | number,
    policy: FallbackSettings,
): boolean {
    const cand = svcMap[Number(candidate)];
    const prim = svcMap[Number(primary)];
    if (!cand || !prim) return false;

    const cRate = toFiniteNumber(cand.rate);
    const pRate = toFiniteNumber(prim.rate);
    if (!Number.isFinite(cRate) || !Number.isFinite(pRate)) return false;

    const rp = policy.ratePolicy ?? { kind: "lte_primary" as const };
    switch (rp.kind) {
        case "lte_primary":
            return cRate <= pRate;
        case "within_pct": {
            const pct = Math.max(0, rp.pct ?? 0);
            return cRate <= pRate * (1 + pct / 100);
        }
        case "at_least_pct_lower": {
            const pct = Math.max(0, rp.pct ?? 0);
            return cRate <= pRate * (1 - pct / 100);
        }
        default:
            return false;
    }
}
```


---
*Generated with [Prodex](https://github.com/emxhive/prodex) — Codebase decoded.*
<!-- PRODEx v1.4.11 | 2026-01-20T14:32:20.260Z -->