*Generated by [Prodex](https://github.com/emxhive/prodex#readme)*
> Note for LLMs: `Lx-Ly` ranges refer to lines in this Prodex trace file, not the original source files. Index metadata is provided via the HTML comment markers in this section.

# Index
<!-- PRODEX_INDEX_RANGE: L8-L13 -->
<!-- PRODEX_FILE_COUNT: 6 -->
<!-- PRODEX_INDEX_LIST_START -->
- [src/react/inputs/__tests__/input-registery.spec.ts](#1)  L17-L86
- [src/react/inputs/form-context.tsx](#2)  L87-L240
- [src/react/inputs/provider.tsx](#3)  L241-L309
- [src/react/inputs/register-custom.ts](#4)  L310-L376
- [src/react/inputs/registry.ts](#5)  L377-L464
- [src/react/inputs/wrapper.tsx](#6)  L465-L706
<!-- PRODEX_INDEX_LIST_END -->

---
---
#### 1


` File: src/react/inputs/__tests__/input-registery.spec.ts`  [↑ Back to top](#index)

```ts
import {describe, it, expect} from 'vitest';
import React from 'react';
import {createInputRegistry, resolveInputDescriptor} from '../registry';
import type {InputDescriptor} from '../registry';

function StubA(_: Record<string, unknown>) { return React.createElement('div'); }
function StubB(_: Record<string, unknown>) { return React.createElement('div'); }

describe('InputRegistry variant resolution', () => {
    it('returns the default descriptor when variant not provided', () => {
        const registry = createInputRegistry();

        const defaultDesc: InputDescriptor = { Component: StubA, defaultProps: {foo: 1} };
        registry.register('custom:Rating', defaultDesc); // default variant

        const resolved = resolveInputDescriptor(registry, 'custom:Rating');
        expect(resolved).toBeDefined();
        expect(resolved?.Component).toBe(StubA);
        expect(resolved?.defaultProps).toEqual({foo: 1});
    });

    it('returns the specific variant when registered', () => {
        const registry = createInputRegistry();

        const defaultDesc: InputDescriptor = { Component: StubA };
        const compactDesc: InputDescriptor = { Component: StubB, defaultProps: {size: 'sm'} };

        registry.register('custom:Rating', defaultDesc);                 // default
        registry.register('custom:Rating', compactDesc, 'compact');      // variant

        // explicit variant
        const resolvedCompact = resolveInputDescriptor(registry, 'custom:Rating', 'compact');
        expect(resolvedCompact).toBeDefined();
        expect(resolvedCompact?.Component).toBe(StubB);
        expect(resolvedCompact?.defaultProps).toEqual({size: 'sm'});

        // unknown variant → falls back to default
        const resolvedUnknown = resolveInputDescriptor(registry, 'custom:Rating', 'unknown' as any);
        expect(resolvedUnknown).toBeDefined();
        expect(resolvedUnknown?.Component).toBe(StubA);
    });

    it('registerMany works and fallback-to-default still applies', () => {
        const registry = createInputRegistry();

        const entries = [
            { kind: 'custom:Rating', descriptor: { Component: StubA } },
            { kind: 'custom:Rating', descriptor: { Component: StubB, defaultProps: {size: 'xs'} }, variant: 'compact' },
        ];
        registry.registerMany(entries);

        // exact variant
        const v = resolveInputDescriptor(registry, 'custom:Rating', 'compact');
        expect(v?.Component).toBe(StubB);
        expect(v?.defaultProps).toEqual({size: 'xs'});

        // fallback to default
        const d = resolveInputDescriptor(registry, 'custom:Rating', 'nope' as any);
        expect(d?.Component).toBe(StubA);
    });
});
```

---
#### 2


` File: src/react/inputs/form-context.tsx`  [↑ Back to top](#index)

```tsx
import React, {
    createContext,
    useCallback,
    useContext,
    useMemo,
    useRef,
    useState,
} from "react";
import type { ReactNode } from "react";
import type { Scalar } from "../../schema/order";

export type FormSnapshot = {
    values: Record<string, Scalar | Scalar[]>;
    selections: Record<string, string[]>;
};

export type FormApi = {
    /** Scalar/array value by fieldId (non-option inputs) */
    get: (fieldId: string) => Scalar | Scalar[] | undefined;
    set: (fieldId: string, value: Scalar | Scalar[]) => void;

    /** Option selections by fieldId (array of optionIds) */
    getSelections: (fieldId: string) => string[];
    setSelections: (fieldId: string, optionIds: string[]) => void;
    toggleSelection: (fieldId: string, optionId: string) => void;

    /** Read-only snapshot for debugging */
    snapshot: () => FormSnapshot;

    /** Simple subscribe (re-render triggers) */
    subscribe: (fn: () => void) => () => void;
};

const FormCtx = createContext<FormApi | null>(null);

export function FormProvider({
    initial,
    children,
}: {
    initial?: Partial<FormSnapshot>;
    children: ReactNode;
}) {
    const [values, setValues] = useState<Record<string, Scalar | Scalar[]>>(
        initial?.values ?? {},
    );
    const [selections, setSelections] = useState<Record<string, string[]>>(
        initial?.selections ?? {},
    );
    const subsRef = useRef(new Set<() => void>());

    const publish = useCallback(() => {
        for (const fn of Array.from(subsRef.current)) {
            try {
                fn();
            } catch {
                /* noop */
            }
        }
    }, []);

    const api = useMemo<FormApi>(
        () => ({
            get: (fieldId) => values[fieldId],
            set: (fieldId, value) => {
                setValues((prev) => {
                    if (prev[fieldId] === value) return prev;
                    const next = { ...prev, [fieldId]: value };
                    return next;
                });
                publish();
            },

            getSelections: (fieldId) => selections[fieldId] ?? [],
            setSelections: (fieldId, optionIds) => {
                setSelections((prev) => {
                    const next = {
                        ...prev,
                        [fieldId]: Array.from(new Set(optionIds)),
                    };
                    return next;
                });
                publish();
            },
            toggleSelection: (fieldId, optionId) => {
                setSelections((prev) => {
                    const cur = new Set(prev[fieldId] ?? []);
                    if (cur.has(optionId)) cur.delete(optionId);
                    else cur.add(optionId);
                    return { ...prev, [fieldId]: Array.from(cur) };
                });
                publish();
            },

            snapshot: () => ({
                values: { ...values },
                selections: { ...selections },
            }),

            subscribe: (fn) => {
                subsRef.current.add(fn);
                return () => subsRef.current.delete(fn);
            },
        }),
        [publish, selections, values],
    );

    return <FormCtx.Provider value={api}>{children}</FormCtx.Provider>;
}

/** Strict hook (throws if no provider) */
export function useFormApi(): FormApi {
    const ctx = useContext(FormCtx);
    if (!ctx) throw new Error("useFormApi must be used within <FormProvider>");
    return ctx;
}

/** Optional hook (returns null if no provider) */
export function useOptionalFormApi(): FormApi | null {
    return useContext(FormCtx);
}

/** Field-scoped helpers */

export function useFormField(fieldId: string): {
    value: Scalar | Scalar[] | undefined;
    set: (value: Scalar | Scalar[]) => void;
} {
    const api = useFormApi();
    const value = api.get(fieldId);
    const set = (v: Scalar | Scalar[]) => api.set(fieldId, v);
    return { value, set };
}

export function useFormSelections(fieldId: string): {
    selected: string[];
    set: (optionIds: string[]) => void;
    toggle: (optionId: string) => void;
} {
    const api = useFormApi();
    return {
        selected: api.getSelections(fieldId),
        set: (arr: string[]) => api.setSelections(fieldId, arr),
        toggle: (oid: string) => api.toggleSelection(fieldId, oid),
    };
}
```

---
#### 3


` File: src/react/inputs/provider.tsx`  [↑ Back to top](#index)

```tsx
import React, { createContext, useContext, useMemo } from "react";
import type { ReactNode } from "react";
import { createInputRegistry } from "./registry";
import type {
    Registry,
    InputDescriptor,
    InputKind,
    InputVariant,
} from "./registry";

type InputsCtxValue = {
    registry: Registry;
    register: (
        kind: InputKind,
        descriptor: InputDescriptor,
        variant?: InputVariant,
    ) => void;
    unregister: (kind: InputKind, variant?: InputVariant) => void;
    registerMany: (
        entries: Array<{
            kind: InputKind;
            descriptor: InputDescriptor;
            variant?: InputVariant;
        }>,
    ) => void;
};

const Ctx = createContext<InputsCtxValue | null>(null);

export function Provider({
    children,
    initialRegistry,
}: {
    children: ReactNode;
    /** Optional pre-built registry (e.g., you registered built-ins/customs before mounting) */
    initialRegistry?: Registry;
}) {
    const registry = useMemo(
        () => initialRegistry ?? createInputRegistry(),
        [initialRegistry],
    );

    const value = useMemo<InputsCtxValue>(
        () => ({
            registry,
            register: registry.register,
            unregister: registry.unregister,
            registerMany: registry.registerMany,
        }),
        [registry],
    );

    return <Ctx.Provider value={value}>{children}</Ctx.Provider>;
}

export function useInputs(): InputsCtxValue {
    const v = useContext(Ctx);
    if (!v) throw new Error("useInputs() must be used within <InputsProvider>");
    return v;
}
```

---
#### 4


` File: src/react/inputs/register-custom.ts`  [↑ Back to top](#index)

```ts
import type {Registry, InputDescriptor, InputKind, InputVariant, InputAdapter} from './registry';

const moduleCache = new Map<string, unknown>();

export type RegisterCustomOptions = {
    /** Full URL to the module (host-controlled & trusted) */
    url: string;
    /** Descriptor key; recommend prefixing with "custom:" e.g. "custom:Rating" */
    kind: InputKind;
    /** Optional variant; defaults to "default" */
    variant?: InputVariant;
    /** Which export to use; defaults to "default" */
    exportName?: string;
    /** Optional adapter + default props */
    adapter?: InputAdapter;
    defaultProps?: Record<string, unknown>;
};

/**
 * Dynamically imports a remote component and registers it in the input registry.
 * Call this client-side (e.g., inside useEffect) to avoid SSR pitfalls.
 */
export async function registerCustomFromUrl(
    registry: Registry,
    opts: RegisterCustomOptions
): Promise<void> {
    const {url, kind, variant, exportName = 'default', adapter, defaultProps} = opts;

    if (typeof window === 'undefined') {
        // No-op on server
        return;
    }

    let mod: any = moduleCache.get(url);
    if (!mod) {
        // Host must ensure origin trust/safety
        mod = await import(/* webpackIgnore: true */ url);
        moduleCache.set(url, mod);
    }

    const Component = mod?.[exportName];
    if (!Component) {
        // eslint-disable-next-line no-console
        console.warn(`[registerCustomFromUrl] Export "${exportName}" not found at ${url}`);
        return;
    }

    const descriptor: InputDescriptor = {Component, ...(adapter ? {adapter} : {}), ...(defaultProps ? {defaultProps} : {})};
    registry.register(kind, descriptor, variant);
}

/** Optional helper to pre-warm the cache (no registration) */
export async function preloadCustomModule(url: string): Promise<void> {
    if (moduleCache.has(url)) return;
    if (typeof window === 'undefined') return;
    const mod = await import(/* webpackIgnore: true */ url);
    moduleCache.set(url, mod);
}
```

---
#### 5


` File: src/react/inputs/registry.ts`  [↑ Back to top](#index)

```ts
import type React from 'react';
import type {Scalar} from '../../schema/order';

/** Matches your InputWrapper’s expectations */
export type InputKind = string;               // e.g. "text", "number", "select", "custom:Rating"
export type InputVariant = 'default' | (string & {});

export type InputAdapter = {
    /** Prop name where the value goes on the host component (default: "value") */
    valueProp?: string;
    /** Prop name of the change handler on the host component (default: "onChange") */
    changeProp?: string;
    /**
     * Normalize the host's change payload into a Scalar | Scalar[] your form will store.
     * If omitted, `next as Scalar | Scalar[]` is used.
     */
    getValue?: (next: unknown, prev: unknown) => Scalar | Scalar[];
};

export type InputDescriptor = {
    Component: React.ComponentType<Record<string, unknown>>;
    adapter?: InputAdapter;
    defaultProps?: Record<string, unknown>;
};

type VariantMap = Map<InputVariant, InputDescriptor>;
type RegistryStore = Map<InputKind, VariantMap>;

export type Registry = {
    get(kind: InputKind, variant?: InputVariant): InputDescriptor | undefined;
    register(kind: InputKind, descriptor: InputDescriptor, variant?: InputVariant): void;
    unregister(kind: InputKind, variant?: InputVariant): void;
    registerMany(entries: Array<{ kind: InputKind; descriptor: InputDescriptor; variant?: InputVariant }>): void;
    /** low-level escape hatch */
    _store: RegistryStore;
};

export function createInputRegistry(): Registry {
    const store: RegistryStore = new Map();

    const get = (kind: InputKind, variant?: InputVariant): InputDescriptor | undefined => {
        const vm = store.get(kind);
        if (!vm) return undefined;
        const v = (variant ?? 'default') as InputVariant;
        return vm.get(v) ?? vm.get('default');
    };

    const register = (kind: InputKind, descriptor: InputDescriptor, variant?: InputVariant): void => {
        let vm = store.get(kind);
        if (!vm) {
            vm = new Map<InputVariant, InputDescriptor>();
            store.set(kind, vm);
        }
        vm.set((variant ?? 'default') as InputVariant, descriptor);
    };

    const unregister = (kind: InputKind, variant?: InputVariant): void => {
        const vm = store.get(kind);
        if (!vm) return;
        const key = (variant ?? 'default') as InputVariant;
        vm.delete(key);
        if (vm.size === 0) store.delete(kind);
    };

    const registerMany = (entries: Array<{ kind: InputKind; descriptor: InputDescriptor; variant?: InputVariant }>): void => {
        for (const e of entries) register(e.kind, e.descriptor, e.variant);
    };

    return { get, register, unregister, registerMany, _store: store };
}

/** Helper used by InputWrapper */
export function resolveInputDescriptor(
    registry: Registry,
    kind: InputKind,
    variant?: InputVariant
): InputDescriptor | undefined {
    return registry.get(kind, variant);
}
```

---
#### 6


` File: src/react/inputs/wrapper.tsx`  [↑ Back to top](#index)

```tsx
import React, { useMemo } from "react";
import type {
    Field,
    FieldOption,
    UtilityMark,
    WithQuantityDefault,
} from "../../schema";
import type { ButtonValue, Scalar } from "../../schema/order";
import { useInputs } from "./provider";
import type { InputDescriptor, InputVariant, InputKind } from "./registry";
import { resolveInputDescriptor } from "./registry";
import { isMultiField } from "../../utils";
import { useOptionalFormApi } from "./FormContext";

export type InputWrapperProps = {
    field: Field;
    disabled?: boolean;
    /** Extra props to forward to the host component (low priority, overridden by adapter wiring). */
    extraProps?: Record<string, unknown>;
};

export type OnChangeValue = ButtonValue | ButtonValue[]; // multi-select allowed

function toKind(field: Field): InputKind {
    if (field.type === "custom") {
        const comp = (field.component ?? "").trim();
        return `custom:${comp}` as InputKind;
    }
    return field.type as InputKind;
}

function toVariant(field: Field): InputVariant | undefined {
    const v = (field as any).meta?.variant;
    return typeof v === "string" && v.trim() ? (v as InputVariant) : undefined;
}

export function Wrapper({
    field,
    disabled,
    extraProps,
}: InputWrapperProps) {
    const { registry } = useInputs();
    const form = useOptionalFormApi();

    const kind = toKind(field);
    const variant = toVariant(field);

    const descriptor: InputDescriptor | undefined = useMemo(
        () => resolveInputDescriptor(registry, kind, variant),
        [kind, registry, variant],
    );

    if (!descriptor) {
        // eslint-disable-next-line no-console
        console.warn("[InputWrapper] No descriptor for", {
            kind,
            variant,
            field,
        });
        return null;
    }

    const { Component, adapter, defaultProps } = descriptor;
    const valueProp = adapter?.valueProp ?? "value";
    const changeProp = adapter?.changeProp ?? "onChange";

    // Shape/intention
    const isOptionBased =
        Array.isArray(field.options) && field.options.length > 0;
    const multi = !!(isOptionBased && isMultiField(field));
    const isButton = field.button === true || isOptionBased;

    // Helpers
    const optionById = useMemo(() => {
        if (!isOptionBased) return new Map<string, FieldOption>();
        return new Map((field.options ?? []).map((o) => [o.id, o]));
    }, [isOptionBased, field.options]);

    const enrich = (bv: ButtonValue): ButtonValue => {
        // Option-based button → derive from option
        if (isOptionBased) {
            const opt = optionById.get(bv.id);
            if (opt) {
                const role = (opt.pricing_role ?? "base") as "base" | "utility";
                const sid = (opt as any).service_id as number | undefined;
                const meta = (opt.meta ?? field.meta) as
                    | (Record<string, unknown> &
                          UtilityMark &
                          WithQuantityDefault)
                    | undefined;

                // utility must not carry a service_id
                return {
                    ...bv,
                    pricing_role: role,
                    service_id: role === "utility" ? undefined : sid,
                    ...(meta ? { meta } : {}),
                };
            }
            // fallback: unknown option id → just return as-is
            return bv;
        }

        // Option-less button → derive from field
        const role = (field.pricing_role ?? "base") as "base" | "utility";
        const sid = (field as any).service_id as number | undefined;
        const meta = field.meta as
            | (Record<string, unknown> & UtilityMark & WithQuantityDefault)
            | undefined;

        return {
            ...bv,
            pricing_role: role,
            service_id: role === "utility" ? undefined : sid,
            ...(meta ? { meta } : {}),
        };
    };

    function normalizeToButtonValues(input: unknown): ButtonValue[] {
        const coerceOne = (v: unknown): ButtonValue | null => {
            if (v && typeof v === "object" && "id" in (v as any)) {
                const id = String((v as any).id);
                const valueRaw = (v as any).value;
                const value =
                    typeof valueRaw === "number" || typeof valueRaw === "string"
                        ? (valueRaw as number | string)
                        : 1; // default
                return enrich({ id, value });
            }
            // If host returned a primitive, assume it's the id; default value=1
            if (typeof v === "string" || typeof v === "number") {
                return enrich({ id: String(v), value: 1 });
            }
            return null;
        };

        if (Array.isArray(input)) {
            const arr: ButtonValue[] = [];
            for (const x of input) {
                const one = coerceOne(x);
                if (one) arr.push(one);
            }
            return arr;
        }
        const one = coerceOne(input);
        return one ? [one] : [];
    }

    // Current value bindings
    let current: Scalar | Scalar[] | undefined = undefined;
    let onChange: ((v: unknown) => void) | undefined = undefined;

    if (form) {
        if (isButton) {
            if (isOptionBased) {
                // For option buttons, current is the selected option ids (single or array)
                const selIds = form.getSelections(field.id);
                current = multi ? selIds : (selIds[0] ?? null);

                onChange = (next: unknown) => {
                    const normalized = adapter?.getValue
                        ? adapter.getValue(next, current)
                        : next;
                    const bvs = normalizeToButtonValues(normalized);
                    const ids = bvs.map((b) => b.id);

                    // Update selections with ids
                    form.setSelections(field.id, Array.from(new Set(ids)));

                    // Optionally store the value(s) for per_value utilities or quantity logic
                    const values = multi ? bvs : (bvs[0] ?? null);
                    form.set(field.id, values);
                };
            } else {
                // Option-less button (e.g., switch/checkbox acting as action button)
                // We keep a scalar "value" in form.values and maintain selection id presence for "active" state.
                const val = form.get(field.id);
                current = val;

                onChange = (next: unknown) => {
                    const normalized = adapter?.getValue
                        ? adapter.getValue(next, current)
                        : next;
                    const bvs = normalizeToButtonValues(normalized);
                    const first = bvs[0]; // single semantics for option-less button

                    // If host toggled "off", allow value = 0 or empty → clear selection
                    const active =
                        first &&
                        (typeof first.value === "number"
                            ? first.value !== 0
                            : String(first.value).length > 0);

                    if (active) {
                        form.setSelections(field.id, [field.id]);
                        form.set(field.id, first.value as Scalar);
                    } else {
                        form.setSelections(field.id, []);
                        form.set(field.id, null as unknown as Scalar);
                    }
                };
            }
        } else {
            // Non-button (plain input)
            current = form.get(field.id);
            onChange = (next: unknown) => {
                const normalized = adapter?.getValue
                    ? adapter.getValue(next, current)
                    : (next as Scalar | Scalar[]);
                form.set(field.id, normalized as Scalar | Scalar[]);
            };
        }
    }

    const hostProps: Record<string, unknown> = {
        id: field.id,
        field,
        disabled: !!disabled,
        ...(defaultProps ?? {}),
        ...(extraProps ?? {}),
        ...(isOptionBased ? { options: field.options as FieldOption[] } : {}),
    };

    if (form) {
        hostProps[valueProp] = current as unknown;
        hostProps[changeProp] = onChange as unknown;
    }

    return <Component {...hostProps} />;
}
```


---
*Generated with [Prodex](https://github.com/emxhive/prodex) — Codebase decoded.*
<!-- PRODEx v1.4.11 | 2026-01-20T14:32:20.260Z -->