*Generated by [Prodex](https://github.com/emxhive/prodex#readme)*
> Note for LLMs: `Lx-Ly` ranges refer to lines in this Prodex trace file, not the original source files. Index metadata is provided via the HTML comment markers in this section.

# Index
<!-- PRODEX_INDEX_RANGE: L8-L9 -->
<!-- PRODEX_FILE_COUNT: 2 -->
<!-- PRODEX_INDEX_LIST_START -->
- [src/react/hooks/order-flow-provider.tsx](#1)  L13-L163
- [src/react/hooks/use-order-flow.ts](#2)  L164-L508
<!-- PRODEX_INDEX_LIST_END -->

---
---
#### 1


` File: src/react/hooks/order-flow-provider.tsx`  [↑ Back to top](#index)

```tsx
// src/react/hooks/OrderFlowProvider.tsx
import React, {
    useRef,
    useImperativeHandle,
    useEffect,
    useState,
    forwardRef,
    createContext,
    useContext,
    ReactNode,
    useMemo,
} from 'react';

import type {Builder} from '../../core';
import type {Selection} from '../canvas/selection';

import {Provider} from '../inputs/provider';
import {Registry as InputRegistryConfig} from '../inputs/registry';

import {FormProvider, useFormApi} from '../inputs/FormContext';
import type {Scalar} from '../../schema/order';

/* ───────────────────────── Types ───────────────────────── */

export type UseOrderFlowInit = {
    /** Seed form values keyed by fieldId (non-option inputs) */
    initialFormByFieldId?: Record<string, Scalar | Scalar[]>;
    /** (optional) seed selections by fieldId → optionIds[] */
    initialSelectionsByFieldId?: Record<string, string[]>;
};

export type OrderFlowProviderProps = {
    /** Bring your own flow (no internal Selection!) */
    flow: { builder: Builder; selection: Selection };
    /** Host input registry (maps kind/variant → components) */
    registry?: InputRegistryConfig;
    /** Optional init (form + selections seeding) */
    init?: UseOrderFlowInit;
    children?: ReactNode;
};

export type OrderFlowHandle = {
    /** Current active tag id (or undefined) */
    getActiveTag: () => string | undefined;
    /** Select a tag context (single-context) */
    selectTag: (tagId: string) => void;
    /** Latest visible-group result from Selection */
    getVisibleGroup: () => ReturnType<Selection['visibleGroup']>;
    /** Access to Form API (e.g., set/get values programmatically) */
    getFormApi: () => ReturnType<typeof useFormApi> | undefined;
    /** Raw selection ids */
    getSelectionIds: () => string[];
    /** Clear selection */
    clearSelection: () => void;
    /** Force refresh of internal activeTag tracker */
    refresh: () => void;
};

/* ───────────────────────── Context ───────────────────────── */

type CtxShape = {
    builder: Builder;
    selection: Selection;
    activeTagId?: string;
    setActiveTag: (id: string) => void;
};

const OrderFlowCtx = createContext<CtxShape | null>(null);

export function useOrderFlowContext(): CtxShape {
    const ctx = useContext(OrderFlowCtx);
    if (!ctx) throw new Error('useOrderFlowContext must be used within <OrderFlowProvider>');
    return ctx;
}

/* ───────────────────────── Internals ───────────────────────── */

/** Captures the FormApi from inside FormProvider (no extra props required). */
function CaptureFormApi({assign}: { assign: (api: ReturnType<typeof useFormApi>) => void }) {
    const api = useFormApi();
    useEffect(() => assign(api), [api, assign]);
    return null;
}

/* ───────────────────────── Component ───────────────────────── */

export const OrderFlowProvider = forwardRef<OrderFlowHandle, OrderFlowProviderProps>(function OrderFlowProvider(
    {flow, registry, init, children},
    ref
) {
    const {builder, selection} = flow;

    // Track current active tag from the provided Selection instance
    const [activeTagId, setActiveTagId] = useState<string | undefined>(() => selection.currentTag());
    useEffect(() => selection.onChange(() => setActiveTagId(selection.currentTag())), [selection]);

    const setActiveTag = (id: string) => {
        selection.replace(id);
        setActiveTagId(id);
    };

    // Imperative API: we store the FormApi ref captured from inside the FormProvider
    const formApiRef = useRef<ReturnType<typeof useFormApi>>();

    useImperativeHandle(
        ref,
        (): OrderFlowHandle => ({
            getActiveTag: () => activeTagId,
            selectTag: (id: string) => setActiveTag(id),
            getVisibleGroup: () => selection.visibleGroup(),
            getFormApi: () => formApiRef.current,
            getSelectionIds: () => Array.from(selection.all()),
            clearSelection: () => selection.clear(),
            refresh: () => setActiveTagId(selection.currentTag()),
        }),
        [activeTagId, selection]
    );

    // Build initial snapshot for FormProvider (values + selections)
    const initialFormValues = useMemo(
        () => init?.initialFormByFieldId ?? {},
        [init?.initialFormByFieldId]
    );
    const initialSelections = useMemo(
        () => init?.initialSelectionsByFieldId ?? {},
        [init?.initialSelectionsByFieldId]
    );

    return (
        <Provider initialRegistry={registry}>
            <FormProvider initial={{values: initialFormValues, selections: initialSelections}}>
                {/* capture API once we are inside the provider */}
                <CaptureFormApi assign={(api) => {
                    formApiRef.current = api;
                }}/>
                <OrderFlowCtx.Provider value={{builder, selection, activeTagId, setActiveTag}}>
                    {children}
                </OrderFlowCtx.Provider>
            </FormProvider>
        </Provider>
    );
});
```

---
#### 2


` File: src/react/hooks/use-order-flow.ts`  [↑ Back to top](#index)

```ts
import {useCallback, useEffect, useMemo, useRef, useState} from 'react';

import type {Builder} from '../../core';
import type {ServiceProps, Field, Tag} from '../../schema';
import type {DgpServiceCapability, DgpServiceMap} from '../../schema/provider';
import type {OrderSnapshot, Scalar} from '../../schema/order';
import type {FallbackSettings} from '../../schema/validation';

import {Selection} from '../canvas/selection';
import {buildOrderSnapshot} from '../../utils/build-order-snapshot';
import {useOptionalFormApi} from '../inputs/FormContext';

/* ───────────────────────── public API ───────────────────────── */

export type UseOrderFlowInit = {
    mode?: 'prod' | 'dev';
    services: DgpServiceMap;
    fallback?: FallbackSettings;
    hydrateFrom?: OrderSnapshot;
    initialTagId?: string;
    hostDefaultQuantity?: number; // default 1
    resolveService?: (id: number | string) => DgpServiceCapability | undefined;
};

export type UseOrderFlowReturn = {
    activeTagId?: string;
    visibleFieldIds: string[];
    visibleFields: Field[];
    formValuesByFieldId: Record<string, Scalar | Scalar[]>;
    optionSelectionsByFieldId: Record<string, string[]>;
    quantityPreview: number;
    services: Array<string | number>;
    serviceMap: Record<string, Array<string | number>>;
    selectTag: (tagId: string) => void;
    toggleOption: (fieldId: string, optionId: string) => void;
    setValue: (fieldId: string, value: Scalar | Scalar[]) => void;
    clearField: (fieldId: string) => void;
    reset: () => void;
    buildSnapshot: () => OrderSnapshot;
    setFallbackPolicy: (next: FallbackSettings) => void;
};

/* ───────────────────────── implementation ───────────────────────── */

export function useOrderFlow(builder: Builder, init: UseOrderFlowInit): UseOrderFlowReturn {
    const mode: 'prod' | 'dev' = init.mode ?? 'prod';
    const hostDefaultQuantity: number = Number.isFinite(init.hostDefaultQuantity ?? 1)
        ? (init.hostDefaultQuantity as number)
        : 1;

    const propsRef = useRef<ServiceProps>(builder.getProps());
    useEffect(() => {
        propsRef.current = builder.getProps();
    });

    const [fallbackPolicy, setFallbackPolicy] = useState<FallbackSettings>(() => ({
        requireConstraintFit: true,
        ratePolicy: {kind: 'lte_primary'},
        selectionStrategy: 'priority',
        mode: mode === 'dev' ? 'dev' : 'strict',
        ...(init.fallback ?? {}),
    }));

    // Internal state (used only if no FormContext is present)
    const [formValuesByFieldId, setFormValuesByFieldId] = useState<Record<string, Scalar | Scalar[]>>({});
    const [optionSelectionsByFieldId, setOptionSelectionsByFieldId] = useState<Record<string, string[]>>({});

    // Optional Form Context (host-provided)
    const formApi = useOptionalFormApi();

    // Selection
    const selectionRef = useRef<Selection>();
    if (!selectionRef.current) {
        selectionRef.current = new Selection(builder, {
            env: 'client',
            rootTagId: 'root',
            resolveService: init.resolveService,
        });
    }
    const selection = selectionRef.current;

    // Default tag: hydrate → initial → root → first
    useEffect(() => {
        const props = propsRef.current;
        const tags = props.filters ?? [];

        const hydratedTag = init.hydrateFrom?.selection?.tag;
        const initialTag = init.hydrateFrom
            ? hydratedTag
            : (init.initialTagId ?? findDefaultTagId(tags));

        if (initialTag) {
            selection.replace(initialTag);
        } else if (tags.length) {
            selection.replace(tags[0].id);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    // Hydrate inputs (internal state only; FormContext has its own state)
    useEffect(() => {
        const snap = init.hydrateFrom;
        if (!snap) return;

        if (snap.inputs?.selections) setOptionSelectionsByFieldId(snap.inputs.selections);

        const byFieldId: Record<string, Scalar | Scalar[]> = {};
        if (snap.inputs?.form) {
            const fields = propsRef.current.fields ?? [];
            const nameToIds = new Map<string, string[]>();
            for (const f of fields) {
                if (!f.name) continue;
                const arr = nameToIds.get(f.name) ?? [];
                arr.push(f.id);
                nameToIds.set(f.name, arr);
            }
            for (const [name, value] of Object.entries(snap.inputs.form)) {
                for (const fid of (nameToIds.get(name) ?? [])) byFieldId[fid] = value as Scalar | Scalar[];
            }
        }
        setFormValuesByFieldId(byFieldId);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    // Track active tag
    const [activeTagId, setActiveTagId] = useState<string | undefined>(() => selection.currentTag());
    useEffect(() => {
        return selection.onChange(() => {
            setActiveTagId(selection.currentTag());
        });
    }, [selection]);

    // Selected option keys from internal state (used if no FormContext)
    const selectedOptionKeys: string[] = useMemo(() => {
        const keys: string[] = [];
        for (const [fid, oids] of Object.entries(optionSelectionsByFieldId)) {
            for (const oid of oids) keys.push(`${fid}::${oid}`);
        }
        return keys;
    }, [optionSelectionsByFieldId]);

    // Visible fields
    const {visibleFieldIds, visibleFields} = useMemo(() => {
        const tag = activeTagId;
        if (!tag) return {visibleFieldIds: [] as string[], visibleFields: [] as Field[]};

        const fallbackSelectionKeys = selectedOptionKeys;
        const ids = builder.visibleFields(tag, fallbackSelectionKeys);
        const byId = new Map((propsRef.current.fields ?? []).map(f => [f.id, f] as const));
        const fields = ids.map(id => byId.get(id)).filter((f): f is Field => !!f);
        return {visibleFieldIds: ids, visibleFields: fields};
    }, [builder, activeTagId, selectedOptionKeys]);

    // Merge values/selections: FormContext (if present) takes precedence for visible fields
    const effectiveMaps = useMemo(() => {
        const visible = new Set(visibleFieldIds);

        const fromFormValues: Record<string, Scalar | Scalar[]> = {};
        const fromFormSelections: Record<string, string[]> = {};

        if (formApi) {
            for (const fid of visible) {
                const v = formApi.get(fid);
                if (v !== undefined) fromFormValues[fid] = v;
                const sel = formApi.getSelections(fid);
                if (sel && sel.length) fromFormSelections[fid] = sel.slice();
            }
        }

        // fall back to internal state for fields that that are not present in formApi
        const mergedValues: Record<string, Scalar | Scalar[]> = {...formValuesByFieldId};
        for (const [fid, v] of Object.entries(fromFormValues)) mergedValues[fid] = v;

        const mergedSelections: Record<string, string[]> = {...optionSelectionsByFieldId};
        for (const [fid, arr] of Object.entries(fromFormSelections)) mergedSelections[fid] = arr;

        return {formValuesByFieldId: mergedValues, optionSelectionsByFieldId: mergedSelections};
    }, [formApi, formValuesByFieldId, optionSelectionsByFieldId, visibleFieldIds]);

    // Live preview snapshot (uses effectiveMaps)
    const previewSnapshot: OrderSnapshot = useMemo(() => {
        if (!activeTagId) {
            return {
                version: '1',
                mode,
                builtAt: new Date().toISOString(),
                selection: {tag: 'unknown', fields: []},
                inputs: {form: {}, selections: {}},
                quantity: Number(init.hostDefaultQuantity ?? 1) || 1,
                quantitySource: {kind: 'default', defaultedFromHost: true},
                services: [],
                serviceMap: {},
                meta: {
                    schema_version: propsRef.current.schema_version,
                    context: {
                        tag: 'unknown',
                        constraints: {},
                        nodeContexts: {},
                        policy: {ratePolicy: {kind: 'lte_primary'}, requireConstraintFit: true},
                    },
                },
            };
        }

        return buildOrderSnapshot(
            propsRef.current,
            builder,
            {
                activeTagId,
                formValuesByFieldId: effectiveMaps.formValuesByFieldId,
                optionSelectionsByFieldId: effectiveMaps.optionSelectionsByFieldId,
            },
            init.services,
            {
                mode,
                hostDefaultQuantity,
                fallback: fallbackPolicy,
            },
        );
    }, [activeTagId, builder, effectiveMaps.formValuesByFieldId, effectiveMaps.optionSelectionsByFieldId, fallbackPolicy, hostDefaultQuantity, init.services, mode]);

    /* ───────────────────────── mutators ───────────────────────── */

    const selectTag = useCallback((tagId: string) => {
        selection.replace(tagId);
    }, [selection]);

    const toggleOption = useCallback((fieldId: string, optionId: string) => {
        // If a FormContext exists, prefer using it; otherwise internal state
        if (formApi) {
            formApi.toggleSelection(fieldId, optionId);
            return;
        }
        setOptionSelectionsByFieldId(prev => {
            const cur = new Set(prev[fieldId] ?? []);
            if (cur.has(optionId)) cur.delete(optionId); else cur.add(optionId);
            return {...prev, [fieldId]: Array.from(cur)};
        });
    }, [formApi]);

    const setValue = useCallback((fieldId: string, value: Scalar | Scalar[]) => {
        if (formApi) {
            formApi.set(fieldId, value);
            return;
        }
        setFormValuesByFieldId(prev => ({...prev, [fieldId]: value}));
    }, [formApi]);

    const clearField = useCallback((fieldId: string) => {
        if (formApi) {
            formApi.set(fieldId, undefined as unknown as Scalar); // effectively clears
            formApi.setSelections(fieldId, []);
            return;
        }
        setFormValuesByFieldId(prev => {
            const next = {...prev};
            delete next[fieldId];
            return next;
        });
        setOptionSelectionsByFieldId(prev => {
            const next = {...prev};
            delete next[fieldId];
            return next;
        });
    }, [formApi]);

    const reset = useCallback(() => {
        const tags = propsRef.current.filters ?? [];
        const defaultTag = findDefaultTagId(tags) ?? tags[0]?.id;
        if (defaultTag) selection.replace(defaultTag);
        if (formApi) {
            // clear all known visible fields
            for (const fid of visibleFieldIds) {
                formApi.set(fid, undefined as unknown as Scalar);
                formApi.setSelections(fid, []);
            }
        } else {
            setFormValuesByFieldId({});
            setOptionSelectionsByFieldId({});
        }
    }, [formApi, selection, visibleFieldIds]);

    const buildSnapshot = useCallback((): OrderSnapshot => {
        const tagId = selection.currentTag();
        if (!tagId) throw new Error('OrderFlow: no active tag/context selected');

        return buildOrderSnapshot(
            propsRef.current,
            builder,
            {
                activeTagId: tagId,
                formValuesByFieldId: effectiveMaps.formValuesByFieldId,
                optionSelectionsByFieldId: effectiveMaps.optionSelectionsByFieldId,
            },
            init.services,
            {
                mode,
                hostDefaultQuantity,
                fallback: fallbackPolicy,
            },
        );
    }, [builder, effectiveMaps.formValuesByFieldId, effectiveMaps.optionSelectionsByFieldId, fallbackPolicy, hostDefaultQuantity, init.services, mode, selection]);

    /* ───────────────────────── return ───────────────────────── */

    return {
        activeTagId,
        visibleFieldIds,
        visibleFields,
        formValuesByFieldId: effectiveMaps.formValuesByFieldId,
        optionSelectionsByFieldId: effectiveMaps.optionSelectionsByFieldId,
        quantityPreview: previewSnapshot.quantity,
        services: previewSnapshot.services,
        serviceMap: previewSnapshot.serviceMap,

        selectTag,
        toggleOption,
        setValue,
        clearField,
        reset,

        buildSnapshot,
        setFallbackPolicy,
    };
}

/* ───────────────────────── helpers ───────────────────────── */

function findDefaultTagId(tags: Tag[]): string | undefined {
    if (!tags || !tags.length) return undefined;
    const hasRoot = tags.find(t => t.id === 'root');
    return hasRoot ? 'root' : tags[0].id;
}
```


---
*Generated with [Prodex](https://github.com/emxhive/prodex) — Codebase decoded.*
<!-- PRODEx v1.4.11 | 2026-01-20T14:32:20.260Z -->