*Generated by [Prodex](https://github.com/emxhive/prodex#readme)*
> Note for LLMs: `Lx-Ly` ranges refer to lines in this Prodex trace file, not the original source files. Index metadata is provided via the HTML comment markers in this section.

# Index
<!-- PRODEX_INDEX_RANGE: L8-L17 -->
<!-- PRODEX_FILE_COUNT: 10 -->
<!-- PRODEX_INDEX_LIST_START -->
- [src/react/canvas/__tests__/editor.quantity-rule.spec.ts](#1)  L21-L106
- [src/react/canvas/__tests__/editor.service-filter.spec.ts](#2)  L107-L345
- [src/react/canvas/__tests__/editor.utility-guard.spec.ts](#3)  L346-L440
- [src/react/canvas/__tests__/selection.test.ts](#4)  L441-L594
- [src/react/canvas/api.ts](#5)  L595-L886
- [src/react/canvas/backend.ts](#6)  L887-L969
- [src/react/canvas/comments.ts](#7)  L970-L1459
- [src/react/canvas/editor.ts](#8)  L1460-L3590
- [src/react/canvas/events.ts](#9)  L3591-L3635
- [src/react/canvas/selection.ts](#10)  L3636-L4048
<!-- PRODEX_INDEX_LIST_END -->

---
---
#### 1


` File: src/react/canvas/__tests__/editor.quantity-rule.spec.ts`  [↑ Back to top](#index)

```ts
// src/canvas/__tests__/editor.quantity-rule.spec.ts
import {describe, it, expect} from 'vitest';
import {createBuilder} from "../../../core";
import {CanvasAPI} from "../api";

function baseProps() {
    return {
        schema_version: '1.0',
        filters: [{ id: 'root', label: 'Root' }],
        fields: [
            { id: 'f:text', type: 'text', bind_id: 'root', label: 'Qty Source' },
        ],
    };
}

describe('Editor field quantity rule helpers', () => {
    it('set/get/clear meta.quantity and undo/redo', () => {
        const b = createBuilder();
        b.load(baseProps());

        const api = new CanvasAPI(b, { autoEmitState: false });
        const { editor } = api;

        // initially none
        expect(editor.getFieldQuantityRule('f:text')).toBeUndefined();

        // set eval rule
        editor.setFieldQuantityRule('f:text', {
            valueBy: 'eval',
            code: 'return (Array.isArray(values) ? values.length : (value ? 1 : 0)) * 3;',
        });

        let props = b.getProps();
        expect((props.fields[0] as any).meta?.quantity).toEqual({
            valueBy: 'eval',
            code: 'return (Array.isArray(values) ? values.length : (value ? 1 : 0)) * 3;',
        });
        expect(editor.getFieldQuantityRule('f:text')).toEqual({
            valueBy: 'eval',
            code: 'return (Array.isArray(values) ? values.length : (value ? 1 : 0)) * 3;',
        });

        // clear via helper
        editor.clearFieldQuantityRule('f:text');
        props = b.getProps();
        expect((props.fields[0] as any).meta).toBeUndefined();
        expect(editor.getFieldQuantityRule('f:text')).toBeUndefined();

        // undo → rule back
        editor.undo();
        props = b.getProps();
        expect((props.fields[0] as any).meta?.quantity?.valueBy).toBe('eval');

        // redo → cleared again
        editor.redo();
        props = b.getProps();
        expect((props.fields[0] as any).meta).toBeUndefined();
    });

    it('normalizes rule (drops invalid shapes)', () => {
        const b = createBuilder();
        b.load(baseProps());

        const api = new CanvasAPI(b, { autoEmitState: false });
        const { editor } = api;

        // invalid valueBy should be ignored → nothing set
        editor.setFieldQuantityRule('f:text', { valueBy: 'weird' });
        let props = b.getProps();
        expect((props.fields[0] as any).meta).toBeUndefined();

        // valid non-eval drops code
        editor.setFieldQuantityRule('f:text', { valueBy: 'length', code: 'ignored' });
        props = b.getProps();
        expect((props.fields[0] as any).meta?.quantity).toEqual({ valueBy: 'length' });
    });
});
```

---
#### 2


` File: src/react/canvas/__tests__/editor.service-filter.spec.ts`  [↑ Back to top](#index)

```ts
import { describe, it, expect } from "vitest";
import { createBuilder } from "../../../core";
import { CanvasAPI } from "../api";
import type { ServiceProps } from "../../../schema";
import type { DgpServiceMap } from "../../../schema/provider";
import type { FallbackSettings } from "../../../schema/validation";

function baseProps(): ServiceProps {
    return {
        schema_version: "1.0",
        filters: [{ id: "root", label: "Root" }],
        fields: [],
    };
}

const serviceMap: DgpServiceMap = {
    // primary used in tests
    100: {
        id: 100,
        rate: 10,
        dripfeed: true,
        refill: true,
        cancel: true,
        platform_id: "p1",
        handler_id: "h1",
    },

    // already-used (to verify exclusion)
    101: {
        id: 101,
        rate: 12,
        dripfeed: true,
        refill: true,
        cancel: true,
        platform_id: "p1",
        handler_id: "h1",
    },

    // cheaper than primary → passes rate
    102: {
        id: 102,
        rate: 8,
        dripfeed: true,
        refill: false,
        cancel: true,
        platform_id: "p1",
        handler_id: "h1",
    },

    // fails constraint (dripfeed false when tag requires true)
    103: {
        id: 103,
        rate: 9,
        dripfeed: false,
        refill: true,
        cancel: true,
        platform_id: "p1",
        handler_id: "h1",
    },

    // more expensive than primary → fails lte_primary
    104: {
        id: 104,
        rate: 15,
        dripfeed: true,
        refill: true,
        cancel: true,
        platform_id: "p1",
        handler_id: "h1",
    },

    // different platform to trigger a policy failure (no_mix platform_id)
    201: {
        id: 201,
        rate: 9,
        dripfeed: true,
        refill: true,
        cancel: true,
        platform_id: "p2",
        handler_id: "h1",
    },

    // same platform as primary → OK for no_mix(platform_id)
    202: {
        id: 202,
        rate: 9,
        dripfeed: true,
        refill: true,
        cancel: true,
        platform_id: "p1",
        handler_id: "h2",
    },
};

describe("Editor.filterServicesForVisibleGroup", () => {
    it("excludes already-used, checks constraints + rate + policies", () => {
        const b = createBuilder({ serviceMap });
        b.load(baseProps());

        const api = new CanvasAPI(b, { autoEmitState: false });
        const { editor } = api;

        const tagId = "root";
        const usedServiceIds = [100, 101]; // 101 also in candidates → excluded
        const effectiveConstraints = { dripfeed: true }; // require dripfeed:true
        const policies = [
            {
                id: "no_mix_platform",
                scope: "visible_group",
                subject: "services",
                op: "no_mix",
                projection: "service.platform_id",
                severity: "error",
            },
        ];

        const candidates = [101, 102, 103, 104, 201, 202];

        const checks = editor.filterServicesForVisibleGroup(candidates, {
            tagId,
            usedServiceIds,
            effectiveConstraints,
            policies,
            fallback: {
                ratePolicy: { kind: "lte_primary" },
            } as FallbackSettings,
        });

        const byId = new Map(checks.map((c) => [String(c.id), c]));

        // 101: excluded (already used)
        expect(byId.has("101")).toBe(false);

        // 102: cheaper, dripfeed true, same platform → OK
        const c102 = byId.get("102")!;
        expect(c102.ok).toBe(true);
        expect(c102.fitsConstraints).toBe(true);
        expect(c102.passesRate).toBe(true);
        expect(c102.passesPolicies).toBe(true);
        expect(c102.reasons).toEqual([]);

        // 103: fails constraint
        const c103 = byId.get("103")!;
        expect(c103.ok).toBe(false);
        expect(c103.fitsConstraints).toBe(false);
        expect(c103.reasons).toContain("constraint_mismatch");

        // 104: fails rate policy
        const c104 = byId.get("104")!;
        expect(c104.ok).toBe(false);
        expect(c104.passesRate).toBe(false);
        expect(c104.reasons).toContain("rate_policy");

        // 201: policy failure (no_mix platform with p2 against used p1)
        const c201 = byId.get("201")!;
        expect(c201.ok).toBe(false);
        expect(c201.passesPolicies).toBe(false);
        expect(c201.policyErrors).toContain("no_mix_platform");
        expect(c201.reasons).toContain("policy_error");

        // 202: same platform as primary → passes policy
        const c202 = byId.get("202")!;
        expect(c202.ok).toBe(true);
        expect(c202.passesPolicies).toBe(true);
    });

    it("passes rate by default when there is no primary (empty usedServiceIds)", () => {
        const b = createBuilder({ serviceMap });
        b.load(baseProps());

        const api = new CanvasAPI(b, { autoEmitState: false });
        const { editor } = api;

        const checks = editor.filterServicesForVisibleGroup([104], {
            tagId: "root",
            usedServiceIds: [], // no primary → rate check defaults to true
            effectiveConstraints: {},
            policies: [],
            fallback: { ratePolicy: { kind: "lte_primary" } },
        });

        expect(checks).toHaveLength(1);
        expect(checks[0].id).toBe(104);
        expect(checks[0].passesRate).toBe(true);
    });

    it("respects ratePolicy variants (at_least_pct_lower)", () => {
        const b = createBuilder({ serviceMap });
        b.load(baseProps());

        const api = new CanvasAPI(b, { autoEmitState: false });
        const { editor } = api;

        // primary 100 → rate 10; require at least 20% lower → candidate must be <= 8
        const checks = editor.filterServicesForVisibleGroup([102, 103, 104], {
            tagId: "root",
            usedServiceIds: [100],
            effectiveConstraints: {},
            policies: [],
            fallback: { ratePolicy: { kind: "at_least_pct_lower", pct: 20 } },
        });

        const byId = new Map(checks.map((c) => [String(c.id), c]));
        expect(byId.get("102")!.passesRate).toBe(true); // 8 OK
        expect(byId.get("103")!.passesRate).toBe(false); // 9 FAIL
        expect(byId.get("104")!.passesRate).toBe(false); // 15 FAIL
    });

    it("handles loose/unknown policy input but still evaluates", () => {
        const b = createBuilder({ serviceMap });
        b.load(baseProps());

        const api = new CanvasAPI(b, { autoEmitState: false });
        const { editor } = api;

        const checks = editor.filterServicesForVisibleGroup([102], {
            tagId: "root",
            usedServiceIds: [100],
            effectiveConstraints: {},
            // intentionally loose: compilePolicies should normalize
            policies: [
                { subject: "services", scope: "visible_group", op: "all_true" },
            ],
            fallback: { ratePolicy: { kind: "lte_primary" } },
        });

        expect(checks).toHaveLength(1);
        expect(checks[0].ok).toBe(true);
    });
});
```

---
#### 3


` File: src/react/canvas/__tests__/editor.utility-guard.spec.ts`  [↑ Back to top](#index)

```ts
// src/canvas/__tests__/editor.utility-guard.spec.ts
import {describe, it, expect, vi} from 'vitest';
import {createBuilder} from "../../../core";
import {CanvasAPI} from "../api";
import {ServiceProps} from "../../../schema";

function baseProps(): ServiceProps {
    return {
        schema_version: '1.0',
        filters: [{id: 'root', label: 'Root'}],
        fields: [
            {
                id: 'fld',
                type: 'select',
                label: 'Select',
                bind_id: 'root',
                options: [
                    {id: 'o:base', label: 'Base Opt', pricing_role: 'base', service_id: 5},
                ],
            },
        ],
    };
}

describe('Editor utility guard (utilities cannot have service_id)', () => {
    it('clears service_id when switching option to utility', () => {
        const b = createBuilder();
        b.load(baseProps());

        const api = new CanvasAPI(b, {autoEmitState: false});
        const {editor} = api;

        // switch to utility (correct signature)
        editor.setService('o:base', {pricing_role: 'utility'});

        const props = b.getProps();
        const opt = props.fields[0].options!.find(o => o.id === 'o:base')!;
        expect(opt.pricing_role).toBe('utility');
        expect((opt as any).service_id).toBeUndefined();
    });

    it('blocks assigning service_id to a utility option', () => {
        const b = createBuilder();
        b.load(baseProps());

        const api = new CanvasAPI(b, {autoEmitState: false});
        const {editor} = api;

        // switch to utility first
        editor.setService('o:base', {pricing_role: 'utility'});

        // spy on error emission if your Editor exposes .on / .emit for 'editor:error'
        vi.fn();
        // If your Editor exposes `on`, uncomment:
        // editor.on('editor:error', errSpy);

        // attempt to set a service_id → should be blocked (correct signature)
        editor.setService('o:base', {service_id: 99});

        const props = b.getProps();
        const opt = props.fields[0].options!.find(o => o.id === 'o:base')!;
        expect(opt.pricing_role).toBe('utility');
        expect((opt as any).service_id).toBeUndefined();

        // If wired above:
        // expect(errSpy).toHaveBeenCalled();
    });

    it('undo restores previous base + service_id', () => {
        const b = createBuilder();
        b.load(baseProps());

        const api = new CanvasAPI(b, {autoEmitState: false});
        const {editor} = api;

        editor.setService('o:base', {pricing_role: 'utility'});
        let props = b.getProps();
        expect(props.fields[0].options![0].pricing_role).toBe('utility');
        expect((props.fields[0].options![0] as any).service_id).toBeUndefined();

        editor.undo();
        props = b.getProps();
        expect(props.fields[0].options![0].pricing_role).toBe('base');
        expect((props.fields[0].options![0] as any).service_id).toBe(5);
    });
});
```

---
#### 4


` File: src/react/canvas/__tests__/selection.test.ts`  [↑ Back to top](#index)

```ts
import {describe, it, expect} from 'vitest';
import {Selection} from '../selection';

// Minimal “builder” double for Selection (we only need getProps()).
function mkBuilder(props: any) {
    return {getProps: () => props} as any;
}

describe('Selection.visibleGroup()', () => {
    it('workspace: >1 tag selected → returns multi with raw selection set', () => {
        const props = {
            filters: [
                {id: 't:root', label: 'Root'},
                {id: 't:A', label: 'A', bind_id: 't:root'},
                {id: 't:B', label: 'B', bind_id: 't:root'},
            ],
            fields: [],
        };
        const builder = mkBuilder(props);
        const sel = new Selection(builder, {env: 'workspace', rootTagId: 't:root'});

        const raw = ['t:A', 't:B', 'o:x'];
        sel.many(raw, 't:A');

        const out = sel.visibleGroup();
        expect(out).toEqual({kind: 'multi', groups: raw});
    });

    it('single group: computes visible fields (bind + tag includes/excludes + option includes/excludes) honoring order_for_tags', () => {
        const props = {
            filters: [
                {id: 't:root', label: 'Root'},
                {
                    id: 't:Web', label: 'Web', bind_id: 't:root',
                    includes: ['f:extra'],         // force-include f:extra
                    excludes: ['f:hidden'],        // hide f:hidden even if bound
                },
            ],
            fields: [
                {id: 'f:bound1', label: 'Bound1', bind_id: 't:Web'}, // visible
                {id: 'f:hidden', label: 'Hidden', bind_id: 't:Web'}, // excluded by tag.excludes
                {id: 'f:extra', label: 'Extra'},                    // included by tag.includes
                {id: 'f:optIn', label: 'OptIn'},                    // will be included by option
            ],
            // Option-level mapping: selecting 'o:show' includes f:optIn; 'o:hide' excludes f:bound1
            includes_for_options: {'o:show': ['f:optIn']},
            excludes_for_options: {'o:hide': ['f:bound1']},
            // Explicit order for Web: f:extra, f:bound1, (others afterward)
            order_for_tags: {'t:Web': ['f:extra', 'f:bound1']},
        };
        const builder = mkBuilder(props);
        const sel = new Selection(builder, {env: 'client', rootTagId: 't:root'});

        // Select the tag and the option that includes f:optIn
        sel.replace('t:Web');
        sel.add('o:show');

        const res = sel.visibleGroup();
        expect(res.kind).toBe('single');
        const group = (res as any).group;

        // Should include: bound1 (bound), extra (tag.include), optIn (option.include)
        // Should exclude: hidden (tag.exclude)
        expect(group.fieldIds).toEqual(['f:extra', 'f:bound1', 'f:optIn']);
    });

    it('services: tag service first unless overridden by the first selected base option; utilities append; extra base options append', () => {
        const props = {
            filters: [
                {id: 't:root', label: 'Root'},
                {id: 't:Web', label: 'Web', bind_id: 't:root', service_id: 100}, // tag base 100
            ],
            fields: [
                {
                    id: 'f:plan', label: 'Plan', bind_id: 't:Web',
                    options: [
                        {id: 'o:util', label: 'Util', service_id: 300, pricing_role: 'utility'},
                        {id: 'o:base2', label: 'Base2', service_id: 200, pricing_role: 'base'},
                        {id: 'o:base3', label: 'Base3', service_id: 400, pricing_role: 'base'},
                    ]
                }
            ]
        };
        const resolveService = (id: any) => ({id});
        const builder = mkBuilder(props);
        const sel = new Selection(builder, {env: 'client', rootTagId: 't:root', resolveService});

        sel.replace('t:Web');
        sel.add('o:util');   // append after base
        sel.add('o:base2');  // first base → overrides tag base
        sel.add('o:base3');  // additional base → append

        const res = sel.visibleGroup();
        expect(res.kind).toBe('single');
        const services = (res as any).group.services;
        expect(services.map((s: any) => s.id)).toEqual([200, 300, 400]);
    });

    it('parentTags (nearest-first) and childrenTags (immediate only)', () => {
        const props = {
            filters: [
                {id: 't:root', label: 'Root'},
                {id: 't:A', label: 'A', bind_id: 't:root'},
                {id: 't:B', label: 'B', bind_id: 't:A'}, // focus tag
                {id: 't:C', label: 'C', bind_id: 't:B'}, // child of B
                {id: 't:D', label: 'D', bind_id: 't:B'}, // child of B
            ],
            fields: [],
        };
        const builder = mkBuilder(props);
        const sel = new Selection(builder, {env: 'client', rootTagId: 't:root'});

        sel.replace('t:B');
        const res = sel.visibleGroup();
        expect(res.kind).toBe('single');

        const group = (res as any).group;
        expect(group.tagId).toBe('t:B');
        // Nearest-first: A, then root
        expect(group.parentTags?.map((t: any) => t.id)).toEqual(['t:A', 't:root']);
        // Immediate children of B
        expect(group.childrenTags?.map((t: any) => t.id).sort()).toEqual(['t:C', 't:D']);
    });

    it('resolves tag context from a field selection (no tag explicitly selected)', () => {
        const props = {
            filters: [
                {id: 't:root', label: 'Root'},
                {id: 't:X', label: 'X', bind_id: 't:root'},
            ],
            fields: [
                {id: 'f:foo', label: 'Foo', bind_id: 't:X'},
                {id: 'f:bar', label: 'Bar', bind_id: 't:X'},
            ]
        };
        const builder = mkBuilder(props);
        const sel = new Selection(builder, {env: 'client', rootTagId: 't:root'});

        sel.replace('f:foo'); // only field selected
        const res = sel.visibleGroup();
        expect(res.kind).toBe('single');
        expect((res as any).group.tagId).toBe('t:X');
        expect((res as any).group.fieldIds.sort()).toEqual(['f:bar', 'f:foo'].sort());
    });
});
```

---
#### 5


` File: src/react/canvas/api.ts`  [↑ Back to top](#index)

```ts
import { EventBus } from "./events";
import type {
    CanvasEvents,
    CanvasOptions,
    CanvasState,
    NodePositions,
    Viewport,
    DraftWire,
} from "../../schema/canvas-types";
import type { Builder } from "../../core";
import type { EdgeKind, GraphSnapshot } from "../../schema/graph";
import { CommentsAPI } from "./comments";
import { CanvasBackendOptions } from "./backend";
import { Editor } from "./editor";
import { Selection } from "./selection";

export class CanvasAPI {
    private bus = new EventBus<CanvasEvents>();
    private readonly state: CanvasState;
    private builder: Builder;
    public readonly editor: Editor;
    private readonly autoEmit: boolean;
    readonly comments: CommentsAPI;
    readonly selection: Selection;

    constructor(
        builder: Builder,
        opts: CanvasOptions & CanvasBackendOptions = {},
    ) {
        this.builder = builder;
        this.autoEmit = opts.autoEmitState ?? true;
        this.selection = new Selection(builder, {
            env: "workspace",
            rootTagId: "t:root",
        });
        const graph = builder.tree();
        this.state = {
            graph,
            positions: {},
            selection: new Set(),
            highlighted: new Set(),
            viewport: { x: 0, y: 0, zoom: 1, ...opts.initialViewport },
            version: 1,
        };

        // compose comments with backend (if provided)
        this.comments = new CommentsAPI(this.bus, {
            backend: opts.backend?.comments,
            workspaceId: opts.workspaceId,
            actor: opts.actor,
        });

        this.editor = new Editor(builder, this, {
            serviceMap: builder.getServiceMap(),
            serviceExists: (id) => builder.getServiceMap().hasOwnProperty(id),
            ...opts,
        });

        if (this.autoEmit) this.bus.emit("state:change", this.snapshot());
    }

    /* ─── Events ─────────────────────────────────────────────── */
    on = this.bus.on.bind(this.bus);
    once = this.bus.once.bind(this.bus);

    public emit<K extends keyof CanvasEvents>(
        event: K,
        payload: CanvasEvents[K],
    ): void {
        this.bus.emit(event, payload);
    }

    /* ─── State accessors ───────────────────────────────────── */
    snapshot(): CanvasState {
        // return an immutable-looking view
        return {
            ...this.state,
            selection: new Set(this.state.selection),
            highlighted: new Set(this.state.highlighted),
            graph: {
                nodes: [...this.state.graph.nodes],
                edges: [...this.state.graph.edges],
            },
            positions: { ...this.state.positions },
        };
    }

    getGraph(): GraphSnapshot {
        return this.state.graph;
    }

    getSelection(): string[] {
        return Array.from(this.state.selection);
    }

    getViewport(): Viewport {
        return { ...this.state.viewport };
    }

    /* ─── Graph lifecycle ───────────────────────────────────── */
    refreshGraph(): void {
        this.state.graph = this.builder.tree();
        this.bump();
        this.bus.emit("graph:update", this.state.graph);
    }

    setPositions(pos: NodePositions): void {
        this.state.positions = { ...this.state.positions, ...pos };
        this.bump();
    }

    setPosition(id: string, x: number, y: number): void {
        this.state.positions[id] = { x, y };
        this.bump();
    }

    /* ─── Selection ─────────────────────────────────────────── */
    select(ids: string[] | Set<string>): void {
        this.state.selection = new Set(ids as any);
        this.bump();
        this.bus.emit("selection:change", { ids: this.getSelection() });
    }

    selectComments(threadId?: string): void {
        this.bus.emit("comment:select", { threadId });
    }

    addToSelection(ids: string[] | Set<string>): void {
        for (const id of ids as any) this.state.selection.add(id);
        this.bump();
        this.bus.emit("selection:change", { ids: this.getSelection() });
    }

    toggleSelection(id: string): void {
        if (this.state.selection.has(id)) this.state.selection.delete(id);
        else this.state.selection.add(id);
        this.bump();
        this.bus.emit("selection:change", { ids: this.getSelection() });
    }

    clearSelection(): void {
        if (this.state.selection.size === 0) return;
        this.state.selection.clear();
        this.bump();
        this.bus.emit("selection:change", { ids: [] });
    }

    /* ─── Highlight / Hover ─────────────────────────────────── */
    setHighlighted(ids: string[] | Set<string>): void {
        this.state.highlighted = new Set(ids as any);
        this.bump();
    }

    setHover(id?: string): void {
        this.state.hoverId = id;
        this.bump();
        this.bus.emit("hover:change", { id });
    }

    /* ─── Viewport ──────────────────────────────────────────── */
    setViewport(v: Partial<Viewport>): void {
        this.state.viewport = { ...this.state.viewport, ...v };
        this.bump();
        this.bus.emit("viewport:change", this.getViewport());
    }

    /* ─── Wiring draft (for bind/include/exclude UX) ────────── */
    startWire(from: string, kind: DraftWire["kind"]): void {
        this.state.draftWire = { from, kind };
        this.bump();
        this.bus.emit("wire:preview", { from, kind });
    }

    previewWire(to?: string): void {
        const dw = this.state.draftWire;
        if (!dw) return;
        this.bus.emit("wire:preview", { from: dw.from, to, kind: dw.kind });
    }

    commitWire(to: string): void {
        const dw = this.state.draftWire;
        if (!dw) return;
        // Headless API emits; the adapter/host decides how to mutate Builder
        this.bus.emit("wire:commit", { from: dw.from, to, kind: dw.kind });
        this.state.draftWire = undefined;
        this.bump();
    }

    cancelWire(): void {
        const dw = this.state.draftWire;
        if (!dw) return;
        this.bus.emit("wire:cancel", { from: dw.from });
        this.state.draftWire = undefined;
        this.bump();
    }

    /* ─── Utilities ─────────────────────────────────────────── */
    private bump(): void {
        this.state.version++;
        if (this.autoEmit) this.bus.emit("state:change", this.snapshot());
    }

    dispose(): void {
        this.bus.clear();
    }

    undo() {
        this.builder.undo();
        this.refreshGraph();
    }

    private edgeRel: EdgeKind = "bind";

    getEdgeRel(): EdgeKind {
        return this.edgeRel;
    }

    public setEdgeRel(rel: EdgeKind) {
        if (this.edgeRel === rel) return; // ← correct: skip only if identical
        this.edgeRel = rel;
        this.bus.emit('edge:change', rel);
    }

    /* ─── Option-node visibility (per field) ───────────────────────────────── */

    /** Internal mirror of which fields should show their options as nodes. */
    private shownOptionFields = new Set<string>();

    /** Return the field ids whose options are currently set to be visible as nodes. */
    getShownOptionFields(): string[] {
        return Array.from(this.shownOptionFields);
    }

    /** True if this field’s options are shown as nodes. */
    isFieldOptionsShown(fieldId: string): boolean {
        return this.shownOptionFields.has(String(fieldId));
    }

    /**
     * Set visibility of option nodes for a field, then rebuild the graph.
     * When shown = true, the Builder will emit option nodes for this field.
     */
    setFieldOptionsShown(fieldId: string, shown: boolean): void {
        const id = String(fieldId);
        const before = this.shownOptionFields.has(id);
        if (shown && !before) this.shownOptionFields.add(id);
        else if (!shown && before) this.shownOptionFields.delete(id);
        else return; // no-op

        // Push to builder options and refresh
        this.builder.setOptions({
            showOptionNodes: new Set(this.shownOptionFields),
        });
        this.refreshGraph();
    }

    /** Toggle option-node visibility for a field. Returns the new visibility. */
    toggleFieldOptions(fieldId: string): boolean {
        const next = !this.isFieldOptionsShown(fieldId);
        this.setFieldOptionsShown(fieldId, next);
        return next;
    }

    /**
     * Replace the whole set of fields whose options are visible as nodes.
     * Useful for restoring a saved UI state.
     */
    setShownOptionFields(ids: Iterable<string>): void {
        const next = new Set(Array.from(ids, String));
        // Fast-path: if identical set, skip work
        if (
            next.size === this.shownOptionFields.size &&
            Array.from(next).every((id) => this.shownOptionFields.has(id))
        ) {
            return;
        }
        this.shownOptionFields = next;
        this.builder.setOptions({
            showOptionNodes: new Set(this.shownOptionFields),
        });
        this.refreshGraph();
    }
}
```

---
#### 6


` File: src/react/canvas/backend.ts`  [↑ Back to top](#index)

```ts
// Transport-agnostic backend interfaces the HOST must implement

import type {CommentAnchor, CommentMessage, CommentThread} from './comments';

export type BackendError = {
    code: 'network' | 'forbidden' | 'not_found' | 'validation' | 'conflict' | 'unknown';
    message: string;
    meta?: any;
};

export type Result<T> = { ok: true; data: T } | { ok: false; error: BackendError };

// Minimal identity for annotation; permissions enforced server-side
export type Actor = { id: string; name?: string; avatarUrl?: string };

/**
 * Wire format is intentionally the same shape as headless types, so hosts can
 * pass data through if they like. They may add backend-specific fields via `meta`.
 */
export type CommentThreadDTO = CommentThread;
export type CommentMessageDTO = CommentMessage;

export interface CommentsBackend {
    // Load all threads for a canvas/workspace
    listThreads(ctx: { workspaceId: string }): Promise<Result<CommentThreadDTO[]>>;

    // Create thread with initial message
    createThread(ctx: { workspaceId: string; actor?: Actor }, input: {
        anchor: CommentAnchor;
        body: string;
        meta?: Record<string, unknown>;
    }): Promise<Result<CommentThreadDTO>>;

    addMessage(ctx: { workspaceId: string; actor?: Actor }, input: {
        threadId: string;
        body: string;
        meta?: Record<string, unknown>;
    }): Promise<Result<CommentMessageDTO>>;

    editMessage(ctx: { workspaceId: string; actor?: Actor }, input: {
        threadId: string;
        messageId: string;
        body: string;
    }): Promise<Result<CommentMessageDTO>>;

    deleteMessage(ctx: { workspaceId: string; actor?: Actor }, input: {
        threadId: string;
        messageId: string;
    }): Promise<Result<void>>;

    moveThread(ctx: { workspaceId: string; actor?: Actor }, input: {
        threadId: string;
        anchor: CommentAnchor;
    }): Promise<Result<CommentThreadDTO>>;

    resolveThread(ctx: { workspaceId: string; actor?: Actor }, input: {
        threadId: string;
        resolved: boolean;
    }): Promise<Result<CommentThreadDTO>>;

    deleteThread(ctx: { workspaceId: string; actor?: Actor }, input: {
        threadId: string;
    }): Promise<Result<void>>;
}

export type CanvasBackend = {
    comments?: CommentsBackend;
};

export type CanvasBackendOptions = {
    backend?: CanvasBackend;
    workspaceId?: string; // host-provided scope for loading/saving
    actor?: Actor;
};
```

---
#### 7


` File: src/react/canvas/comments.ts`  [↑ Back to top](#index)

```ts
import type {EventBus} from './events';
import type {CanvasEvents} from '../../schema/canvas-types';
import type {CommentsBackend, Actor, BackendError} from './backend';
import {RetryQueue, type RetryOptions as RetryOpts} from "../../utils/retry-queue";

export type CommentId = string;
export type ThreadId = string;

export type CommentAnchor =
    | { type: 'node'; nodeId: string; offset?: { dx: number; dy: number } }
    | { type: 'edge'; edgeId: string; t?: number }
    | { type: 'free'; position: { x: number; y: number } };

export type CommentMessage = {
    id: CommentId;
    authorId?: string;
    authorName?: string;
    body: string;
    createdAt: number;
    editedAt?: number;
    meta?: Record<string, unknown>;
};

export type CommentThread = {
    id: ThreadId;
    anchor: CommentAnchor;
    resolved: boolean;
    createdAt: number;
    updatedAt: number;
    messages: CommentMessage[];
    meta?: Record<string, unknown>;
    // local sync flags (not persisted by server)
    _sync?: 'pending' | 'synced' | 'error';
};

let __seq = 0;
const newLocalId = (p = 'loc'): string => `${p}_${Date.now().toString(36)}_${(++__seq).toString(36)}`;

type CommentsDeps = {
    backend?: CommentsBackend;
    workspaceId?: string;
    actor?: Actor;
    retry?: RetryOpts;
};

export class CommentsAPI {
    private threads = new Map<ThreadId, CommentThread>();
    private bus: EventBus<CanvasEvents>;
    private deps: CommentsDeps;
    private retry: RetryQueue;

    constructor(bus: EventBus<CanvasEvents>, deps: CommentsDeps = {}) {
        this.bus = bus;
        this.deps = deps;
        this.retry = new RetryQueue(deps.retry);
    }

    private emitSync(op: CanvasEvents['comment:sync']['op'], threadId: string, messageId: string | undefined, status: CanvasEvents['comment:sync']['status'], meta: {
        attempt: number;
        nextDelayMs?: number;
        error?: BackendError | unknown
    }) {
        this.bus.emit('comment:sync', {
            op,
            threadId,
            messageId,
            status,
            attempt: meta.attempt,
            nextDelayMs: meta.nextDelayMs,
            error: meta.error
        });
    }

    /* ─── Persistence bridge ───────────────────────────── */

    async loadAll(): Promise<void> {
        if (!this.deps.backend || !this.deps.workspaceId) return;
        const res = await this.deps.backend.listThreads({workspaceId: this.deps.workspaceId});
        if (!res.ok) {
            this.bus.emit('error', {message: res.error.message, code: res.error.code, meta: res.error.meta});
            return;
        }
        this.threads.clear();
        for (const th of res.data) this.threads.set(th.id, {...th, _sync: 'synced'});
        this.bus.emit('comment:thread:update', {thread: undefined as any}); // signal refresh
    }

    /* ─── Query ─────────────────────────────────────────── */
    list(): CommentThread[] {
        return Array.from(this.threads.values()).sort((a, b) => a.createdAt - b.createdAt);
    }

    get(id: ThreadId): CommentThread | undefined {
        return this.threads.get(id);
    }

    /* ─── Mutations (optimistic if backend present) ─────── */

    async create(anchor: CommentAnchor, initialBody: string, meta?: Record<string, unknown>): Promise<ThreadId> {
        const now = Date.now();
        const localId = newLocalId('t');
        const msgId = newLocalId('m');

        const local: CommentThread = {
            id: localId,
            anchor,
            resolved: false,
            createdAt: now,
            updatedAt: now,
            messages: [{id: msgId, body: initialBody, createdAt: now}],
            meta,
            _sync: this.deps.backend ? 'pending' : 'synced',
        };
        this.threads.set(localId, local);
        this.bus.emit('comment:thread:create', {thread: local});

        if (!this.deps.backend || !this.deps.workspaceId) return localId;

        const performOnce = async () => {
            const res = await this.deps.backend!.createThread(
                {workspaceId: this.deps.workspaceId!, actor: this.deps.actor},
                {anchor, body: initialBody, meta}
            );
            if (!res.ok) throw res.error;
            // Swap local→server on success
            this.threads.delete(localId);
            const serverTh: CommentThread = {...res.data, _sync: 'synced'};
            this.threads.set(serverTh.id, serverTh);
            this.bus.emit('comment:thread:update', {thread: serverTh});
            return true;
        };

        try {
            await performOnce();
        } catch (err) {
            // schedule retry
            const jobId = `comments:create_thread:${localId}`;
            this.retry.enqueue({
                id: jobId,
                perform: async (_attempt) => {
                    try {
                        await performOnce();
                        return true;
                    } catch (e) {
                        return false;
                    }
                },
                onStatus: (status, meta) => this.emitSync('create_thread', localId, undefined, status, meta ?? {attempt: 0}),
            });
            // mark error locally (UI can show badge)
            local._sync = 'error';
            this.bus.emit('error', {
                message: (err as BackendError)?.message ?? 'Create failed',
                code: (err as BackendError)?.code,
                meta: err
            });
            this.bus.emit('comment:thread:update', {thread: local});
        }

        return localId;
    }

    async reply(threadId: ThreadId, body: string, meta?: Record<string, unknown>): Promise<CommentId> {
        const th = this.ensure(threadId);
        const now = Date.now();
        const localMid = newLocalId('m');
        const localMsg: CommentMessage = {id: localMid, body, createdAt: now, meta};
        th.messages.push(localMsg);
        th.updatedAt = now;
        th._sync ??= this.deps.backend ? 'pending' : 'synced';
        this.bus.emit('comment:message:create', {threadId, message: localMsg});
        this.bus.emit('comment:thread:update', {thread: th});

        if (!this.deps.backend || !this.deps.workspaceId) return localMid;

        const performOnce = async () => {
            const res = await this.deps.backend!.addMessage(
                {workspaceId: this.deps.workspaceId!, actor: this.deps.actor},
                {threadId: th.id, body, meta}
            );
            if (!res.ok) throw res.error;
            const idx = th.messages.findIndex(m => m.id === localMid);
            if (idx >= 0) th.messages[idx] = res.data;
            th._sync = 'synced';
            this.bus.emit('comment:thread:update', {thread: th});
            return true;
        };

        try {
            await performOnce();
        } catch (err) {
            const jobId = `comments:add_message:${threadId}:${localMid}`;
            this.retry.enqueue({
                id: jobId,
                perform: async () => {
                    try {
                        await performOnce();
                        return true;
                    } catch {
                        return false;
                    }
                },
                onStatus: (status, meta) => this.emitSync('add_message', threadId, localMid, status, meta ?? {attempt: 0}),
            });
            th._sync = 'error';
            this.bus.emit('error', {
                message: (err as BackendError)?.message ?? 'Reply failed',
                code: (err as BackendError)?.code,
                meta: err
            });
            this.bus.emit('comment:thread:update', {thread: th});
        }
        return localMid;
    }

    async editMessage(threadId: ThreadId, messageId: CommentId, body: string): Promise<void> {
        const th = this.ensure(threadId);
        const orig = th.messages.find(m => m.id === messageId);
        if (!orig) return;
        const previous = {...orig};
        orig.body = body;
        orig.editedAt = Date.now();
        th.updatedAt = orig.editedAt;
        th._sync ??= this.deps.backend ? 'pending' : 'synced';
        this.bus.emit('comment:thread:update', {thread: th});

        if (!this.deps.backend || !this.deps.workspaceId) return;

        const performOnce = async () => {
            const res = await this.deps.backend!.editMessage(
                {workspaceId: this.deps.workspaceId!, actor: this.deps.actor},
                {threadId: th.id, messageId, body}
            );
            if (!res.ok) throw res.error;
            const idx = th.messages.findIndex(m => m.id === messageId);
            if (idx >= 0) th.messages[idx] = res.data;
            th._sync = 'synced';
            this.bus.emit('comment:thread:update', {thread: th});
            return true;
        };

        try {
            await performOnce();
        } catch (err) {
            const jobId = `comments:edit_message:${threadId}:${messageId}`;
            this.retry.enqueue({
                id: jobId,
                perform: async () => {
                    try {
                        await performOnce();
                        return true;
                    } catch {
                        return false;
                    }
                },
                onStatus: (status, meta) => this.emitSync('edit_message', threadId, messageId, status, meta ?? {attempt: 0}),
            });
            // rollback on immediate failure to keep UI honest
            const idx = th.messages.findIndex(m => m.id === messageId);
            if (idx >= 0) th.messages[idx] = previous;
            th._sync = 'error';
            this.bus.emit('error', {
                message: (err as BackendError)?.message ?? 'Edit failed',
                code: (err as BackendError)?.code,
                meta: err
            });
            this.bus.emit('comment:thread:update', {thread: th});
        }
    }

    async deleteMessage(threadId: ThreadId, messageId: CommentId): Promise<void> {
        const th = this.ensure(threadId);
        const backup = [...th.messages];
        th.messages = th.messages.filter(m => m.id !== messageId);
        th.updatedAt = Date.now();
        th._sync ??= this.deps.backend ? 'pending' : 'synced';
        this.bus.emit('comment:thread:update', {thread: th});

        if (!this.deps.backend || !this.deps.workspaceId) return;

        const performOnce = async () => {
            const res = await this.deps.backend!.deleteMessage(
                {workspaceId: this.deps.workspaceId!, actor: this.deps.actor},
                {threadId: th.id, messageId}
            );
            if (!res.ok) throw res.error;
            th._sync = 'synced';
            this.bus.emit('comment:thread:update', {thread: th});
            return true;
        };

        try {
            await performOnce();
        } catch (err) {
            const jobId = `comments:delete_message:${threadId}:${messageId}`;
            this.retry.enqueue({
                id: jobId,
                perform: async () => {
                    try {
                        await performOnce();
                        return true;
                    } catch {
                        return false;
                    }
                },
                onStatus: (status, meta) => this.emitSync('delete_message', threadId, messageId, status, meta ?? {attempt: 0}),
            });
            // rollback UI on immediate failure
            th.messages = backup;
            th._sync = 'error';
            this.bus.emit('error', {
                message: (err as BackendError)?.message ?? 'Delete failed',
                code: (err as BackendError)?.code,
                meta: err
            });
            this.bus.emit('comment:thread:update', {thread: th});
        }
    }

    async move(threadId: ThreadId, anchor: CommentAnchor): Promise<void> {
        const th = this.ensure(threadId);
        const prev = th.anchor;
        th.anchor = anchor;
        th.updatedAt = Date.now();
        th._sync ??= this.deps.backend ? 'pending' : 'synced';
        this.bus.emit('comment:move', {thread: th});
        this.bus.emit('comment:thread:update', {thread: th});

        if (!this.deps.backend || !this.deps.workspaceId) return;

        const performOnce = async () => {
            const res = await this.deps.backend!.moveThread(
                {workspaceId: this.deps.workspaceId!, actor: this.deps.actor},
                {threadId: th.id, anchor}
            );
            if (!res.ok) throw res.error;
            this.threads.set(th.id, {...res.data, _sync: 'synced'});
            this.bus.emit('comment:thread:update', {thread: this.threads.get(threadId)!});
            return true;
        };

        try {
            await performOnce();
        } catch (err) {
            const jobId = `comments:move_thread:${threadId}`;
            this.retry.enqueue({
                id: jobId,
                perform: async () => {
                    try {
                        await performOnce();
                        return true;
                    } catch {
                        return false;
                    }
                },
                onStatus: (status, meta) => this.emitSync('move_thread', threadId, undefined, status, meta ?? {attempt: 0}),
            });
            th.anchor = prev;
            th._sync = 'error';
            this.bus.emit('error', {
                message: (err as BackendError)?.message ?? 'Move failed',
                code: (err as BackendError)?.code,
                meta: err
            });
            this.bus.emit('comment:thread:update', {thread: th});
        }
    }

    async resolve(threadId: ThreadId, value = true): Promise<void> {
        const th = this.ensure(threadId);
        const prev = th.resolved;
        th.resolved = value;
        th.updatedAt = Date.now();
        th._sync ??= this.deps.backend ? 'pending' : 'synced';
        this.bus.emit('comment:resolve', {thread: th, resolved: value});
        this.bus.emit('comment:thread:update', {thread: th});

        if (!this.deps.backend || !this.deps.workspaceId) return;

        const performOnce = async () => {
            const res = await this.deps.backend!.resolveThread(
                {workspaceId: this.deps.workspaceId!, actor: this.deps.actor},
                {threadId: th.id, resolved: value}
            );
            if (!res.ok) throw res.error;
            this.threads.set(th.id, {...res.data, _sync: 'synced'});
            this.bus.emit('comment:thread:update', {thread: this.threads.get(threadId)!});
            return true;
        };

        try {
            await performOnce();
        } catch (err) {
            const jobId = `comments:resolve_thread:${threadId}`;
            this.retry.enqueue({
                id: jobId,
                perform: async () => {
                    try {
                        await performOnce();
                        return true;
                    } catch {
                        return false;
                    }
                },
                onStatus: (status, meta) => this.emitSync('resolve_thread', threadId, undefined, status, meta ?? {attempt: 0}),
            });
            th.resolved = prev;
            th._sync = 'error';
            this.bus.emit('error', {
                message: (err as BackendError)?.message ?? 'Resolve failed',
                code: (err as BackendError)?.code,
                meta: err
            });
            this.bus.emit('comment:thread:update', {thread: th});
        }
    }

    async deleteThread(threadId: ThreadId): Promise<void> {
        const prev = this.threads.get(threadId);
        if (!prev) return;
        this.threads.delete(threadId);
        this.bus.emit('comment:thread:delete', {threadId});

        if (!this.deps.backend || !this.deps.workspaceId) return;

        const performOnce = async () => {
            const res = await this.deps.backend!.deleteThread(
                {workspaceId: this.deps.workspaceId!, actor: this.deps.actor},
                {threadId}
            );
            if (!res.ok) throw res.error;
            return true;
        };

        try {
            await performOnce();
        } catch (err) {
            const jobId = `comments:delete_thread:${threadId}`;
            this.retry.enqueue({
                id: jobId,
                perform: async () => {
                    try {
                        await performOnce();
                        return true;
                    } catch {
                        return false;
                    }
                },
                onStatus: (status, meta) => this.emitSync('delete_thread', threadId, undefined, status, meta ?? {attempt: 0}),
            });
            // rollback deletion so user can retry
            this.threads.set(threadId, prev);
            this.bus.emit('error', {
                message: (err as BackendError)?.message ?? 'Delete thread failed',
                code: (err as BackendError)?.code,
                meta: err
            });
            this.bus.emit('comment:thread:update', {thread: prev!});
        }
    }

    // Optional helpers for UI controls
    retryJob(jobId: string): boolean {
        return this.retry.triggerNow(jobId);
    }

    cancelJob(jobId: string): boolean {
        return this.retry.cancel(jobId);
    }

    pendingJobs(): string[] {
        return this.retry.pendingIds();
    }

    /* ─── internal ────────────────────────────────────────── */
    private ensure(threadId: ThreadId): CommentThread {
        const th = this.threads.get(threadId);
        if (!th) throw new Error(`Comment thread not found: ${threadId}`);
        return th;
    }
}
```

---
#### 8


` File: src/react/canvas/editor.ts`  [↑ Back to top](#index)

```ts
import { cloneDeep } from "lodash-es";
import type { Builder } from "../../core";
import type { ServiceProps, Tag, Field } from "../../schema";
import { normalise } from "../../core";
import type { CanvasAPI } from "./api";
import type {
    Command,
    EditorEvents,
    EditorOptions,
} from "../../schema/editor.types";
import { compilePolicies, PolicyDiagnostic } from "../../core/policy";
import { DynamicRule, FallbackSettings } from "../../schema/validation";
import { DgpServiceCapability, DgpServiceMap } from "../../schema/provider";
import { constraintFitOk, rateOk, toFiniteNumber } from "../../utils/util";
import { EditorSnapshot } from "../../schema/editor";
import { Selection } from "./selection";

const MAX_LIMIT = 100;
type WireKind = "bind" | "include" | "exclude" | "service";

// Addressing nodes
export type TagRef = { kind: "tag"; id: string };
export type FieldRef = { kind: "field"; id: string };
export type OptionRef = { kind: "option"; fieldId: string; id: string };
export type NodeRef = TagRef | FieldRef | OptionRef;

export type DuplicateOptions = {
    // tags
    withChildren?: boolean; // default false
    // fields
    copyBindings?: boolean; // default true
    copyIncludesExcludes?: boolean; // default false
    copyOptionMaps?: boolean; // default false
    // all
    id?: string; // force an id instead of auto
    labelStrategy?: (old: string) => string; // override default "Label (copy)" logic
    nameStrategy?: (old?: string) => string | undefined; // for fields; default suffix "_copy"
    optionIdStrategy?: (old: string) => string; // for options; default add "_copy"
};

const isTagId = (id: string) => id.startsWith("t:");
const isFieldId = (id: string) => id.startsWith("f:");
const isOptionId = (id: string) => id.startsWith("o:");

// owner lookup (linear, OK for editor; index if you want later)
function ownerOfOption(
    props: ServiceProps,
    optionId: string,
): { fieldId: string; index: number } | null {
    for (const f of props.fields ?? []) {
        const idx = (f.options ?? []).findIndex((o) => o.id === optionId);
        if (idx >= 0) return { fieldId: f.id, index: idx };
    }
    return null;
}

function ensureServiceExists(opts: EditorOptions, id: any) {
    if (typeof opts.serviceExists === "function") {
        if (!opts.serviceExists(id))
            throw new Error(`service_not_found:${String(id)}`);
        return;
    }
    if (opts.serviceMap) {
        if (!Object.prototype.hasOwnProperty.call(opts.serviceMap, id as any)) {
            throw new Error(`service_not_found:${String(id)}`);
        }
        return;
    }
    // Host didn't provide a way to verify — fail so they wire one.
    throw new Error("service_checker_missing");
}

export class Editor {
    private builder: Builder;
    private api: CanvasAPI;
    private readonly opts: Required<EditorOptions>;
    private history: EditorSnapshot[] = [];
    private index = -1; // points to current snapshot
    private txnDepth = 0;
    private txnLabel?: string;
    private stagedBefore?: EditorSnapshot;
    private _lastPolicyDiagnostics?: PolicyDiagnostic[];
    constructor(builder: Builder, api: CanvasAPI, opts: EditorOptions = {}) {
        this.builder = builder;
        this.api = api;
        // @ts-ignore
        this.opts = {
            historyLimit: Math.max(
                1,
                Math.min(opts.historyLimit ?? MAX_LIMIT, 1000),
            ),
            validateAfterEach: opts.validateAfterEach ?? false,
        };
        // seed initial snapshot
        this.pushHistory(this.makeSnapshot("init"));
    }

    /* ───────────────────────── Public API ───────────────────────── */

    getProps(): ServiceProps {
        return this.builder.getProps();
    }

    transact(label: string, fn: () => void): void {
        const wasTop = this.txnDepth === 0;
        let ok = false;
        if (wasTop) {
            this.txnLabel = label;
            this.stagedBefore = this.makeSnapshot(label + ":before");
        }
        this.txnDepth++;
        try {
            fn();
            ok = true;
        } finally {
            this.txnDepth--;
            if (wasTop) {
                if (ok) {
                    this.commit(label); // push one history entry
                } else if (this.stagedBefore) {
                    this.loadSnapshot(this.stagedBefore, "undo"); // rollback to pre-txn state
                }
                this.txnLabel = undefined;
                this.stagedBefore = undefined;
            }
        }
    }

    exec(cmd: Command): void {
        try {
            const before = this.makeSnapshot(cmd.name + ":before");
            cmd.do();
            this.afterMutation(cmd.name, before);
        } catch (err) {
            this.emit("editor:error", {
                message: (err as Error)?.message ?? String(err),
                code: "command",
            });
            throw err;
        }
    }

    undo(): boolean {
        if (this.index <= 0) return false;
        this.index--;
        this.loadSnapshot(this.history[this.index], "undo");
        this.emit("editor:undo", {
            stackSize: this.history.length,
            index: this.index,
        });
        return true;
    }

    redo(): boolean {
        if (this.index >= this.history.length - 1) return false;
        this.index++;
        this.loadSnapshot(this.history[this.index], "redo");
        this.emit("editor:redo", {
            stackSize: this.history.length,
            index: this.index,
        });
        return true;
    }

    clearService(id: string) {
        this.setService(id, { service_id: undefined });
    }

    /* ───────────── Convenience editing ops (command-wrapped) ───────────── */
    duplicate(ref: NodeRef, opts: DuplicateOptions = {}): string {
        const snapBefore = this.makeSnapshot("duplicate:before");
        try {
            let newId = "";
            this.transact("duplicate", () => {
                if (ref.kind === "tag") {
                    newId = this.duplicateTag(ref.id, opts);
                } else if (ref.kind === "field") {
                    newId = this.duplicateField(ref.id, opts);
                } else {
                    newId = this.duplicateOption(ref.fieldId, ref.id, opts);
                }
            });
            return newId;
        } catch (err) {
            // rollback to be safe
            this.loadSnapshot(snapBefore, "undo");
            throw err;
        }
    }

    /**
     * Update the display label for a node and refresh the graph so node labels stay in sync.
     * Supports: tag ("t:*"), field ("f:*"), option ("o:*").
     * IDs are NOT changed; only the human-readable label.
     */
    reLabel(id: string, nextLabel: string): void {
        const label = String(nextLabel ?? "").trim();

        this.exec({
            name: "reLabel",
            do: () =>
                this.patchProps((p) => {
                    // Tag
                    if (isTagId(id)) {
                        const t = (p.filters ?? []).find((x) => x.id === id);
                        if (!t) return;
                        if ((t.label ?? "") === label) return;
                        t.label = label;
                        // graph nodes mirror builder, so rebuild
                        this.api.refreshGraph();
                        return;
                    }

                    // Option (find owner field → option)
                    if (isOptionId(id)) {
                        const own = ownerOfOption(p, id);
                        if (!own) return;
                        const f = (p.fields ?? []).find(
                            (x) => x.id === own.fieldId,
                        );
                        const o = f?.options?.find((x) => x.id === id);
                        if (!o) return;
                        if ((o.label ?? "") === label) return;
                        o.label = label;
                        this.api.refreshGraph();
                        return;
                    }

                    // Field (default)
                    const fld = (p.fields ?? []).find((x) => x.id === id);
                    if (!fld) return;
                    if ((fld.label ?? "") === label) return;
                    fld.label = label;
                    this.api.refreshGraph();
                }),
            undo: () => this.api.undo(),
        });
    }

    /**
     * Assign or change a field's `name`. Only allowed when the field (and its options) have NO service mapping.
     * - If `nextName` is empty/blank → removes the `name`.
     * - Emits an error if the field or any of its options carry a `service_id`.
     * - Emits an error if `nextName` collides with an existing field's name (case-sensitive).
     */
    setFieldName(fieldId: string, nextName: string | null | undefined): void {
        const raw = typeof nextName === "string" ? nextName : "";
        const name = raw.trim();

        this.exec({
            name: "setFieldName",
            do: () =>
                this.patchProps((p) => {
                    const fields = p.fields ?? [];
                    const f = fields.find((x) => x.id === fieldId);
                    if (!f) {
                        this.api.emit("error", {
                            code: "field_not_found",
                            message: `Field not found: ${fieldId}`,
                            meta: { fieldId },
                        });
                        return;
                    }

                    // Disallow if the field itself maps to a service
                    const fieldHasService =
                        typeof (f as any).service_id === "number";

                    // Disallow if any option maps to a service
                    const optionHasService = Array.isArray(f.options)
                        ? f.options.some(
                              (o) => typeof (o as any).service_id === "number",
                          )
                        : false;

                    if (fieldHasService || optionHasService) {
                        this.api.emit("error", {
                            code: "field_has_service_mapping",
                            message:
                                "Cannot set a name on a field that maps to a service (either the field or one of its options has a service_id).",
                            meta: {
                                fieldId,
                                fieldHasService,
                                optionHasService,
                            },
                        });
                        return;
                    }

                    // If clearing, remove the key to keep payload lean
                    if (name.length === 0) {
                        if ("name" in f) delete (f as any).name;
                        return;
                    }

                    // Prevent name collisions with other fields
                    const collision = fields.find(
                        (x) => x.id !== fieldId && (x.name ?? "") === name,
                    );
                    if (collision) {
                        this.api.emit("error", {
                            code: "field_name_collision",
                            message: `Another field already uses the name "${name}".`,
                            meta: { fieldId, otherFieldId: collision.id },
                        });
                        return;
                    }

                    // Assign
                    (f as any).name = name;
                }),
            undo: () => this.api.undo(),
        });
    }
    getLastPolicyDiagnostics(): PolicyDiagnostic[] | undefined {
        return this._lastPolicyDiagnostics;
    }
    /* ───────────────────── Internals: duplicate impls ───────────────────── */

    private duplicateTag(tagId: string, opts: DuplicateOptions): string {
        const props = this.builder.getProps();
        const tags = props.filters ?? [];
        const src = tags.find((t) => t.id === tagId);
        if (!src) throw new Error(`Tag not found: ${tagId}`);

        // generate new id + label
        const id = opts.id ?? this.uniqueId(src.id);
        const label = (opts.labelStrategy ?? nextCopyLabel)(src.label ?? id);

        if (!opts.withChildren) {
            // shallow copy
            this.patchProps((p) => {
                const clone = { ...src, id, label };
                // keep same parent
                clone.bind_id = src.bind_id;
                // includes/excludes are field ids—copy them as-is
                clone.constraints_overrides = undefined;
                clone.constraints_origin = undefined;
                // insert after original among siblings: we can rebuild array with splice
                const arr = p.filters ?? [];
                const idx = arr.findIndex((t) => t.id === tagId);
                arr.splice(idx + 1, 0, clone);
                p.filters = arr;
            });
            return id;
        }

        // deep clone subtree: map oldTagId -> newTagId
        const idMap = new Map<string, string>();
        const collect = (t: typeof src, acc: (typeof src)[]) => {
            acc.push(t);
            for (const child of tags.filter((x) => x.bind_id === t.id))
                collect(child as any, acc);
        };
        const subtree: (typeof src)[] = [];
        collect(src, subtree);

        // allocate ids
        for (const n of subtree)
            idMap.set(n.id, n.id === src.id ? id : this.uniqueId(n.id));

        // build clones
        const clones = subtree.map((n) => {
            const cloned = { ...n };
            cloned.id = idMap.get(n.id)!;
            cloned.label =
                n.id === src.id
                    ? label
                    : (opts.labelStrategy ?? nextCopyLabel)(n.label ?? n.id);

            // rewire parent if parent is in subtree
            cloned.bind_id = n.bind_id
                ? (idMap.get(n.bind_id) ?? n.bind_id)
                : undefined;

            // scrub derived meta (will be re-created by normalise)
            cloned.constraints_origin = undefined;
            cloned.constraints_overrides = undefined;
            return cloned;
        });

        this.patchProps((p) => {
            const arr = p.filters ?? [];
            // insert root clone after original
            const rootIdx = arr.findIndex((t) => t.id === tagId);
            arr.splice(rootIdx + 1, 0, clones[0] as any);
            // append other clones (order: parent before children to keep grouping stable)
            for (const c of clones.slice(1)) arr.push(c as any);
            p.filters = arr;
        });

        return id;
    }

    private duplicateField(fieldId: string, opts: DuplicateOptions): string {
        const props = this.builder.getProps();
        const fields = props.fields ?? [];
        const src = fields.find((f) => f.id === fieldId);
        if (!src) throw new Error(`Field not found: ${fieldId}`);

        const id = opts.id ?? this.uniqueId(src.id);
        const label = (opts.labelStrategy ?? nextCopyLabel)(src.label ?? id);
        const name = opts.nameStrategy
            ? opts.nameStrategy(src.name)
            : nextCopyName(src.name);

        // helper to create new option ids
        const optId = (old: string) =>
            this.uniqueOptionId(
                id,
                (opts.optionIdStrategy ?? defaultOptionIdStrategy)(old),
            );

        // deep copy options with new ids
        const clonedOptions = (src.options ?? []).map((o) => ({
            ...o,
            id: optId(o.id),
            label: (opts.labelStrategy ?? nextCopyLabel)(o.label ?? o.id),
        }));

        const cloned = {
            ...src,
            id,
            label,
            name,
            bind_id: (opts.copyBindings ?? true) ? src.bind_id : undefined,
            options: clonedOptions,
        } as typeof src;

        // map: oldOptId -> newOptId (only if options exist)
        const optionIdMap = new Map<string, string>();
        (src.options ?? []).forEach((o, i) => {
            const newOptId = clonedOptions[i]?.id ?? o.id;
            optionIdMap.set(o.id, newOptId);
        });

        this.patchProps((p) => {
            // insert clone after original
            const arr = p.fields ?? [];
            const idx = arr.findIndex((f) => f.id === fieldId);
            arr.splice(idx + 1, 0, cloned as any);
            p.fields = arr;

            // copy tag-level includes/excludes (field ids)
            if (opts.copyIncludesExcludes) {
                for (const t of p.filters ?? []) {
                    if (t.includes?.includes(fieldId)) {
                        const s = new Set(t.includes);
                        s.add(id);
                        t.includes = Array.from(s);
                    }
                    if (t.excludes?.includes(fieldId)) {
                        const s = new Set(t.excludes);
                        s.add(id);
                        t.excludes = Array.from(s);
                    }
                }
            }

            // copy button maps (keys are only field ids OR option ids)
            if (opts.copyOptionMaps) {
                const maps: Array<
                    "includes_for_buttons" | "excludes_for_buttons"
                > = ["includes_for_buttons", "excludes_for_buttons"];

                for (const mapKey of maps) {
                    const srcMap = (p as any)[mapKey] ?? {};
                    const nextMap: Record<string, string[]> = { ...srcMap };

                    for (const [key, targets] of Object.entries(
                        srcMap as Record<string, string[]>,
                    )) {
                        // A) non-option button: key === original field id → duplicate under new field id
                        if (key === fieldId) {
                            const newKey = id;
                            const merged = new Set([
                                ...(nextMap[newKey] ?? []),
                                ...targets,
                            ]);
                            nextMap[newKey] = Array.from(merged);
                            continue;
                        }

                        // B) option button: key === one of the original option ids → duplicate under new option id
                        if (optionIdMap.has(key)) {
                            const newKey = optionIdMap.get(key)!;
                            const merged = new Set([
                                ...(nextMap[newKey] ?? []),
                                ...targets,
                            ]);
                            nextMap[newKey] = Array.from(merged);
                        }
                    }

                    (p as any)[mapKey] = nextMap;
                }
            }
        });

        return id;
    }

    private duplicateOption(
        fieldId: string,
        optionId: string,
        opts: DuplicateOptions,
    ): string {
        const props = this.builder.getProps();
        const fields = props.fields ?? [];
        const f = fields.find((x) => x.id === fieldId);
        if (!f) throw new Error(`Field not found: ${fieldId}`);
        const optIdx = (f.options ?? []).findIndex((o) => o.id === optionId);
        if (optIdx < 0)
            throw new Error(`Option not found: ${fieldId}::${optionId}`);
        const src = (f.options ?? [])[optIdx];

        const newId = this.uniqueOptionId(
            fieldId,
            (opts.optionIdStrategy ?? defaultOptionIdStrategy)(src.id),
        );
        const newLabel = (opts.labelStrategy ?? nextCopyLabel)(
            src.label ?? src.id,
        );

        this.patchProps((p) => {
            const fld = (p.fields ?? []).find((x) => x.id === fieldId)!;
            const arr = fld.options ?? [];
            const clone = { ...src, id: newId, label: newLabel };
            arr.splice(optIdx + 1, 0, clone);
            fld.options = arr;

            // Option-level maps are NOT copied by default (safer)
            if (opts.copyOptionMaps) {
                const oldKey = `${fieldId}::${optionId}`;
                const newKey = `${fieldId}::${newId}`;
                for (const mapKey of [
                    "includes_for_buttons",
                    "excludes_for_buttons",
                ] as const) {
                    const m = p[mapKey] ?? {};
                    if (m[oldKey]) {
                        m[newKey] = Array.from(new Set(m[oldKey]));
                        p[mapKey] = m as any;
                    }
                }
            }
        });

        return newId;
    }

    /* ───────────────────── Helpers: uniqueness & naming ───────────────────── */

    private uniqueId(base: string): string {
        const props = this.builder.getProps();
        const taken = new Set<string>([
            ...(props.filters ?? []).map((t) => t.id),
            ...(props.fields ?? []).map((f) => f.id),
        ]);
        let candidate = nextCopyId(base);
        while (taken.has(candidate)) candidate = bumpSuffix(candidate);
        return candidate;
    }

    private uniqueOptionId(fieldId: string, base: string): string {
        const props = this.builder.getProps();
        const fld = (props.fields ?? []).find((f) => f.id === fieldId);
        const taken = new Set((fld?.options ?? []).map((o) => o.id));
        let candidate = base;
        if (taken.has(candidate)) candidate = nextCopyId(candidate);
        while (taken.has(candidate)) candidate = bumpSuffix(candidate);
        return candidate;
    }

    //---------

    /**
     * Reorder a node:
     * - Tag: among its siblings (same bind_id) inside filters[]
     * - Field: inside order_for_tags[scopeTagId] (you must pass scopeTagId)
     * - Option: use placeOption() instead
     */
    placeNode(
        id: string,
        opts: {
            scopeTagId?: string;
            beforeId?: string;
            afterId?: string;
            index?: number;
        },
    ) {
        if (isTagId(id)) {
            // … your existing tag sibling reorder logic …
            this.exec({
                name: "placeTag",
                do: () =>
                    this.patchProps((p) => {
                        const all = p.filters ?? [];
                        const cur = all.find((t) => t.id === id);
                        if (!cur) return;
                        const groupKey = cur.bind_id ?? "__root__";
                        const siblings = all.filter(
                            (t) => (t.bind_id ?? "__root__") === groupKey,
                        );

                        const curIdx = siblings.findIndex((t) => t.id === id);
                        if (curIdx < 0) return;
                        const pulled = siblings.splice(curIdx, 1)[0];

                        let dest =
                            typeof opts.index === "number"
                                ? opts.index
                                : undefined;
                        if (opts.beforeId)
                            dest = Math.max(
                                0,
                                siblings.findIndex(
                                    (t) => t.id === opts.beforeId,
                                ),
                            );
                        if (opts.afterId)
                            dest = Math.min(
                                siblings.length,
                                siblings.findIndex(
                                    (t) => t.id === opts.afterId,
                                ) + 1,
                            );
                        if (dest === undefined || Number.isNaN(dest))
                            dest = siblings.length;

                        // stitch back: leave other groups untouched, replace this group in order
                        const out: Tag[] = [];
                        for (const t of all) {
                            const sameGroup =
                                (t.bind_id ?? "__root__") === groupKey;
                            if (!sameGroup) {
                                out.push(t);
                            }
                            // if (!used.has(t.id) && t.id !== id) continue; // skip old group entries
                        }
                        siblings.splice(dest, 0, pulled);
                        p.filters = [...out, ...siblings];
                    }),
                undo: () => this.api.undo(),
            });
        } else if (isFieldId(id)) {
            if (!opts.scopeTagId)
                throw new Error("placeNode(field): scopeTagId is required");
            const fieldId = id;
            const tagId = opts.scopeTagId;

            this.exec({
                name: "placeField",
                do: () =>
                    this.patchProps((p) => {
                        const map = (p.order_for_tags ??= {});
                        const arr = (map[tagId] ??= []);
                        const curIdx = arr.indexOf(fieldId);
                        if (curIdx >= 0) arr.splice(curIdx, 1);

                        let dest =
                            typeof opts.index === "number"
                                ? opts.index
                                : undefined;
                        if (opts.beforeId)
                            dest = Math.max(0, arr.indexOf(opts.beforeId));
                        if (opts.afterId)
                            dest = Math.min(
                                arr.length,
                                arr.indexOf(opts.afterId) + 1,
                            );
                        if (dest === undefined || Number.isNaN(dest))
                            dest = arr.length;

                        arr.splice(dest, 0, fieldId);
                    }),
                undo: () => this.api.undo(),
            });
        } else if (isOptionId(id)) {
            // defer to placeOption for options
            this.placeOption(id, opts);
        } else {
            throw new Error("placeNode: unknown id prefix");
        }
    }

    placeOption(
        optionId: string,
        opts: { beforeId?: string; afterId?: string; index?: number },
    ) {
        if (!isOptionId(optionId))
            throw new Error('placeOption: optionId must start with "o:"');

        this.exec({
            name: "placeOption",
            do: () =>
                this.patchProps((p) => {
                    const owner = ownerOfOption(p, optionId);
                    if (!owner) return;
                    const f = (p.fields ?? []).find(
                        (x) => x.id === owner.fieldId,
                    );
                    if (!f?.options) return;

                    const curIdx = f.options.findIndex(
                        (o) => o.id === optionId,
                    );
                    if (curIdx < 0) return;

                    const pulled = f.options.splice(curIdx, 1)[0];

                    let dest =
                        typeof opts.index === "number" ? opts.index : undefined;
                    if (opts.beforeId)
                        dest = Math.max(
                            0,
                            f.options.findIndex((o) => o.id === opts.beforeId),
                        );
                    if (opts.afterId)
                        dest = Math.min(
                            f.options.length,
                            f.options.findIndex((o) => o.id === opts.afterId) +
                                1,
                        );
                    if (dest === undefined || Number.isNaN(dest))
                        dest = f.options.length;

                    f.options.splice(dest, 0, pulled);
                }),
            undo: () => this.api.undo(),
        });
    }

    addOption(
        fieldId: string,
        input: {
            id?: string;
            label: string;
            service_id?: number;
            pricing_role?: "base" | "utility" | "addon";
            [k: string]: any;
        },
    ): string {
        // decide id up-front so we can return synchronously
        const id = input.id ?? this.genId("o");

        this.exec({
            name: "addOption",
            do: () =>
                this.patchProps((p) => {
                    const f = (p.fields ?? []).find((x) => x.id === fieldId);
                    if (!f)
                        throw new Error(
                            `addOption: field '${fieldId}' not found`,
                        );
                    const list = (f.options ??= []);
                    if (list.some((o) => o.id === id))
                        throw new Error(`Option id '${id}' already exists`);
                    // @ts-ignore
                    list.push({ ...input, id });
                }),
            undo: () => this.api.undo(),
        });

        return id;
    }

    updateOption(
        optionId: string,
        patch: Partial<
            {
                label: string;
                service_id: number;
                pricing_role: "base" | "utility" | "addon";
            } & Record<string, any>
        >,
    ) {
        if (!isOptionId(optionId))
            throw new Error('updateOption: optionId must start with "o:"');
        this.exec({
            name: "updateOption",
            do: () =>
                this.patchProps((p) => {
                    const owner = ownerOfOption(p, optionId);
                    if (!owner) return;
                    const f = (p.fields ?? []).find(
                        (x) => x.id === owner.fieldId,
                    );
                    if (!f?.options) return;
                    const o = f.options.find((x) => x.id === optionId);
                    if (o) Object.assign(o, patch);
                }),
            undo: () => this.api.undo(),
        });
    }

    removeOption(optionId: string) {
        if (!isOptionId(optionId))
            throw new Error('removeOption: optionId must start with "o:"');
        this.exec({
            name: "removeOption",
            do: () =>
                this.patchProps((p) => {
                    const owner = ownerOfOption(p, optionId);
                    if (!owner) return;
                    const f = (p.fields ?? []).find(
                        (x) => x.id === owner.fieldId,
                    );
                    if (!f?.options) return;
                    f.options = f.options.filter((o) => o.id !== optionId);

                    // prune option-level include/exclude maps keyed by the option id
                    const maps: Array<
                        "includes_for_options" | "excludes_for_options"
                    > = ["includes_for_options", "excludes_for_options"];
                    for (const m of maps) {
                        const map = (p as any)[m] as
                            | Record<string, string[]>
                            | undefined;
                        if (!map) continue;
                        if (map[optionId]) delete map[optionId];
                        if (!Object.keys(map).length) delete (p as any)[m];
                    }
                }),
            undo: () => this.api.undo(),
        });
    }

    editLabel(id: string, label: string): void {
        const next = (label ?? "").trim();
        if (!next) throw new Error("Label cannot be empty");

        this.exec({
            name: "editLabel",
            do: () =>
                this.patchProps((p) => {
                    if (isTagId(id)) {
                        const t = (p.filters ?? []).find((x) => x.id === id);
                        if (t) t.label = next;
                        return;
                    }
                    if (isFieldId(id)) {
                        const f = (p.fields ?? []).find((x) => x.id === id);
                        if (f) f.label = next;
                        return;
                    }
                    if (isOptionId(id)) {
                        const own = ownerOfOption(p, id);
                        if (!own) return;
                        const f = (p.fields ?? []).find(
                            (x) => x.id === own.fieldId,
                        );
                        const o = f?.options?.find((x) => x.id === id);
                        if (o) o.label = next;
                        return;
                    }
                    throw new Error("editLabel: unsupported id");
                }),
            undo: () => this.api.undo(),
        });
    }

    editName(fieldId: string, name: string | undefined) {
        this.exec({
            name: "editName",
            do: () =>
                this.patchProps((p) => {
                    const f = (p.fields ?? []).find((x) => x.id === fieldId);
                    if (!f) return;
                    f.name = name;
                }),
            undo: () => this.api.undo(),
        });
    }

    setService(
        id: string,
        input: { service_id?: number; pricing_role?: "base" | "utility" },
    ): void {
        this.exec({
            name: "setService",
            do: () =>
                this.patchProps((p) => {
                    const hasSidKey = Object.prototype.hasOwnProperty.call(
                        input,
                        "service_id",
                    );
                    const validId =
                        hasSidKey &&
                        typeof input.service_id === "number" &&
                        Number.isFinite(input.service_id);
                    const sid: number | undefined = validId
                        ? Number(input.service_id)
                        : undefined;
                    const nextRole = input.pricing_role;

                    // ── TAG ───────────────────────────────────────────────────
                    if (isTagId(id)) {
                        const t = (p.filters ?? []).find((x) => x.id === id);
                        if (!t) return;

                        // role not applicable for tags
                        if (hasSidKey) {
                            if (sid === undefined) delete (t as any).service_id;
                            else t.service_id = sid;
                        }
                        return;
                    }

                    // ── OPTION ───────────────────────────────────────────────
                    if (isOptionId(id)) {
                        const own = ownerOfOption(p, id);
                        if (!own) return;
                        const f = (p.fields ?? []).find(
                            (x) => x.id === own.fieldId,
                        );
                        const o = f?.options?.find((x) => x.id === id);
                        if (!o) return;

                        const currentRole = (o.pricing_role ?? "base") as
                            | "base"
                            | "utility";
                        const role = nextRole ?? currentRole;

                        if (role === "utility") {
                            // Utilities cannot have service_id, and if switching to utility, strip any existing sid.
                            if (hasSidKey && sid !== undefined) {
                                this.api.emit("error", {
                                    message:
                                        "Utilities cannot have service_id (option).",
                                    code: "utility_service_conflict",
                                    meta: { id, service_id: sid },
                                });
                            }
                            o.pricing_role = "utility";
                            if ("service_id" in o) delete (o as any).service_id;
                            return;
                        }

                        // role === 'base'
                        if (nextRole) o.pricing_role = "base";
                        if (hasSidKey) {
                            if (sid === undefined) delete (o as any).service_id;
                            else o.service_id = sid;
                        }
                        return;
                    }

                    // ── FIELD (button-able) ─────────────────────────────────
                    // Field ids usually look like "f:*" in your project; we’ll treat any non-tag/non-option as field.
                    const f = (p.fields ?? []).find((x) => x.id === id);
                    if (!f) {
                        throw new Error(
                            'setService only supports tag ("t:*"), option ("o:*"), or field ("f:*") ids',
                        );
                    }

                    const isOptionBased =
                        Array.isArray(f.options) && f.options.length > 0;
                    const isButton = !!(f as any).button;

                    // Move/normalize role at field level if provided
                    if (nextRole) {
                        f.pricing_role = nextRole;
                    }
                    const effectiveRole = (f.pricing_role ?? "base") as
                        | "base"
                        | "utility";

                    // If the field is option-based, services must live on options, not on the field.
                    if (isOptionBased) {
                        if (hasSidKey) {
                            this.api.emit("error", {
                                message:
                                    "Cannot set service_id on an option-based field. Assign service_id on its options instead.",
                                code: "field_option_based_service_forbidden",
                                meta: { id, service_id: sid },
                            });
                        }
                        // Still allow changing pricing_role at field level (acts as a default for options),
                        // but never write/keep service_id on the field itself.
                        if ("service_id" in (f as any))
                            delete (f as any).service_id;
                        return;
                    }

                    // For non-option fields, only "button" fields are allowed to carry a service_id.
                    if (!isButton) {
                        if (hasSidKey) {
                            this.api.emit("error", {
                                message:
                                    "Only button fields (without options) can have a service_id.",
                                code: "non_button_field_service_forbidden",
                                meta: { id, service_id: sid },
                            });
                        }
                        // Ensure we don't keep any stray sid
                        if ("service_id" in (f as any))
                            delete (f as any).service_id;
                        return;
                    }

                    // Button field + role checks
                    if (effectiveRole === "utility") {
                        // Utilities cannot have service_id at all.
                        if (hasSidKey && sid !== undefined) {
                            this.api.emit("error", {
                                message:
                                    "Utilities cannot have service_id (field).",
                                code: "utility_service_conflict",
                                meta: { id, service_id: sid },
                            });
                        }
                        if ("service_id" in (f as any))
                            delete (f as any).service_id;
                        return;
                    }

                    // Button field with role 'base' → allow setting/clearing sid
                    if (hasSidKey) {
                        if (sid === undefined) delete (f as any).service_id;
                        else (f as any).service_id = sid;
                    }
                }),
            undo: () => this.api.undo(),
        });
    }

    addTag(
        partial: Omit<Tag, "id" | "label"> & { id?: string; label: string },
    ) {
        const id = partial.id ?? this.genId("t");
        const payload = { ...partial, id };
        this.exec({
            name: "addTag",
            do: () =>
                this.patchProps((p) => {
                    p.filters = [...(p.filters ?? []), payload];
                }),
            undo: () =>
                this.patchProps((p) => {
                    p.filters = (p.filters ?? []).filter((t) => t.id !== id);
                }),
        });
    }

    updateTag(id: string, patch: Partial<Tag>) {
        let prev: Tag | undefined;
        this.exec({
            name: "updateTag",
            do: () =>
                this.patchProps((p) => {
                    p.filters = (p.filters ?? []).map((t) => {
                        if (t.id !== id) return t;
                        prev = t;
                        return { ...t, ...patch };
                    });
                }),
            undo: () =>
                this.patchProps((p) => {
                    p.filters = (p.filters ?? []).map((t) =>
                        t.id === id && prev ? prev : t,
                    );
                }),
        });
    }

    removeTag(id: string) {
        let prevSlice!: ServiceProps;
        this.exec({
            name: "removeTag",
            do: () =>
                this.patchProps((p) => {
                    prevSlice = cloneDeep(p);
                    // noinspection DuplicatedCode
                    p.filters = (p.filters ?? []).filter((t) => t.id !== id);
                    // drop references
                    for (const t of p.filters ?? []) {
                        if (t.bind_id === id) delete t.bind_id;
                        t.includes = (t.includes ?? []).filter((x) => x !== id);
                        t.excludes = (t.excludes ?? []).filter((x) => x !== id);
                    }
                    for (const f of p.fields ?? []) {
                        if (Array.isArray(f.bind_id))
                            f.bind_id = f.bind_id.filter((x) => x !== id);
                        else if (f.bind_id === id) delete f.bind_id;
                    }
                }),
            undo: () => this.replaceProps(prevSlice),
        });
    }

    addField(
        partial: Omit<Field, "id" | "label" | "type"> & {
            id?: string;
            label: string;
            type: Field["type"];
        },
    ) {
        const id = partial.id ?? this.genId("f");
        const payload = { ...partial, id };
        this.exec({
            name: "addField",
            do: () =>
                this.patchProps((p) => {
                    p.fields = [...(p.fields ?? []), payload as Field];
                }),
            undo: () =>
                this.patchProps((p) => {
                    p.fields = (p.fields ?? []).filter((f) => f.id !== id);
                }),
        });
    }

    updateField(id: string, patch: Partial<Field>) {
        let prev: Field | undefined;
        this.exec({
            name: "updateField",
            do: () =>
                this.patchProps((p) => {
                    // @ts-ignore
                    p.fields = (p.fields ?? []).map((f) => {
                        if (f.id !== id) return f;
                        prev = f;
                        return { ...f, ...patch };
                    });
                }),
            undo: () =>
                this.patchProps((p) => {
                    p.fields = (p.fields ?? []).map((f) =>
                        f.id === id && prev ? prev : f,
                    );
                }),
        });
    }

    removeField(id: string) {
        let prevSlice!: ServiceProps;
        this.exec({
            name: "removeField",
            do: () =>
                this.patchProps((p) => {
                    prevSlice = cloneDeep(p);
                    p.fields = (p.fields ?? []).filter((f) => f.id !== id);
                    // prune option maps that reference this field
                    for (const mapKey of [
                        "includes_for_buttons",
                        "excludes_for_buttons",
                    ] as const) {
                        const m = p[mapKey];
                        if (!m) continue;
                        for (const k of Object.keys(m)) {
                            m[k] = (m[k] ?? []).filter((fid) => fid !== id);
                            if (!m[k]?.length) delete m[k];
                        }
                    }
                    for (const t of p.filters ?? []) {
                        t.includes = (t.includes ?? []).filter((x) => x !== id);
                        t.excludes = (t.excludes ?? []).filter((x) => x !== id);
                    }
                }),
            undo: () => this.replaceProps(prevSlice),
        });
    }

    remove(id: string) {
        if (isTagId(id)) {
            this.exec({
                name: "removeTag",
                do: () =>
                    this.patchProps((p) => {
                        // noinspection DuplicatedCode
                        p.filters = (p.filters ?? []).filter(
                            (t) => t.id !== id,
                        );

                        // detach children + prune includes/excludes references
                        for (const t of p.filters ?? []) {
                            if (t.bind_id === id) delete t.bind_id;
                            t.includes = (t.includes ?? []).filter(
                                (x) => x !== id,
                            );
                            t.excludes = (t.excludes ?? []).filter(
                                (x) => x !== id,
                            );
                        }

                        // remove tag from field.bind_id arrays
                        for (const f of p.fields ?? []) {
                            if (Array.isArray(f.bind_id))
                                f.bind_id = f.bind_id.filter(
                                    (x) => x !== id,
                                ) as any;
                            else if (f.bind_id === id) delete f.bind_id;
                        }

                        // prune per-tag ordering entry and stale field ids
                        if (p.order_for_tags?.[id]) delete p.order_for_tags[id];
                        for (const k of Object.keys(p.order_for_tags ?? {})) {
                            p.order_for_tags![k] = (
                                p.order_for_tags![k] ?? []
                            ).filter((fid) =>
                                (p.fields ?? []).some((f) => f.id === fid),
                            );
                            if (!p.order_for_tags![k].length)
                                delete p.order_for_tags![k];
                        }
                    }),
                undo: () => this.api.undo(),
            });
            return;
        }

        if (isFieldId(id)) {
            this.exec({
                name: "removeField",
                do: () =>
                    this.patchProps((p) => {
                        p.fields = (p.fields ?? []).filter((f) => f.id !== id);

                        // prune tag includes/excludes
                        for (const t of p.filters ?? []) {
                            t.includes = (t.includes ?? []).filter(
                                (x) => x !== id,
                            );
                            t.excludes = (t.excludes ?? []).filter(
                                (x) => x !== id,
                            );
                        }

                        // prune per-tag ordering
                        for (const k of Object.keys(p.order_for_tags ?? {})) {
                            p.order_for_tags![k] = (
                                p.order_for_tags![k] ?? []
                            ).filter((fid) => fid !== id);
                            if (!p.order_for_tags![k].length)
                                delete p.order_for_tags![k];
                        }

                        // prune option maps that reference this field id
                        const maps: Array<
                            "includes_for_options" | "excludes_for_options"
                        > = ["includes_for_options", "excludes_for_options"];
                        for (const m of maps) {
                            const map = (p as any)[m] as
                                | Record<string, string[]>
                                | undefined;
                            if (!map) continue;
                            for (const key of Object.keys(map)) {
                                map[key] = (map[key] ?? []).filter(
                                    (fid) => fid !== id,
                                );
                                if (!map[key]?.length) delete map[key];
                            }
                            if (!Object.keys(map).length) delete (p as any)[m];
                        }
                    }),
                undo: () => this.api.undo(),
            });
            return;
        }

        if (isOptionId(id)) {
            this.removeOption(id);
            return;
        }

        throw new Error("remove: unknown id prefix");
    }

    getNode(
        id: string,
    ):
        | { kind: "tag"; data?: Tag; owners: { parentTagId?: string } }
        | { kind: "field"; data?: Field; owners: { bindTagIds: string[] } }
        | { kind: "option"; data?: any; owners: { fieldId?: string } } {
        const props = this.builder.getProps();
        if (isTagId(id)) {
            const t = (props.filters ?? []).find((x) => x.id === id);
            return {
                kind: "tag",
                data: t,
                owners: { parentTagId: t?.bind_id },
            };
        }
        if (isFieldId(id)) {
            const f = (props.fields ?? []).find((x) => x.id === id);
            const bind = Array.isArray(f?.bind_id)
                ? (f!.bind_id as string[])
                : f?.bind_id
                  ? [f.bind_id]
                  : [];
            return { kind: "field", data: f, owners: { bindTagIds: bind } };
        }
        if (isOptionId(id)) {
            const own = ownerOfOption(props, id);
            const f = own
                ? (props.fields ?? []).find((x) => x.id === own.fieldId)
                : undefined;
            const o = f?.options?.find((x) => x.id === id);
            return {
                kind: "option",
                data: o,
                owners: { fieldId: own?.fieldId },
            };
        }
        // you can extend for service lookup if desired
        return { kind: "option", data: undefined, owners: {} };
    }

    getFieldQuantityRule(id: string): QuantityRule | undefined {
        const props = this.builder.getProps();
        const f = (props.fields ?? []).find((x) => x.id === id);
        if (!f) return undefined;
        return normalizeQuantityRule((f as any).meta?.quantity);
    }

    setFieldQuantityRule(id: string, rule: unknown): void {
        this.exec({
            name: "setFieldQuantityRule",
            do: () =>
                this.patchProps((p) => {
                    const f = (p.fields ?? []).find((x) => x.id === id);
                    if (!f) return;

                    const normalized = normalizeQuantityRule(rule);

                    if (!normalized) {
                        // Drop invalid shapes entirely
                        if ((f as any).meta?.quantity !== undefined) {
                            delete (f as any).meta.quantity;
                            // Clean up empty meta object
                            if (
                                (f as any).meta &&
                                Object.keys((f as any).meta).length === 0
                            ) {
                                delete (f as any).meta;
                            }
                        }
                        return;
                    }

                    // Keep other meta keys intact
                    (f as any).meta = {
                        ...(f as any).meta,
                        quantity: normalized,
                    };
                }),
            undo: () => this.api.undo(),
        });
    }

    clearFieldQuantityRule(id: string): void {
        this.exec({
            name: "clearFieldQuantityRule",
            do: () =>
                this.patchProps((p) => {
                    const f = (p.fields ?? []).find((x) => x.id === id);
                    if (!f || !(f as any).meta?.quantity) return;
                    delete (f as any).meta.quantity;
                    if (
                        (f as any).meta &&
                        Object.keys((f as any).meta).length === 0
                    ) {
                        delete (f as any).meta;
                    }
                }),
            undo: () => this.api.undo(),
        });
    }

    /** Walk ancestors for a tag and detect if parent→child would create a cycle */
    private wouldCreateTagCycle(
        p: ServiceProps,
        parentId: string,
        childId: string,
    ): boolean {
        if (parentId === childId) return true;
        const tagById = new Map((p.filters ?? []).map((t) => [t.id, t]));
        let cur: string | undefined = parentId;
        const guard = new Set<string>();
        while (cur) {
            if (cur === childId) return true; // child is ancestor of parent → cycle
            if (guard.has(cur)) break;
            guard.add(cur);
            cur = tagById.get(cur)?.bind_id;
        }
        return false;
    }

    /* ──────────────────────────────────────────────────────────────────────────
     * CONNECT
     * ────────────────────────────────────────────────────────────────────────── */
    connect(kind: WireKind, fromId: string, toId: string): void {
        this.exec({
            name: `connect:${kind}`,
            do: () =>
                this.patchProps((p) => {
                    /* ── BIND ─────────────────────────────────────────────── */
                    if (kind === "bind") {
                        // Tag → Tag: set child.bind_id = parent (cycle-safe)
                        if (isTagId(fromId) && isTagId(toId)) {
                            if (this.wouldCreateTagCycle(p, fromId, toId)) {
                                throw new Error(
                                    `bind would create a cycle: ${fromId} → ${toId}`,
                                );
                            }
                            const child = (p.filters ?? []).find(
                                (t) => t.id === toId,
                            );
                            if (child) child.bind_id = fromId;
                            return;
                        }
                        // Tag → Field (or Field → Tag): ensure field.bind_id contains the tag
                        if (
                            (isTagId(fromId) && isFieldId(toId)) ||
                            (isFieldId(fromId) && isTagId(toId))
                        ) {
                            const fieldId = isFieldId(toId) ? toId : fromId;
                            const tagId = isTagId(fromId) ? fromId : toId;
                            const f = (p.fields ?? []).find(
                                (x) => x.id === fieldId,
                            );
                            if (!f) return;
                            if (!f.bind_id) {
                                f.bind_id = tagId;
                                return;
                            }
                            if (typeof f.bind_id === "string") {
                                if (f.bind_id !== tagId)
                                    f.bind_id = [f.bind_id, tagId];
                                return;
                            }
                            if (!f.bind_id.includes(tagId))
                                f.bind_id.push(tagId);
                            return;
                        }
                        throw new Error(
                            `bind: unsupported route ${fromId} → ${toId}`,
                        );
                    }

                    /* ── INCLUDE / EXCLUDE (Tag→Field, Option→Field) ──────── */
                    if (kind === "include" || kind === "exclude") {
                        const key =
                            kind === "include" ? "includes" : "excludes";

                        // Tag → Field: mutate tag.includes/excludes
                        if (isTagId(fromId) && isFieldId(toId)) {
                            const t = (p.filters ?? []).find(
                                (x) => x.id === fromId,
                            );
                            if (!t) return;
                            const arr = (t[key] ??= []);
                            if (!arr.includes(toId)) arr.push(toId);
                            return;
                        }

                        // Option → Field: mutate includes_for_options / excludes_for_options using optionId
                        if (isOptionId(fromId) && isFieldId(toId)) {
                            const mapKey =
                                kind === "include"
                                    ? "includes_for_options"
                                    : "excludes_for_options";
                            const maps = (p as any)[mapKey] as
                                | Record<string, string[]>
                                | undefined;
                            const next = { ...(maps ?? {}) };
                            const arr = next[fromId] ?? [];
                            if (!arr.includes(toId)) arr.push(toId);
                            next[fromId] = arr;
                            (p as any)[mapKey] = next;
                            return;
                        }

                        throw new Error(
                            `${kind}: unsupported route ${fromId} → ${toId}`,
                        );
                    }

                    /* ── SERVICE (Service→Tag | Service→Option) ───────────── */
                    // inside connect(kind, from, to)
                    if (kind === "service") {
                        // ONLY ensure it exists; no type checks/parsing
                        ensureServiceExists(this.opts, fromId);

                        if (toId.startsWith("t:")) {
                            this.exec({
                                name: "connect:service→tag",
                                do: () =>
                                    this.patchProps((p) => {
                                        const t = (p.filters ?? []).find(
                                            (x) => x.id === toId,
                                        );
                                        if (t) (t as any).service_id = fromId; // store as-is
                                    }),
                                undo: () => this.api.undo(),
                            });
                            return;
                        }

                        if (toId.startsWith("o:")) {
                            this.exec({
                                name: "connect:service→option",
                                do: () =>
                                    this.patchProps((p) => {
                                        for (const f of p.fields ?? []) {
                                            const o = f.options?.find(
                                                (x) => x.id === toId,
                                            );
                                            if (o) {
                                                (o as any).service_id = fromId;
                                                return;
                                            }
                                        }
                                    }),
                                undo: () => this.api.undo(),
                            });
                            return;
                        }

                        throw new Error(
                            'service: to must be a tag ("t:*") or option ("o:*")',
                        );
                    }

                    throw new Error(`Unknown connect kind: ${kind}`);
                }),
            undo: () => this.api.undo(), // snapshot-based undo will restore prior state
        });
    }

    /* ──────────────────────────────────────────────────────────────────────────
     * DISCONNECT
     * ────────────────────────────────────────────────────────────────────────── */
    disconnect(kind: WireKind, fromId: string, toId: string): void {
        this.exec({
            name: `disconnect:${kind}`,
            do: () =>
                this.patchProps((p) => {
                    /* ── BIND ─────────────────────────────────────────────── */
                    if (kind === "bind") {
                        // Tag → Tag
                        if (isTagId(fromId) && isTagId(toId)) {
                            const child = (p.filters ?? []).find(
                                (t) => t.id === toId,
                            );
                            if (child?.bind_id === fromId) delete child.bind_id;
                            return;
                        }
                        // Tag ↔ Field
                        if (
                            (isTagId(fromId) && isFieldId(toId)) ||
                            (isFieldId(fromId) && isTagId(toId))
                        ) {
                            const fieldId = isFieldId(toId) ? toId : fromId;
                            const tagId = isTagId(fromId) ? fromId : toId;
                            const f = (p.fields ?? []).find(
                                (x) => x.id === fieldId,
                            );
                            if (!f?.bind_id) return;
                            if (typeof f.bind_id === "string") {
                                if (f.bind_id === tagId) delete f.bind_id;
                                return;
                            }
                            f.bind_id = f.bind_id.filter(
                                (x) => x !== tagId,
                            ) as any;
                            if (f.bind_id?.length === 0) delete f.bind_id;
                            return;
                        }
                        throw new Error(
                            `unbind: unsupported route ${fromId} → ${toId}`,
                        );
                    }

                    /* ── INCLUDE / EXCLUDE (Tag→Field, Option→Field) ──────── */
                    if (kind === "include" || kind === "exclude") {
                        const key =
                            kind === "include" ? "includes" : "excludes";

                        // Tag → Field
                        if (isTagId(fromId) && isFieldId(toId)) {
                            const t = (p.filters ?? []).find(
                                (x) => x.id === fromId,
                            );
                            if (!t) return;
                            t[key] = (t[key] ?? []).filter((x) => x !== toId);
                            if (!t[key]?.length) delete (t as any)[key];
                            return;
                        }

                        // Option → Field
                        if (isOptionId(fromId) && isFieldId(toId)) {
                            const mapKey =
                                kind === "include"
                                    ? "includes_for_options"
                                    : "excludes_for_options";
                            const maps = (p as any)[mapKey] as
                                | Record<string, string[]>
                                | undefined;
                            if (!maps) return;
                            if (maps[fromId]) {
                                maps[fromId] = (maps[fromId] ?? []).filter(
                                    (fid) => fid !== toId,
                                );
                                if (!maps[fromId]?.length) delete maps[fromId];
                            }
                            if (!Object.keys(maps).length)
                                delete (p as any)[mapKey];
                            return;
                        }

                        throw new Error(
                            `${kind}: unsupported route ${fromId} → ${toId}`,
                        );
                    }

                    /* ── SERVICE (Service→Tag | Service→Option) ───────────── */
                    if (kind === "service") {
                        // STILL only ensure it exists; no type checks/parsing
                        ensureServiceExists(this.opts, fromId);

                        if (toId.startsWith("t:")) {
                            this.exec({
                                name: "disconnect:service→tag",
                                do: () =>
                                    this.patchProps((p) => {
                                        const t = (p.filters ?? []).find(
                                            (x) => x.id === toId,
                                        );
                                        if (t) delete (t as any).service_id;
                                    }),
                                undo: () => this.api.undo(),
                            });
                            return;
                        }

                        if (toId.startsWith("o:")) {
                            this.exec({
                                name: "disconnect:service→option",
                                do: () =>
                                    this.patchProps((p) => {
                                        for (const f of p.fields ?? []) {
                                            const o = f.options?.find(
                                                (x) => x.id === toId,
                                            );
                                            if (o) {
                                                delete (o as any).service_id;
                                                return;
                                            }
                                        }
                                    }),
                                undo: () => this.api.undo(),
                            });
                            return;
                        }

                        throw new Error(
                            'service: to must be a tag ("t:*") or option ("o:*")',
                        );
                    }

                    throw new Error(`Unknown disconnect kind: ${kind}`);
                }),
            undo: () => this.api.undo(),
        });
    }

    setConstraint(
        tagId: string,
        flag: "refill" | "cancel" | "dripfeed",
        value: boolean | undefined,
    ) {
        let prev: boolean | undefined;
        this.exec({
            name: "setConstraint",
            do: () =>
                this.patchProps((p) => {
                    const t = (p.filters ?? []).find((x) => x.id === tagId);
                    if (!t) return;
                    prev = t.constraints?.[flag];
                    if (!t.constraints) t.constraints = {};
                    if (value === undefined) delete t.constraints[flag];
                    else t.constraints[flag] = value;
                }),
            undo: () =>
                this.patchProps((p) => {
                    const t = (p.filters ?? []).find((x) => x.id === tagId);
                    if (!t) return;
                    if (!t.constraints) t.constraints = {};
                    if (prev === undefined) delete t.constraints[flag];
                    else t.constraints[flag] = prev;
                }),
        });
        // After mutation, normalise() will propagate effective constraints & meta
    }

    /* ───────────────────── Internals ───────────────────── */

    private replaceProps(next: ServiceProps): void {
        // Ensure canonical shape + constraint propagation
        const norm = normalise(next);
        this.builder.load(norm);
        this.api.refreshGraph();
    }

    private patchProps(mut: (p: ServiceProps) => void): void {
        const cur = cloneDeep(this.builder.getProps());
        mut(cur);
        this.replaceProps(cur);
    }

    private afterMutation(command: string, _before: EditorSnapshot) {
        if (this.txnDepth > 0) return; // delay until commit()
        this.pushHistory(this.makeSnapshot(command));
        this.emit("editor:command", { name: command });
        if (this.opts.validateAfterEach)
            this.emit("editor:change", {
                props: this.builder.getProps(),
                reason: "validate",
                command,
            });
        else
            this.emit("editor:change", {
                props: this.builder.getProps(),
                reason: "mutation",
                command,
            });
    }

    private commit(label: string) {
        const snap = this.makeSnapshot(label);
        this.pushHistory(snap);
        this.emit("editor:change", {
            props: snap.props,
            reason: "transaction",
            command: this.txnLabel,
        });
    }

    private makeSnapshot(_why: string): EditorSnapshot {
        const props = cloneDeep(this.builder.getProps());
        const canvas = this.api.snapshot();
        return {
            props,
            layout: {
                canvas,
            },
        };
    }

    private loadSnapshot(s: EditorSnapshot, reason: "undo" | "redo") {
        this.builder.load(cloneDeep(s.props));

        const layout = s.layout;
        const canvas = layout?.canvas;

        if (canvas) {
            if (canvas.positions) this.api.setPositions(canvas.positions);
            if (canvas.viewport) this.api.setViewport(canvas.viewport);
            if (canvas.selection)
                this.api.select(
                    Array.isArray(canvas.selection)
                        ? canvas.selection
                        : Array.from(canvas.selection),
                );
        } else {
            this.api.refreshGraph();
        }
        this.emit("editor:change", { props: this.builder.getProps(), reason });
    }

    private pushHistory(snap: EditorSnapshot) {
        // truncate forward
        if (this.index < this.history.length - 1) {
            this.history = this.history.slice(0, this.index + 1);
        }
        this.history.push(snap);
        // trim from start if beyond limit
        const over = this.history.length - this.opts.historyLimit;
        if (over > 0) {
            this.history.splice(0, over);
            this.index = this.history.length - 1;
        } else {
            this.index = this.history.length - 1;
        }
    }

    // IDs like "t:1", "f:2", "o:3" — must be unique across tags, fields, options.
    private genId(prefix: "t" | "f" | "o"): string {
        const props = this.builder.getProps();
        const taken = new Set<string>([
            ...(props.filters ?? []).map((t) => t.id),
            ...(props.fields ?? []).map((f) => f.id),
            ...(props.fields ?? []).flatMap(
                (f) => f.options?.map((o) => o.id) ?? [],
            ),
        ]);
        for (let i = 1; i < 10_000; i++) {
            const id = `${prefix}:${i}`;
            if (!taken.has(id)) return id;
        }
        throw new Error("Unable to generate id");
    }

    private emit<K extends keyof (EditorEvents & any)>(
        event: K,
        payload: (EditorEvents & any)[K],
    ) {
        // Reuse CanvasAPI’s bus so consumers have a single stream
        this.api.emit(event as any, payload as any);
    }

    /**
     * Suggest/filter candidate services against the current visible-group
     * (single tag) context.
     *
     * - Excludes services already used in this group.
     * - Applies capability presence, tag constraints, rate policy, and compiled policies.
     *
     * @param candidates    service ids to evaluate
     * @param ctx
     * @param ctx.tagId     active visible-group tag id
     * @param ctx.usedServiceIds  services already selected for this visible group (first is treated as "primary" for rate policy)
     * @param ctx.effectiveConstraints  effective constraints for the active tag (dripfeed/refill/cancel)
     * @param ctx.policies  raw JSON policies (will be compiled via compilePolicies)
     * @param ctx.fallback  fallback/rate settings (defaults applied if omitted)
     */
    public filterServicesForVisibleGroup(
        candidates: Array<number | string>,
        ctx: {
            tagId: string;
            usedServiceIds: Array<number | string>;
            effectiveConstraints?: Partial<
                Record<"refill" | "cancel" | "dripfeed", boolean>
            >;
            policies?: unknown;
            fallback?: FallbackSettings;
        },
    ): ServiceCheck[] {
        const svcMap: DgpServiceMap =
            (this as any).opts?.serviceMap ??
            (this.builder as any).getServiceMap?.() ??
            {};

        const usedSet = new Set(ctx.usedServiceIds.map(String));
        const primary = ctx.usedServiceIds[0]; // group "primary" (first used); rate policy compares against this when present

        const fb: FallbackSettings = {
            requireConstraintFit: true,
            ratePolicy: { kind: "lte_primary" },
            selectionStrategy: "priority",
            mode: "strict",
            ...(ctx.fallback ?? {}),
        };

        // Compile policies once here; you asked for the evaluate path to call compilePolicies.
        const evaluatePoliciesRaw = (
            raw: unknown,
            serviceIds: Array<number | string>,
            tagId: string,
        ) => {
            const { policies } = compilePolicies(raw);
            return evaluateServicePolicies(policies, serviceIds, svcMap, tagId);
        };

        const out: ServiceCheck[] = [];

        for (const id of candidates) {
            // Skip already-used services in this group
            if (usedSet.has(String(id))) continue;

            const cap = svcMap[Number(id)];
            if (!cap) {
                out.push({
                    id,
                    ok: false,
                    fitsConstraints: false,
                    passesRate: false,
                    passesPolicies: false,
                    reasons: ["missing_capability"],
                });
                continue;
            }

            // Constraints (only flags explicitly true at tag are "required")
            const fitsConstraints = constraintFitOk(
                svcMap,
                cap.id,
                ctx.effectiveConstraints ?? {},
            );

            // Rate policy vs primary (if any); if no primary, consider pass
            const passesRate =
                primary == null ? true : rateOk(svcMap, id, primary, fb);

            // Policies: compile + evaluate with current used + candidate
            const polRes = evaluatePoliciesRaw(
                ctx.policies ?? [],
                [...ctx.usedServiceIds, id],
                ctx.tagId,
            );
            const passesPolicies = polRes.ok;

            const reasons: ServiceCheck["reasons"] = [];
            if (!fitsConstraints) reasons.push("constraint_mismatch");
            if (!passesRate) reasons.push("rate_policy");
            if (!passesPolicies) reasons.push("policy_error");

            out.push({
                id,
                ok: fitsConstraints && passesRate && passesPolicies,
                fitsConstraints,
                passesRate,
                passesPolicies,
                policyErrors: polRes.errors.length ? polRes.errors : undefined,
                policyWarnings: polRes.warnings.length
                    ? polRes.warnings
                    : undefined,
                reasons,
                cap,
                rate: toFiniteNumber(cap.rate),
            });
        }

        return out;
    }
}

function nextCopyLabel(old: string): string {
    // "Label" -> "Label (copy)", "Label (copy)" -> "Label (copy 2)"
    // noinspection RegExpUnnecessaryNonCapturingGroup
    const m = old.match(/^(.*?)(?:\s*\(copy(?:\s+(\d+))?\))$/i);
    if (!m) return `${old} (copy)`;
    const stem = m[1].trim();
    const n = m[2] ? parseInt(m[2], 10) + 1 : 2;
    return `${stem} (copy ${n})`;
}

function nextCopyName(old?: string): string | undefined {
    if (!old) return undefined;
    // "name" -> "name_copy", "name_copy" -> "name_copy2", "name_copy2" -> "name_copy3"
    const m = old.match(/^(.*?)(_copy(\d+)?)$/i);
    if (!m) return `${old}_copy`;
    const stem = m[1];
    const n = m[3] ? parseInt(m[3], 10) + 1 : 2;
    return `${stem}_copy${n}`;
}

function defaultOptionIdStrategy(old: string): string {
    // "basic" -> "basic_copy" / "basic_copy2"…
    return nextCopyId(old);
}

function nextCopyId(old: string): string {
    // "tag_1" -> "tag_1_copy" or bumps trailing copy N
    // noinspection RegExpUnnecessaryNonCapturingGroup
    const m = old.match(/^(.*?)(?:_copy(\d+)?)$/i);
    if (!m) return `${old}_copy`;
    const stem = m[1];
    const n = m[2] ? parseInt(m[2], 10) + 1 : 2;
    return `${stem}_copy${n}`;
}

function bumpSuffix(old: string): string {
    // "foo_copy" -> "foo_copy2", "foo_copy2" -> "foo_copy3"
    const m = old.match(/^(.*?)(\d+)$/);
    if (!m) return `${old}2`;
    const stem = m[1];
    return `${stem}${parseInt(m[2], 10) + 1}`;
}

// Accept only these shapes; drop everything else.
type QuantityRule = { valueBy: "value" | "length" | "eval"; code?: string };

function normalizeQuantityRule(input: unknown): QuantityRule | undefined {
    if (!input || typeof input !== "object") return undefined;
    const v = input as any;
    const vb = v.valueBy;
    if (vb !== "value" && vb !== "length" && vb !== "eval") return undefined;

    const out: QuantityRule = { valueBy: vb };
    if (vb === "eval" && typeof v.code === "string" && v.code.trim()) {
        out.code = v.code;
    }
    // For non-eval, any provided code is dropped.
    return out;
}

// ---- Policy evaluation (compiled rules) -------------------------------------

function evaluateServicePolicies(
    rules: DynamicRule[] | undefined,
    svcIds: (string | number)[],
    svcMap: DgpServiceMap,
    tagId: string,
): { ok: boolean; errors: string[]; warnings: string[] } {
    const errors: string[] = [];
    const warnings: string[] = [];
    if (!rules || !rules.length) return { ok: true, errors, warnings };

    const relevant = rules.filter(
        (r) =>
            r.subject === "services" &&
            (r.scope === "visible_group" || r.scope === "global"),
    );

    for (const r of relevant) {
        const ids = svcIds.filter((id) =>
            matchesRuleFilter(svcMap[Number(id)], r, tagId),
        );
        const projection = r.projection || "service.id";
        const values = ids.map((id) =>
            policyProjectValue(svcMap[Number(id)], projection),
        );

        let ok = true;
        switch (r.op) {
            case "all_equal":
                ok = values.length <= 1 || values.every((v) => v === values[0]);
                break;
            case "unique": {
                const uniq = new Set(values.map((v) => String(v)));
                ok = uniq.size === values.length;
                break;
            }
            case "no_mix": {
                const uniq = new Set(values.map((v) => String(v)));
                ok = uniq.size <= 1;
                break;
            }
            case "all_true":
                ok = values.every((v) => !!v);
                break;
            case "any_true":
                ok = values.some((v) => !!v);
                break;
            case "max_count": {
                const n = typeof r.value === "number" ? r.value : NaN;
                ok = Number.isFinite(n) ? values.length <= n : true;
                break;
            }
            case "min_count": {
                const n = typeof r.value === "number" ? r.value : NaN;
                ok = Number.isFinite(n) ? values.length >= n : true;
                break;
            }
            default:
                ok = true;
        }

        if (!ok) {
            if ((r.severity ?? "error") === "error")
                errors.push(r.id ?? "policy_error");
            else warnings.push(r.id ?? "policy_warning");
        }
    }

    return { ok: errors.length === 0, errors, warnings };
}

function policyProjectValue(
    cap: DgpServiceCapability | undefined,
    projection: string,
) {
    if (!cap) return undefined;
    const key = projection.startsWith("service.")
        ? projection.slice(8)
        : projection;
    return (cap as any)[key];
}

function matchesRuleFilter(
    cap: DgpServiceCapability | undefined,
    rule: DynamicRule,
    tagId: string,
): boolean {
    if (!cap) return false;
    const f = rule.filter;
    if (!f) return true;

    if (f.tag_id && !toStrSet(f.tag_id).has(String(tagId))) return false;
    if (
        f.handler_id &&
        !toStrSet(f.handler_id).has(String((cap as any).handler_id))
    )
        return false;
    if (
        f.platform_id &&
        !toStrSet(f.platform_id).has(String((cap as any).platform_id))
    )
        return false;

    // role is intentionally ignored at suggestion-time (unknown), as discussed.
    return true;
}

function toStrSet(v: string | string[] | number | number[]): Set<string> {
    const arr = Array.isArray(v) ? v : [v];
    const s = new Set<string>();
    for (const x of arr) s.add(String(x));
    return s;
}

type ServiceCheck = {
    id: number | string;
    ok: boolean;
    fitsConstraints: boolean;
    passesRate: boolean;
    passesPolicies: boolean;
    policyErrors?: string[];
    policyWarnings?: string[];
    reasons: Array<
        | "constraint_mismatch"
        | "rate_policy"
        | "policy_error"
        | "missing_capability"
    >;
    cap?: DgpServiceCapability;
    rate?: number;
};
```

---
#### 9


` File: src/react/canvas/events.ts`  [↑ Back to top](#index)

```ts
// Lightweight, typed event bus
export type EventMap = Record<string, unknown>;

export class EventBus<E extends EventMap> {
    private listeners = new Map<keyof E, Set<(p: any) => void>>();

    on<K extends keyof E>(event: K, handler: (payload: E[K]) => void): () => void {
        const set = this.listeners.get(event) ?? new Set();
        set.add(handler as any);
        this.listeners.set(event, set);
        return () => {
            set.delete(handler as any);
        };
    }

    once<K extends keyof E>(event: K, handler: (payload: E[K]) => void): () => void {
        const off = this.on(event, (p) => {
            off();
            handler(p);
        });
        return off;
    }

    emit<K extends keyof E>(event: K, payload: E[K]): void {
        const set = this.listeners.get(event);
        if (!set || set.size === 0) return;
        for (const h of Array.from(set)) try {
            (h as any)(payload);
        } catch { /* swallow */
        }
    }

    clear(): void {
        this.listeners.clear();
    }
}
```

---
#### 10


` File: src/react/canvas/selection.ts`  [↑ Back to top](#index)

```ts
// src/react/canvas/selection.ts
import type { Builder } from "../../core";
import type { ServiceProps, Tag, Field } from "../../schema";
import type { DgpServiceCapability } from "../../schema/provider";

export type Env = "client" | "workspace";

export type VisibleGroup = {
    tagId?: string;
    tag?: Tag;
    fields: Field[];
    fieldIds: string[];
    parentTags?: Tag[];
    childrenTags?: Tag[];
    /** In order of selection: tag base (unless overridden) then selected options */
    services?: DgpServiceCapability[];
};

// Returned by visibleGroup():
export type VisibleGroupResult =
    | { kind: "single"; group: VisibleGroup }
    | { kind: "multi"; groups: string[] };

type ChangeEvt = { ids: string[]; primary?: string };
type Listener = (e: ChangeEvt) => void;

const isTagId = (id: string) => typeof id === "string" && id.startsWith("t:");
const isOptionId = (id: string) =>
    typeof id === "string" && id.startsWith("o:");

export type SelectionOptions = {
    env?: Env;
    rootTagId?: string;
    /** Resolve service capability from an id (used for `services` array) */
    resolveService?: (id: any) => DgpServiceCapability | undefined;
};

export class Selection {
    private set = new Set<string>();
    private primaryId: string | undefined;
    private currentTagId: string | undefined;
    private onChangeFns: Listener[] = [];

    constructor(
        private readonly builder: Builder,
        private readonly opts: SelectionOptions = {},
    ) {}

    // ── Public mutators ──────────────────────────────────────────────────────
    replace(id?: string | null) {
        if (!id) return this.clear();
        this.set.clear();
        this.set.add(id);
        this.primaryId = id;
        this.updateCurrentTagFrom(id);
        this.emit();
    }

    add(id: string) {
        this.set.add(id);
        this.primaryId = id;
        this.updateCurrentTagFrom(id);
        this.emit();
    }

    remove(id: string) {
        if (!this.set.delete(id)) return;
        if (this.primaryId === id) {
            this.primaryId = this.set.values().next().value;
            if (this.primaryId) this.updateCurrentTagFrom(this.primaryId);
        }
        this.emit();
    }

    toggle(id: string) {
        if (this.set.has(id)) this.remove(id);
        else this.add(id);
    }

    many(ids: Iterable<string>, primary?: string) {
        this.set = new Set(ids);
        this.primaryId = primary ?? this.set.values().next().value;
        if (this.primaryId) this.updateCurrentTagFrom(this.primaryId);
        this.emit();
    }

    clear() {
        if (!this.set.size && !this.primaryId) return;
        this.set.clear();
        this.primaryId = undefined;
        this.emit();
    }

    // ── Read APIs ────────────────────────────────────────────────────────────
    all(): ReadonlySet<string> {
        return this.set;
    }

    has(id: string): boolean {
        return this.set.has(id);
    }

    primary(): string | undefined {
        return this.primaryId;
    }

    currentTag(): string | undefined {
        return this.currentTagId;
    }

    onChange(fn: Listener): () => void {
        this.onChangeFns.push(fn);
        return () => {
            const i = this.onChangeFns.indexOf(fn);
            if (i >= 0) this.onChangeFns.splice(i, 1);
        };
    }

    // ── Main: visible group snapshot (env-aware) ─────────────────────────────
    visibleGroup(): VisibleGroupResult {
        const props = this.builder.getProps() as ServiceProps;

        // WORKSPACE: >1 tag selected → return raw selection set
        if ((this.opts.env ?? "client") === "workspace") {
            const tagIds = Array.from(this.set).filter(isTagId);
            if (tagIds.length > 1) {
                return { kind: "multi", groups: Array.from(this.set) };
            }
        }

        const tagId = this.resolveTagContextId(props);
        if (!tagId)
            return { kind: "single", group: { fields: [], fieldIds: [] } };

        const group = this.computeGroupForTag(props, tagId);
        return { kind: "single", group };
    }

    // ── Internals ────────────────────────────────────────────────────────────
    private emit() {
        const payload: ChangeEvt = {
            ids: Array.from(this.set),
            primary: this.primaryId,
        };
        for (const fn of this.onChangeFns) fn(payload);
    }

    private updateCurrentTagFrom(id: string) {
        const props = this.builder.getProps() as ServiceProps;
        const tags = props.filters ?? [];
        const fields = props.fields ?? [];

        if (tags.some((t) => t.id === id)) {
            this.currentTagId = id;
            return;
        }
        const f = fields.find((x) => x.id === id);
        if (f?.bind_id) {
            this.currentTagId = Array.isArray(f.bind_id)
                ? f.bind_id[0]
                : f.bind_id;
            return;
        }

        if (isOptionId(id)) {
            const host = fields.find((x) =>
                (x.options ?? []).some((o) => o.id === id),
            );
            if (host?.bind_id) {
                this.currentTagId = Array.isArray(host.bind_id)
                    ? host.bind_id[0]
                    : host.bind_id;
                return;
            }
        }

        if (id.includes("::")) {
            const [fid] = id.split("::");
            const host = fields.find((x) => x.id === fid);
            if (host?.bind_id) {
                this.currentTagId = Array.isArray(host.bind_id)
                    ? host.bind_id[0]
                    : host.bind_id;
                return;
            }
        }
    }

    private resolveTagContextId(props: ServiceProps): string | undefined {
        if (this.currentTagId) return this.currentTagId;

        for (const id of this.set) if (isTagId(id)) return id;

        const fields = props.fields ?? [];
        for (const id of this.set) {
            const f = fields.find((x) => x.id === id);
            if (f?.bind_id)
                return Array.isArray(f.bind_id) ? f.bind_id[0] : f.bind_id;
        }

        for (const id of this.set) {
            if (isOptionId(id)) {
                const host = fields.find((x) =>
                    (x.options ?? []).some((o) => o.id === id),
                );
                if (host?.bind_id)
                    return Array.isArray(host.bind_id)
                        ? host.bind_id[0]
                        : host.bind_id;
            }
            if (id.includes("::")) {
                const [fid] = id.split("::");
                const host = fields.find((x) => x.id === fid);
                if (host?.bind_id)
                    return Array.isArray(host.bind_id)
                        ? host.bind_id[0]
                        : host.bind_id;
            }
        }

        return this.opts.rootTagId;
    }

    private computeGroupForTag(
        props: ServiceProps,
        tagId: string,
    ): VisibleGroup {
        const tags = props.filters ?? [];
        const fields = props.fields ?? [];
        const tagById = new Map(tags.map((t) => [t.id, t]));
        const tag = tagById.get(tagId);

        // selection-aware include/exclude via BUTTON TRIGGERS (options + button fields)
        const selectedTriggerIds = this.selectedButtonTriggerIds(props);
        const incMap = props.includes_for_buttons ?? {};
        const excMap = props.excludes_for_buttons ?? {};

        const trigInclude = new Set<string>();
        const trigExclude = new Set<string>();
        for (const triggerId of selectedTriggerIds) {
            for (const id of incMap[triggerId] ?? []) trigInclude.add(id);
            for (const id of excMap[triggerId] ?? []) trigExclude.add(id);
        }

        const tagInclude = new Set(tag?.includes ?? []);
        const tagExclude = new Set(tag?.excludes ?? []);

        // field pool
        const pool = new Map<string, Field>();
        for (const f of fields) {
            if (this.isBoundTo(f, tagId)) pool.set(f.id, f);
            if (tagInclude.has(f.id)) pool.set(f.id, f);
            if (trigInclude.has(f.id)) pool.set(f.id, f);
        }
        for (const id of tagExclude) pool.delete(id);
        for (const id of trigExclude) pool.delete(id);

        // optional order_for_tags
        const order = props.order_for_tags?.[tagId];
        const visible = order
            ? (
                  order.map((fid) => pool.get(fid)).filter(Boolean) as Field[]
              ).concat(
                  Array.from(pool.values()).filter(
                      (f) => !order.includes(f.id),
                  ),
              )
            : Array.from(pool.values());

        // ancestry & immediate children
        const parentTags: Tag[] = [];
        let cur = tag?.bind_id;
        const guard = new Set<string>();
        while (cur && !guard.has(cur)) {
            const t = tagById.get(cur);
            if (!t) break;
            parentTags.push(t);
            guard.add(cur);
            cur = t.bind_id;
        }
        const childrenTags = tags.filter((t) => t.bind_id === tagId);

        // services: tag base (unless overridden by base option) → selected options with service_id
        const services: DgpServiceCapability[] = [];
        const resolve = this.opts.resolveService;

        // 1) Start with tag base (if any)
        let baseAddedFromTag = false;
        if (tag?.service_id != null) {
            const cap =
                resolve?.(tag.service_id) ??
                ({ id: tag.service_id } as DgpServiceCapability);
            services.push(cap);
            baseAddedFromTag = true;
        }

        // 2) Walk selected ids in insertion order; if an OPTION maps to a service, add it.
        //    If the FIRST base-role option is encountered, it overrides the tag base (if any).
        let baseOverridden = false;
        for (const selId of this.set) {
            const opt = this.findOptionById(fields, selId);
            if (!opt || opt.service_id == null) continue;

            const role = (opt.pricing_role ?? (opt as any).role ?? "base") as
                | "base"
                | "utility"
                | "addon";
            const cap =
                resolve?.(opt.service_id) ??
                ({ id: opt.service_id } as DgpServiceCapability);

            if (role === "base") {
                if (!baseOverridden) {
                    if (baseAddedFromTag && services.length > 0) {
                        services[0] = cap; // override tag base
                    } else {
                        services.unshift(cap);
                    }
                    baseOverridden = true;
                } else {
                    // additional base entries (rare) — append after
                    services.push(cap);
                }
            } else {
                services.push(cap);
            }
        }

        return {
            tagId,
            tag,
            fields: visible,
            fieldIds: visible.map((f) => f.id),
            parentTags,
            childrenTags,
            services,
        };
    }

    private isBoundTo(f: Field, tagId: string): boolean {
        if (!f.bind_id) return false;
        return Array.isArray(f.bind_id)
            ? f.bind_id.includes(tagId)
            : f.bind_id === tagId;
    }

    /**
     * Return the selected "button trigger" ids that drive includes/excludes:
     *  - option ids (o:*)
     *  - field ids where field.button === true (option-less buttons)
     *  - legacy bridge for "fieldId::optionId"
     */
    private selectedButtonTriggerIds(props: ServiceProps): string[] {
        const out: string[] = [];
        const fields = props.fields ?? [];

        for (const id of this.set) {
            // option buttons
            if (isOptionId(id)) {
                out.push(id);
                continue;
            }

            // field-as-button (option-less buttons)
            const f = fields.find((x) => x.id === id);
            // guard via `as any` in case older builds don't have .button normalized yet
            if ((f as any)?.button === true) {
                out.push(id);
                continue;
            }

            // legacy bridge: "fieldId::optionId"
            if (id.includes("::")) {
                const [fid, legacyOid] = id.split("::");
                if (!fid || !legacyOid) continue;
                const host = fields.find((x) => x.id === fid);
                const global =
                    host?.options?.find((o) => o.id === legacyOid)?.id ??
                    legacyOid;
                out.push(global);
            }
        }
        return out;
    }

    private findOptionById(fields: Field[], selId: string) {
        if (isOptionId(selId)) {
            for (const f of fields) {
                const o = f.options?.find((x) => x.id === selId);
                if (o) return o;
            }
        }
        if (selId.includes("::")) {
            const [fid, oid] = selId.split("::");
            const f = fields.find((x) => x.id === fid);
            const o = f?.options?.find((x) => x.id === oid || x.id === selId);
            if (o) return o;
        }
        return undefined;
    }
}
```


---
*Generated with [Prodex](https://github.com/emxhive/prodex) — Codebase decoded.*
<!-- PRODEx v1.4.11 | 2026-01-20T14:32:20.260Z -->