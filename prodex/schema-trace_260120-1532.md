*Generated by [Prodex](https://github.com/emxhive/prodex#readme)*
> Note for LLMs: `Lx-Ly` ranges refer to lines in this Prodex trace file, not the original source files. Index metadata is provided via the HTML comment markers in this section.

# Index
<!-- PRODEX_INDEX_RANGE: L8-L16 -->
<!-- PRODEX_FILE_COUNT: 9 -->
<!-- PRODEX_INDEX_LIST_START -->
- [src/schema/canvas-types.ts](#1)  L20-L92
- [src/schema/editor.ts](#2)  L93-L128
- [src/schema/editor.types.ts](#3)  L129-L171
- [src/schema/graph.ts](#4)  L172-L212
- [src/schema/index.ts](#5)  L213-L455
- [src/schema/order.ts](#6)  L456-L601
- [src/schema/policies.ts](#7)  L602-L618
- [src/schema/provider.ts](#8)  L619-L644
- [src/schema/validation.ts](#9)  L645-L769
<!-- PRODEX_INDEX_LIST_END -->

---
---
#### 1


` File: src/schema/canvas-types.ts`  [↑ Back to top](#index)

```ts
import type { GraphSnapshot, GraphNode, GraphEdge, EdgeKind } from "./graph";
import { CommentMessage, CommentThread } from "../react/canvas/comments";

export type Viewport = { x: number; y: number; zoom: number };

export type NodePos = { x: number; y: number };
export type NodePositions = Record<string, NodePos>;

export type DraftWire = { from: string; kind: EdgeKind };

export type CanvasState = {
    graph: GraphSnapshot;
    positions: NodePositions;
    selection: Set<string>;
    highlighted: Set<string>;
    hoverId?: string;
    viewport: Viewport;
    draftWire?: DraftWire;
    version: number; // bump on any state change
};

export type CanvasEvents = {
    "graph:update": GraphSnapshot;
    "state:change": CanvasState;
    "selection:change": { ids: string[] };
    "viewport:change": Viewport;
    "hover:change": { id?: string };
    "wire:preview": { from: string; to?: string; kind: EdgeKind };
    "wire:commit": { from: string; to: string; kind: EdgeKind };
    "wire:cancel": { from: string };
    error: { message: string; code?: string; meta?: any };
    "comment:thread:create": { thread: CommentThread };
    "comment:thread:update": { thread: CommentThread };
    "comment:thread:delete": { threadId: string };
    "comment:message:create": { threadId: string; message: CommentMessage };
    "comment:resolve": { thread: CommentThread; resolved: boolean };
    "comment:move": { thread: CommentThread };
    "comment:select": { threadId?: string };
    "edge:change": EdgeKind;
    "comment:sync": {
        op:
            | "create_thread"
            | "add_message"
            | "edit_message"
            | "delete_message"
            | "move_thread"
            | "resolve_thread"
            | "delete_thread";
        threadId: string;
        messageId?: string;
        status: "scheduled" | "retrying" | "succeeded" | "failed" | "cancelled";
        attempt: number;
        nextDelayMs?: number;
        error?: any;
    };
};

export type NodeView = GraphNode & { position?: NodePos };
export type EdgeView = GraphEdge;

export type CanvasOptions = {
    initialViewport?: Partial<Viewport>;
    autoEmitState?: boolean; // default true
};
```

---
#### 2


` File: src/schema/editor.ts`  [↑ Back to top](#index)

```ts
import type { ServiceProps } from "./index";
import { CanvasState } from "./canvas-types";

export type CommentNode = {
    id: string;
    text: string;
    status: "open" | "resolved";
    anchor?: { kind: "tag" | "field" | "option"; id: string };
    replies?: Array<{
        id: string;
        text: string;
        created_at: string;
        author?: string;
    }>;
    xy?: { x: number; y: number };
    meta?: Record<string, unknown>;
};

export type EdgeRoute = { id: string; points: Array<{ x: number; y: number }> };
export type LayoutState = { canvas: CanvasState; edges?: EdgeRoute[] };

export type EditorSnapshot = {
    props: ServiceProps;
    layout?: LayoutState;
    comments?: CommentNode[];
    meta?: Record<string, unknown>;
};
```

---
#### 3


` File: src/schema/editor.types.ts`  [↑ Back to top](#index)

```ts
import type { ServiceProps } from "./index";
import { SelectionOptions } from "../react/canvas/selection";

export type EditorEvents = {
    "editor:command": { name: string; payload?: any };
    "editor:change": { props: ServiceProps; reason: string; command?: string };
    "editor:undo": { stackSize: number; index: number };
    "editor:redo": { stackSize: number; index: number };
    "editor:error": { message: string; code?: string; meta?: any };
};

export type Command = {
    name: string;
    do(): void;
    undo(): void;
};

// wherever EditorOptions is declared
export type EditorOptions = {
    historyLimit?: number;
    validateAfterEach?: boolean;

    /** Sync existence check; return true if the service exists. */
    serviceExists?: (id: number) => boolean;

    /** Optional local index; used if serviceExists is not provided. */
    serviceMap?: Record<number, unknown>;

    /** Raw policies JSON; will be compiled on demand by filterServicesForVisibleGroup. */
    policiesRaw?: unknown;
    selectionProps?: SelectionOptions;
};

export type ConnectKind = "bind" | "include" | "exclude";
```

---
#### 4


` File: src/schema/graph.ts`  [↑ Back to top](#index)

```ts
import type { NodeProps } from "reactflow";

export type NodeKind = "tag" | "field" | "comment" | "option";
export type EdgeKind =
    | "child"
    | "bind"
    | "include"
    | "exclude"
    | "error"
    | "anchor";

export type GraphNode = {
    id: string;
    kind: NodeKind;
    bind_type?: "bound" | "utility" | null; // for fields: bound vs unbound helper
    errors?: string[]; // node-local error codes
    label: string;
};

export type GraphEdge = {
    from: string;
    to: string;
    kind: EdgeKind;
    meta?: Record<string, unknown>;
};

export type GraphSnapshot = { nodes: GraphNode[]; edges: GraphEdge[] };

export type FlowNode = NodeProps<{
    node: GraphNode;
    [x: string]: any;
}>;
```

---
#### 5


` File: src/schema/index.ts`  [↑ Back to top](#index)

```ts
// persisted schema + shared types
export type PricingRole = "base" | "utility";
export type FieldType = "custom" | (string & {});

/** ── Marker types (live inside meta; non-breaking) ───────────────────── */
export type QuantityMark = {
    quantity?: {
        valueBy: "value" | "length" | "eval";
        code?: string;
        multiply?: number;
        clamp?: { min?: number; max?: number };
        fallback?: number;
    };
};

export type UtilityMark = {
    utility?: {
        rate: number;
        mode: "flat" | "per_quantity" | "per_value" | "percent";
        valueBy?: "value" | "length"; // only for per_value; default 'value'
        percentBase?: "service_total" | "base_service" | "all";
        label?: string;
    };
};

export type WithQuantityDefault = { quantityDefault?: number };

/** ---------------- Core schema (as you designed) ---------------- */

export interface BaseFieldUI {
    name?: string;
    label: string;
    required?: boolean;
    /** Host-defined prop names → typed UI nodes */
    ui?: Record<string, Ui>;
    /** Host-defined prop names → runtime default values (untyped base) */
    defaults?: Record<string, unknown>;
}

const ui: Record<string, Ui> = {
    multiselect: {
        type: "boolean",
    },
    search: {
        type: "boolean",
    },
    autocomplete: {
        type: "boolean",
    },

    autocompleteItems: {
        type: "array",
        item: {
            type: "string",
        }
    }
}

export type Ui = UiString | UiNumber | UiBoolean | UiAnyOf | UiArray | UiObject;

/** string */
export interface UiString {
    type: "string";
    enum?: string[];
    minLength?: number;
    maxLength?: number;
    pattern?: string;
    format?: string;
}

/** number */
export interface UiNumber {
    type: "number";
    minimum?: number;
    maximum?: number;
    multipleOf?: number;
}

/** boolean */
export interface UiBoolean {
    type: "boolean";
}

/** enumerated choices */
export interface UiAnyOf {
    type: "anyOf";
    multiple?: boolean;
    items: Array<{
        type: "string" | "number" | "boolean";
        title?: string;
        description?: string;
        value: string | number | boolean;
    }>;
}

/** arrays: homogeneous (item) or tuple (items) */
export interface UiArray {
    type: "array";
    item?: Ui; // schema for each element (homogeneous)
    items?: Ui[]; // tuple form
    minItems?: number;
    maxItems?: number;
    uniqueItems?: boolean;
}

/** objects: nested props */
export interface UiObject {
    type: "object";
    fields: Record<string, Ui>;
    required?: string[]; // nested required
    order?: string[]; // render hint
}

/** ---------------- Typed defaults helpers ---------------- */

/**
 * UiValue<U>: given a Ui node U, infer the runtime value type.
 */
export type UiValue<U extends Ui> =
    // primitives
    U extends { type: "string" }
        ? string
        : U extends { type: "number" }
          ? number
          : U extends { type: "boolean" }
            ? boolean
            : // anyOf
              U extends { type: "anyOf"; multiple: true }
              ? Array<U["items"][number]["value"]>
              : U extends { type: "anyOf" }
                ? U["items"][number]["value"]
                : // array (homogeneous vs tuple)
                  U extends { type: "array"; item: infer I extends Ui }
                  ? Array<UiValue<I>>
                  : U extends { type: "array"; items: infer T extends Ui[] }
                    ? { [K in keyof T]: UiValue<T[K]> }
                    : // object (nested fields)
                      U extends {
                            type: "object";
                            fields: infer F extends Record<string, Ui>;
                        }
                      ? { [K in keyof F]?: UiValue<F[K]> }
                      : unknown;

/**
 * FieldWithTypedDefaults<T>: same shape as BaseFieldUI, but:
 *  - ui is a concrete map T (propName → Ui node)
 *  - defaults are auto-typed from T via UiValue
 */
export type FieldWithTypedDefaults<T extends Record<string, Ui>> = Omit<
    BaseFieldUI,
    "ui" | "defaults"
> & {
    ui: T;
    defaults?: Partial<{ [K in keyof T]: UiValue<T[K]> }>;
};

export type FieldOption = {
    id: string;
    label: string;
    value?: string | number;
    service_id?: number;
    pricing_role?: PricingRole;
    meta?: Record<string, unknown> & UtilityMark & WithQuantityDefault;
};

export type Field = BaseFieldUI & {
    id: string;
    type: FieldType; // only 'custom' is reserved
    bind_id?: string | string[];
    name?: string; // omit if options map to services
    options?: FieldOption[];
    component?: string; // required if type === 'custom'
    pricing_role?: PricingRole; // default 'base'
    meta?: Record<string, unknown> & QuantityMark & UtilityMark;
} & (
        | {
              button?: false;
              service_id?: undefined;
          }
        | {
              button: true;
              service_id?: number;
          }
    );

export type FlagKey = "refill" | "cancel" | "dripfeed";
export type Tag = {
    id: string;
    label: string;
    bind_id?: string;
    service_id?: number;
    includes?: string[];
    excludes?: string[];
    meta?: Record<string, unknown> & WithQuantityDefault;
    /**
     * Which flags are set for this tag. If a flag is not set, it's inherited from the nearest ancestor with a value set.
     */
    constraints?: Partial<Record<FlagKey, boolean>>;
    /** Which ancestor defined the *effective* value for each flag (nearest source). */
    constraints_origin?: Partial<Record<FlagKey, string>>; // tagId

    /**
     * Present only when a child explicitly set a different value but was overridden
     * by an ancestor during normalisation.
     */
    constraints_overrides?: Partial<
        Record<
            FlagKey,
            { from: boolean; to: boolean; origin: string } // child explicit -> effective + where it came from
        >
    >;
};

export type ServiceProps = {
    order_for_tags?: Record<string, string[]>;
    filters: Tag[];
    fields: Field[];
    includes_for_buttons?: Record<string, string[]>;
    excludes_for_buttons?: Record<string, string[]>;
    schema_version?: string;
    fallbacks?: ServiceFallback;
};

// Ids
export type ServiceIdRef = number | string; // provider service id
export type NodeIdRef = string; // tag.id or option.id

export type ServiceFallback = {
    /** Node-scoped fallbacks: prefer these when that node’s primary service fails */
    nodes?: Record<NodeIdRef, ServiceIdRef[]>;
    /** Primary→fallback list used when no node-scoped entry is present */
    global?: Record<ServiceIdRef, ServiceIdRef[]>;
};
```

---
#### 6


` File: src/schema/order.ts`  [↑ Back to top](#index)

```ts
// src/schema/order.ts
import { UtilityMark, WithQuantityDefault } from "./index";

export interface ButtonValue {
    id: string; // option id OR field id (for option-less buttons)
    value: string | number; // host’s payload
    // Enrichment added by InputWrapper (not required from host):
    service_id?: number;
    pricing_role?: "base" | "utility";
    meta?: Record<string, unknown> & UtilityMark & WithQuantityDefault;
}
// Primitive values a client can send for form inputs and utility inputs.
export type Scalar = string | number | boolean | ButtonValue | null;

// How utility charges apply.
export type UtilityMode = "flat" | "per_quantity" | "per_value" | "percent";

// Quantity “marker” contract hosts can place under Field.meta.quantity.
export type QuantityRule = {
    valueBy: "value" | "length" | "eval";
    code?: string; // optional client-side evaluator (use with care / sandbox)
};

// One utility line item derived from a field/option marked as pricing_role: 'utility'.
export type UtilityLineItem = {
    nodeId: string; // fieldId or optionId that carries the utility marker
    mode: UtilityMode;
    rate: number; // finite number (validated)
    inputs: {
        quantity: number; // resolved snapshot quantity
        value?: Scalar | Scalar[]; // present for per_value modes (when applicable)
        valueBy?: "value" | "length" | "eval";
        evalCodeUsed?: boolean; // true if client executed an eval path
    };
};

// Fallbacks shape stored on ServiceProps (formalized).
export type ServiceFallbacks = {
    nodes?: Record<string, Array<string | number>>; // nodeId -> candidate service ids
    global?: Record<string | number, Array<string | number>>; // primary -> candidate service ids
};

// Dev-only diagnostics for pruned/flagged fallbacks.
export type FallbackDiagnostics = {
    scope: "node" | "global";
    nodeId?: string; // for scope:'node'
    primary: string | number;
    candidate: string | number;
    reasons: Array<
        | "rate_violation"
        | "constraint_mismatch"
        | "unknown_service"
        | "ambiguous_context"
    >;
};

// Single-tag evaluation context included in the snapshot meta.
export type SnapshotContext = {
    /** The single active tag id for this order */
    tag: string;

    /** Effective (post-propagation) constraints on that tag */
    constraints: Partial<Record<"refill" | "cancel" | "dripfeed", boolean>>;

    /**
     * Per-node evaluation context:
     * - For the active tag node itself: the same tag id.
     * - For an option node: parent's field.bind_id must include this tag to be applicable; otherwise null.
     * - For a field node (optional to include later): same rule as option, derived from field.bind_id.
     */
    nodeContexts: Record<string /* nodeId */, string | null>;

    /** Client pruning policy used (so server can mirror/compare). */
    policy: {
        ratePolicy: { kind: "lte_primary" | "none"; thresholdPct?: number };
        requireConstraintFit: boolean; // node-level constraint enforcement on client
    };
};

// Stable order snapshot contract (client -> server).
export type OrderSnapshot = {
    version: "1";
    mode: "prod" | "dev";
    builtAt: string; // ISO timestamp

    // ── Single-context selection (the only active tag) ──
    selection: {
        tag: string; // tag id (context)
        fields: Array<{
            id: string; // field id
            type: string; // field.type at build time
            selectedOptions?: string[]; // option ids if option-based (always array if present)
        }>;
    };

    // ── Inputs for the backend ──
    inputs: {
        form: Record<string, Scalar | Scalar[]>; // name-keyed values for non-option fields
        selections: Record<string, string[]>; // fieldId -> option ids[]
    };

    // ── Resolved quantity (+ provenance) ──
    quantity: number;
    quantitySource: {
        kind: "field" | "tag" | "option" | "default";
        id?: string; // which field/tag/option provided it
        rule?: QuantityRule; // when kind === 'field'
        defaultedFromHost?: boolean; // true if host default used
    };

    // ── Selected primaries ──
    services: Array<string | number>; // deduped union of all primaries
    serviceMap: Record<string, Array<string | number>>; // nodeId -> primary ids[]

    // ── Client-pruned fallbacks (server will still do final pruning) ──
    fallbacks?: {
        nodes?: Record<string, Array<string | number>>; // only nodes present in this selection
        global?: Record<string | number, Array<string | number>>; // only primaries present in `services`
    };

    // ── Utility line items ──
    utilities?: UtilityLineItem[];

    // ── Dev-only warnings (safe to ignore server-side) ──
    warnings?: {
        utility?: Array<{ nodeId: string; reason: string }>;
        fallbacks?: FallbackDiagnostics[];
    };

    // ── Optional provenance and live context for server-side double-checks ──
    meta?: {
        schema_version?: string;
        workspaceId?: string;
        builder?: { commit?: string };
        context?: SnapshotContext;
    };
};
```

---
#### 7


` File: src/schema/policies.ts`  [↑ Back to top](#index)

```ts
// src/schema/policies.ts
import type { DynamicRule } from './validation';

/** Exported alias so the schema generator can target an array */
export type AdminPolicies = DynamicRule[];

// Re-export (optional convenience)
export type { DynamicRule };
```

---
#### 8


` File: src/schema/provider.ts`  [↑ Back to top](#index)

```ts
/** Minimal capability shape sourced from DgpService */
export type DgpServiceCapability = {
    id: number;
    name?: string;                    // human-friendly name
    key?: string;                     // provider key if relevant
    rate?: number;                    // canonical numeric rate
    min?: number;                     // min order qty
    max?: number;                     // max order qty
    dripfeed?: boolean;
    refill?: boolean;
    cancel?: boolean;
    estimate?: { start?: number | null; speed?: number | null; average?: number | null };
    meta?: Record<string, unknown>;
    [x: string]: any;
};

export type DgpServiceMap = Record<number, DgpServiceCapability>; // id -> capability
```

---
#### 9


` File: src/schema/validation.ts`  [↑ Back to top](#index)

```ts
import { DgpServiceMap } from "./provider";

export type ValidationCode =
    // structure
    | "root_missing"
    | "cycle_in_tags"
    | "bad_bind_reference"
    // identity & labels
    | "duplicate_id"
    | "duplicate_tag_label"
    | "duplicate_field_name"
    | "label_missing"
    // visibility & option maps
    | "duplicate_visible_label"
    | "bad_option_key"
    | "option_include_exclude_conflict"
    // service/input
    | "service_field_missing_service_id"
    | "user_input_field_has_service_option"
    // rates & pricing roles
    | "rate_mismatch_across_base"
    | "utility_without_base"
    // constraints
    | "unsupported_constraint"
    | "constraint_contradiction"
    // custom component
    | "custom_component_missing"
    | "policy_violation"
    | "field_unbound"
    | "constraint_overridden"
    | "unsupported_constraint_option" // option's service can't meet T's effective constraint
    | "custom_component_unresolvable"
    // utilities / quantity markers
    | "quantity_multiple_markers"
    | "utility_with_service_id"
    | "utility_missing_rate"
    | "utility_invalid_mode"
    // fallbacks
    | "fallback_bad_node"
    | "fallback_unknown_service"
    | "fallback_cycle"
    | "fallback_no_primary"
    | "fallback_rate_violation"
    | "fallback_constraint_mismatch"
    | "fallback_no_tag_context";

export type ValidationError = {
    code: ValidationCode;
    nodeId?: string; // tag/field/option id
    details?: Record<string, unknown> & {
        affectedIds?: string[]
    };
};

export type DynamicRule = {
    id: string;
    scope: "global" | "visible_group";
    subject: "services";
    filter?: {
        role?: "base" | "utility" | "both";
        handler_id?: number | number[];
        platform_id?: number | number[];
        tag_id?: string | string[];
        field_id?: string | string[];
    };
    projection?:
        | "service.type"
        | "service.key"
        | "service.rate"
        | "service.handler_id"
        | "service.platform_id"
        | "service.dripfeed"
        | string;
    op:
        | "all_equal"
        | "unique"
        | "no_mix"
        | "all_true"
        | "any_true"
        | "max_count"
        | "min_count";
    value?: number | boolean; // for max/min/all_true/any_true
    severity?: "error" | "warning";
    message?: string;
};

export type ValidatorOptions = {
    serviceMap?: DgpServiceMap;
    allowUnsafe?: boolean;
    selectedOptionKeys?: string[];
    globalUtilityGuard?: boolean;
    policies?: DynamicRule[]; // ← dynamic rules from super admin
    fallbackSettings?: FallbackSettings;
};

export type RatePolicy =
    | { kind: "lte_primary" }
    | { kind: "within_pct"; pct: number }
    | {
          kind: "at_least_pct_lower";
          pct: number;
      };

export type FallbackSettings = {
    /** Require fallbacks to satisfy tag constraints (dripfeed/refill/cancel) when a tag context is known. Default: true */
    requireConstraintFit?: boolean;
    /** Rate rule policy. Default: { kind: 'lte_primary' } i.e. candidate.rate <= primary.rate */
    ratePolicy?: RatePolicy;
    /** When multiple candidates remain, choose first (priority) or cheapest. Default: 'priority' */
    selectionStrategy?: "priority" | "cheapest";
    /** Validation mode: 'strict' → node-scoped violations reported as ValidationError; 'dev' → only collect diagnostics. Default: 'strict' */
    mode?: "strict" | "dev";
};
```


---
*Generated with [Prodex](https://github.com/emxhive/prodex) — Codebase decoded.*
<!-- PRODEx v1.4.11 | 2026-01-20T14:32:20.260Z -->